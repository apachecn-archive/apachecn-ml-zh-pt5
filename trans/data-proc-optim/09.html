<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>
<div><div><h1 id="_idParaDest-121"><em class="italic"> <a id="_idTextAnchor124"/>第七章</em>:特征工程</h1>
			<p>既然我们已经讨论了如何根据需要形成我们的数据，那么让我们来讨论一下特征工程。</p>
			<p>如果你想创建一个机器学习模型，你输入数据。该输入数据包括算法创建模型所需的特征。这些特征需要具有特定的特征；例如，它不能有空值，或者数据需要符合特定的概率分布。</p>
			<p>通过特征工程，您可以准备输入数据集，使其符合算法的要求，还可以提高机器学习模型的性能，从而使用我们已有的数据创建新的要素。</p>
			<p>因此，在本章中，我们将讨论以下主题:</p>
			<ul>
				<li>处理缺失值</li>
				<li>处理异常值</li>
				<li>扔掉</li>
				<li>变量变换</li>
				<li>一键编码</li>
				<li>特征分割</li>
				<li>缩放比例</li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>技术要求</h1>
			<p>Optimus 可以与多种后端技术一起处理数据，包括 GPU。对于 GPU，Optimus 用的是<strong class="bold"> RAPIDS </strong>，需要 NVIDIA 卡。关于需求的更多信息，请参见<a href="B17166_01_Final_SB_epub.xhtml#_idTextAnchor015"> <em class="italic">第一章</em> </a>的<em class="italic"> GPU 配置</em>部分。</p>
			<p>你可以在 https://github . com/packt publishing/Data-Processing-with-Optimus 找到本章的所有代码。</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor126"/>处理缺失值</h1>
			<p>处理数据时最常见的情况之一是在数据集中查找缺失值。</p>
			<p>处理缺失值<a id="_idIndexMarker416"/>很重要，因为，例如，如果你想让许多机器学习算法正常工作，它们就不能有缺失值。或者，如果您正在创建一个报告，您不希望显示包含空值聚合的统计信息。</p>
			<p>需要注意的是，Optimus 将<code>None</code>和<code>NaN</code> ( <strong class="bold">不是数字</strong>)值视为可互换值，以表示空值。要处理它们，你可以做两件事:删除数据或估算数据。在这一节中，我们将展示 Optimus 如何帮助完成这两项任务，而不提供何时使用每种方法的详尽统计解释。让我们看看擎天柱如何帮助我们完成这两项任务。</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor127"/>删除数据</h2>
			<p>在这种情况下，我们将看到如何使用<a id="_idIndexMarker417"/>删除包含缺失值的整行或整列。</p>
			<h3>拆卸<a id="_idTextAnchor128"/>一排</h3>
			<p>首先，让我们用许多列中的一些空值创建一个数据帧<a id="_idIndexMarker419"/>:</p>
			<pre>import numpy as np
df = op.create.dataframe({
    "A":[11,2,3,45,6,np.nan,2],
    "B":[1,2,np.nan,45,6,2,3],
    "C":[1,2,3,45,6,2,np.nan],
    "D":[1,2,3,45,6,2,np.nan],
    "E":[1,2,3,45,6,2,np.nan]
})
df.print()
         A           B           C           D            E
  (float64)   (float64)   (float64)   (float64)   (float64)
-----------  ----------  ----------  ----------  ----------
         11           1           1           1           1
          2           2           2           2           2
          3         nan           3           3           3
         45          45          45          45          45
          6           6           6           6           6
        nan           2           2           2           2
          2           3         nan         nan         nan</pre>
			<p>使用以下命令删除所有带有缺失值的<a id="_idIndexMarker420"/>行<a id="_idIndexMarker421"/>:</p>
			<pre>print(df.rows.drop_na())
         A           B           C           D            E
  (float64)   (float64)   (float64)   (float64)   (float64)
-----------  ----------  ----------  ----------  ----------
         11           1           1           1           1
          2           2           2           2           2
         45          45          45          45          45
          6           6           6           6           6</pre>
			<h3>删除列</h3>
			<p>要了解如何删除包含空值的<a id="_idIndexMarker423"/>列，我们必须首先为它创建一个数据框架:</p>
			<pre>df = op.create.dataframe({
    "A":[11,2,3,45,6],
    "B":[1,2,None,45,6],
    "C":[1,2,3,45,6]
})</pre>
			<p>让我们打印数据帧<a id="_idIndexMarker425"/>以便更好地了解空值在哪里:</p>
			<pre>df.print()
        A            B          C
  (int64)    (float64)    (int64)
---------  -----------  ---------
       11            1          1
        2            2          2
        3          nan          3
       45           45         45
        6            6          6</pre>
			<p>然后，删除<code>B</code>一栏:</p>
			<pre>print(df.cols.drop("B"))
        A          C
  (int64)    (int64)
---------  ---------
       11          1
        2          2
        3          3
       45         45
        6          6</pre>
			<p>请记住，您还可以传递列名列表，如下所示:</p>
			<pre>print(df.cols.drop(["A", "B"]))</pre>
			<p>在前面的例子中，我们删除了列<code>A</code>和<code>B</code>。让我们看看如何处理缺失值。</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>插补</h2>
			<p>插补指<a id="_idIndexMarker426"/>用替代值更新缺失数据。您可能丢失数据的原因可能是由于填写调查时的人为错误，甚至是来自流量传感器的数据流中断。</p>
			<p>与删除相比，插补是更可取的选择，因为您永远不知道您决定删除的数据会如何影响模型的性能。</p>
			<p>Optimus 提供了可以处理数字字符串数据的函数。让我们看看它是如何工作的。</p>
			<h3>数值插补</h3>
			<p>擎天柱<a id="_idIndexMarker427"/>依靠<a id="_idIndexMarker428"/>的<code>impute</code>方法。使用这种方法，您可以轻松处理连续值。您可以应用以下四种技术之一<a id="_idIndexMarker429"/>来处理空值:</p>
			<ul>
				<li>平均</li>
				<li>中位数</li>
				<li>最频繁</li>
				<li>常数</li>
			</ul>
			<p>让我们看一些例子。</p>
			<p>首先，让我们创建一个包含一列数字的数据框架:</p>
			<pre>import numpy as np
df = op.create.dataframe({"A":[1,2,3,45,6,2,np.nan]})
df.print()</pre>
			<p>这将打印一列整数，最后的值表示为<code>nan</code>:</p>
			<pre>         A
  (float64)
-----------
          1
          2
          3
         45
          6
          2
        nan</pre>
			<p>现在<a id="_idIndexMarker430"/>我们<a id="_idIndexMarker431"/>将使用<code>impute</code>计算所有值的<code>median</code>值，并将其应用于<code>nan</code>值:</p>
			<pre>df.cols.impute("A",data_type="continuous", strategy="mean")</pre>
			<p>现在，用平均值<code>9.83333</code>代替<code>nan</code>值:</p>
			<pre>          A
  (float64)
-----------
          1
          2
          3
         45
          6
          2
    9.83333</pre>
			<p>有了平均值，你可以应用中值策略来替换<code>nan</code>，如下:</p>
			<pre>df.cols.impute("A",strategy="median").print()</pre>
			<p>您将获得以下输出:</p>
			<pre>          A
  (float64)
-----------
          1
          2
          3
         45
          6
          2
        2.5</pre>
			<p>此外，您<a id="_idIndexMarker432"/>可以<a id="_idIndexMarker433"/>使用最频繁的值(这也称为<a id="_idIndexMarker434"/>分类插补)，如下所示:</p>
			<pre>print(df.cols.impute("A",strategy="most_frequent"))</pre>
			<p>您将获得以下输出:</p>
			<pre>          A
  (float64)
-----------
          1
          2
          3
         45
          6
          2
          2</pre>
			<p>如果您的数据与之前的任何案例都不匹配，您可以用您输入的任何值替换<code>nan</code>值:</p>
			<pre>print(df.cols.impute("A", strategy="constant", 
                     fill_value=1))</pre>
			<p>此<a id="_idIndexMarker435"/>将打印以下输出:</p>
			<pre>          A
  (float64)
-----------
          1
          2
          3
         45
          6
          2
          1</pre>
			<p>现在我们知道了如何处理数字列，让我们学习如何处理字符串值。</p>
			<h3>字符串插补</h3>
			<p>当涉及到<a id="_idIndexMarker436"/>到<a id="_idIndexMarker437"/>字符串列时，Optimus 只给你使用<code>most_frequent</code>方法。让我们创建一个要使用的数据框架:</p>
			<pre>df = op.create.dataframe({
    "A":[1,2,3,45,6,2,3],
    "B":["Optimus", "Bumblebee", "Eject", "Optimus", 
         "Bumblebee", "Eject", np.nan]
})</pre>
			<p>它的工作方式与处理字符串值相同:</p>
			<pre>print(df.cols.impute("B", strategy="most_<a id="_idTextAnchor130"/>frequent"))
 A    B
 1    Optimus
 2    Bumblebee
 3    Eject
45    Optimus
 6    Bumblebee
 2    Eject
 3    Bumblebee</pre>
			<p>如您所见，有很多选项可以估算缺失值。现在，是时候学习如何处理异常值了。</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor131"/>处理异常值</h1>
			<p>异常值是指远离样本中所有其他数据点且与之不相似的数据点:</p>
			<div><div><img src="img/B17166_07_01.jpg" alt="Figure 7.1 – Outlier (marked in red)&#13;&#10;" width="368" height="264"/>
				</div>
			</div>
			<p class="figure-caption">图 7.1–异常值(用红色标记)</p>
			<p>异常值<a id="_idIndexMarker439"/>可使用图形(箱线图)和非图形方法检测，图形方法更直观。让我们谈谈非图形统计方法:</p>
			<ul>
				<li>Tukey 或百分位数</li>
				<li>z 分数</li>
				<li>修改的 z 分数</li>
			</ul>
			<p>为了展示 Optimus 如何处理异常值，让我们在考虑所有数据的同时创建一个具有正负极值的数据集。它们的值将介于 40 和-50 之间:</p>
			<pre>df = op.create.dataframe(
         {"A":[1,2,3,45,6,-50,np.nan],
          "B":["Optimus","Bumblebee","Eject","Optimus",
               "Bumblebee","Eject",np.nan] })</pre>
			<p>现在，让我们应用这三种方法。</p>
			<h2 id="_idParaDest-127">Tukey</h2>
			<p><strong class="bold"> Tukey </strong>是一种检测离群值的数学<a id="_idIndexMarker440"/>方法<a id="_idIndexMarker441"/>。这里使用四分位数。Optimus 使用这种方法计算下限和上限，如下所示:</p>
			<ul>
				<li>下限:Q1-1.5 *智商</li>
				<li>上限:Q3+1.5 *智商</li>
			</ul>
			<p>这里，Q1 是第一个四分位数，Q3 是第三个四分位数，智商是四分位数之间的范围。</p>
			<p>在 Tukey 中，超出该值范围的每个数据点都被视为异常值。</p>
			<p>使用<code>info</code>方法，你可以对这种方法有一个大致的了解:</p>
			<pre>df.outliers.tukey("A").info()</pre>
			<p>对于 Tukey，您可以通过上限值和下限值获得异常值和非异常值的计数:</p>
			<pre>{
 'count_outliers': 2,
 'count_non_outliers': 4,
 'lower_bound': -4.75,
 'lower_bound_count': 1,
 'upper_bound': 11.25,
 'upper_bound_count': 1,
 'q1': 1.25,
 'median': 2.5,
 'q3': 5.25,
 'iqr': 4.0
}</pre>
			<p><code>lower_bound</code>和<code>upper_bound</code>值代表极限值，在该极限值之后，值<a id="_idIndexMarker442"/>被视为<a id="_idIndexMarker443"/>异常值。在这种情况下，被视为异常值的值是在-4.75 和 11.25 范围之外的值。</p>
			<p>现在，如果您只想获得异常值，您可以使用<code>select</code>方法:</p>
			<pre>print(df.outliers.tukey("A").select())</pre>
			<p>这将返回包含异常值的数据帧:</p>
			<pre>          A  B
  (float64)  (object)
-----------  ----------
         45  Optimus
        -50  Eject</pre>
			<p>如果您想要丢弃异常值，您可以使用<code>drop</code>方法:</p>
			<pre>print(df.outliers.tukey("A").drop())</pre>
			<p>如您所见，值 45 被视为异常值，已从数据集中移除:</p>
			<pre>          A  B
  (float64)  (object)
-----------  ----------
          1  Optimus
          2  Bumblebee
          3  Eject
          6  Bumblebee
        nan  nan</pre>
			<p>您也可以分别使用<code>select_upper_bound()</code>和<code>select_lower_bound()</code>方法选择高于上限和低于下限的值:</p>
			<pre>Print(df.outliers.tukey("A").select_lower_bound())</pre>
			<p>通过这样做，您将获得数据框架底部的异常值:</p>
			<pre>          A  B
  (float64)  (object)
-----------  ----------
        -50  Eject</pre>
			<p>如果<a id="_idIndexMarker444"/>您<a id="_idIndexMarker445"/>想要选择高于上限的数据，您可以使用<code>select_upper_bound()</code>，就像这样:</p>
			<pre>print(df.outliers.tukey("A").select_upper_bound())</pre>
			<p>通过这样做，您将获得数据帧的顶部异常值:</p>
			<pre>          A  B
  (float64)  (object)
-----------  ----------
         45  Optimus</pre>
			<p>Tukey <a id="_idIndexMarker446"/>有<a id="_idIndexMarker447"/>其他有用的方法，你可以用来获得更多关于 Tukey 方法结果的信息。</p>
			<p>要计算非异常值，您可以使用<code>non_outliers_count</code>方法:</p>
			<pre>df.outliers.tukey("A").non_outliers_count()</pre>
			<p>这将打印以下输出:</p>
			<pre>4</pre>
			<p>要计算异常值，请使用以下命令:</p>
			<pre>df.outliers.tukey("A").count()</pre>
			<p>您将获得以下输出:</p>
			<pre>3</pre>
			<p>要获得关于四分点和胡须的信息，请使用以下命令:</p>
			<pre>df.outliers.tukey("A").whiskers()</pre>
			<p>上述示例将打印包含以下值的 Python 字典:</p>
			<pre>{'lower_bound': -4.75, 'upper_bound': 11.25, 'q1': 1.25, 'median': 2.5, 'q3': 5.25, 'iqr': 4.0}</pre>
			<p>就像 Tukey 一样，可以使用 Z-score 来获得不同的界限。</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor133"/> Z 分数</h2>
			<p>Z 分数<a id="_idIndexMarker448"/>在统计学领域是一个非常<a id="_idIndexMarker449"/>有用的概念。它向我们展示了一个数据点是否偏离了一组值的平均值，如果偏离了，偏离了多远。更具体地说，Z 分数告诉我们，与平均值相比，一个数据点有多少标准偏差。</p>
			<p>如果任何数据点的 Z 得分大于 22，则该数据点与其余数据点非常不同，可以被视为异常值。</p>
			<p>在 Optimus 中，通过使用<code>threshold</code>参数，您<a id="_idIndexMarker450"/>可以<a id="_idIndexMarker451"/>指出一个点应该偏离平均值多少个标准偏差，从而将其视为异常值:</p>
			<pre>threshold=2
print(df.outliers.z_score("A", threshold).select())</pre>
			<p>这将返回包含异常值的数据帧:</p>
			<pre>          A
  (float64)
-----------
         31
        -21</pre>
			<p>为了更好地理解这一点，让我们计算一下<code>A</code>列的 Z 分数:</p>
			<pre>print(df.cols.z_score("A"))</pre>
			<p>这将返回以下输出:</p>
			<pre>          A
  (float64)
-----------
  -0.224362
  -0.143592
 -0.0628213
    2.19875
    0.17949
   -2.00131
        nan
  -0.143592
   0.017949</pre>
			<p>如果<a id="_idIndexMarker452"/>你<a id="_idIndexMarker453"/>想去掉离群值，你可以使用<code>drop</code>方法，如下:</p>
			<pre>print(df.outliers.z_score("A", threshold).drop())</pre>
			<p>这将返回以下输出:</p>
			<pre>          A
  (float64)
-----------
          1
          2
          3
          6
        nan
          2
          4
          6</pre>
			<p>与 Tukey 方法一样，我们可以分别获得高于和低于下限和上限的数据。</p>
			<p>如果你想选择高于上限的数据，你可以使用<code>select_lower_bound()</code>，就像这样:</p>
			<pre>print(df.outliers.z_score("A").select_lower_bound())</pre>
			<p>这将返回数据帧底部的异常值:</p>
			<pre>          A
  (float64)
-----------
        -21</pre>
			<p>要选择顶部的选项，您可以使用以下命令:</p>
			<pre>print(df.outliers.z_score("A").select_upper_bound())</pre>
			<p>这个<a id="_idIndexMarker454"/>将<a id="_idIndexMarker455"/>得到如下输出:</p>
			<pre>          A
  (float64)
-----------
         31</pre>
			<p>类似于 Tukey，在 Z_score 中，你有<code>info()</code>、<code>non_outliers_count()</code>、<code>threshold).count()</code>。</p>
			<p>如果希望避免误导边界，可以向 Z 得分的修改版本传递一个阈值。</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor134"/>修改后的 Z 值</h2>
			<p>我们使用 Z 得分<a id="_idIndexMarker456"/>找出<a id="_idIndexMarker457"/>潜在的异常值，但是，这可能不准确，尤其是对于较小的样本量，因为最大 Z 得分最多是<em class="italic">(n1)/sqrt(n)</em>。</p>
			<p>作者<em class="italic"> Iglewicz </em>和<em class="italic"> Hoaglin </em>推荐使用修改后的 Z 分数:</p>
			<p><em class="italic"> Mi=0.6745(xi 中值(x))/MAD </em></p>
			<p>这里，<strong class="bold"> MAD </strong>表示<strong class="bold">中值绝对偏差</strong>。</p>
			<p>在擎天柱中，你可以轻松应用<code>modified_z_score</code>。让我们看看它是如何工作的。</p>
			<p>前述作者还建议使用阈值<code>3.5</code>:</p>
			<pre>print(df.outliers.modified_z_score("A", threshold=3.5).select())
          A
  (float64)
-----------
         31
        -21</pre>
			<p>与<code>z_score</code>方法一样，您<a id="_idIndexMarker458"/>可以使用<code>modified_z_score</code>检查<a id="_idIndexMarker459"/>修改后的 Z 分值:</p>
			<pre>print(df.outliers.modified_z_score("A", threshold).select())
          A
  (float64)
-----------
     0.6745
    0.33725
          0
      9.443
    1.01175
      8.094
        nan
    0.33725
    0.33725</pre>
			<p>您可以使用以下命令删除异常值:</p>
			<pre>print(df.outliers.modified_z_score("A", threshold).drop())</pre>
			<p>您将获得以下输出:</p>
			<pre>        A
  (float64)
-----------
          1
          2
          3
          6
        nan
          2
          4
          6</pre>
			<p>与 Z 分数类似，使用修改后的<a id="_idIndexMarker461"/> Z 分数<a id="_idIndexMarker460"/>，您也可以使用<code>info</code>、<code>count</code>和<code>non_outliers_count</code>方法计数。这三种方法都将我们的数据分组以获得异常值，但是我们也可以使用宁滨以一种定制的方式将这些数据分组。让我们来看看。</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor135"/>宁滨</h1>
			<p>宁滨<a id="_idIndexMarker462"/>的思想是将一些值分组到一个特定的类别中，从而减少数据集中唯一值的数量。</p>
			<p>例如，假设我们正在创建一列数字，如下所示:</p>
			<pre>df = op.create.dataframe(A=[1,2,3,31,6,-21,np.nan,2,4,6])
          A
  (float64)
-----------
          1
          2
          3
         31
          6
        -21
        nan
          2
          4</pre>
			<p>在这里，我们可以将<a id="_idIndexMarker463"/>的值分为低、中、高三类。为此，我们可以使用<code>cut</code>方法:</p>
			<pre>df.cols.cut("A", bins = [0,4,6,35] ,
            labels = ["low", "medium","high"])</pre>
			<p><code>cut</code>方法将把<code>low</code>值赋给 0 到 4 之间的任何值，<code>medium</code>赋给 4 到 6 之间的任何值，<code>high</code>赋给 6 到 35 之间的任何值:</p>
			<pre>A
(category)
------------
low
low
low
high
medium
nan
nan
low
low</pre>
			<p>谈论垃圾箱的工作原理很重要。擎天柱将包括最右边的边，但不包括左边的边。我们使用的面元[0，4，6，35]将表示为(0，4)，(4，6)，(6，35)。这意味着当宁滨时，Optimus 将不会为第一个 bin 取 0 值，但会为第二个 bin 取 4 值，也不会为第二个 bin 取 4 值，但会为第二个 bin 取 6 值:</p>
			<div><div><img src="img/B17166_07_02.jpg" alt="Figure 7.2 – How cut works in Optimus&#13;&#10;" width="600" height="260"/>
				</div>
			</div>
			<p class="figure-caption">图 7.2–cut 在 Optimus 中的工作原理</p>
			<p>您也可以<a id="_idIndexMarker465"/>将<code>cut</code>应用于分类数据，如下所示:</p>
			<pre>df = op.create.dataframe(A=["Maracaibo", "Caracas", "CDMX",
                            "Monterrey", "Bogota"])
print(df.cols.cut("A", ["Maracaibo", "Caracas", "CDMX", 
                        "Monterrey", "Bogota"], 
                  labels=["Venezuela", "Venezuela", 
                          "Mexico", "Mexico", "Colombia"]))</pre>
			<p>这将返回一个数据帧，其中我们将每个状态分组到它们各自的状态:</p>
			<pre>A
(object)
----------
Venezuela
Venezuela
Mexico
Mexico
Colombia</pre>
			<p>宁滨<a id="_idIndexMarker466"/>通常用于建立更健壮的模型，从而以数据丢失和性能为代价防止过度拟合。分类列合并值会有所帮助，从而减少唯一值的总数。</p>
			<p>但是，它主要为包含数字数据的列提供类别，牺牲了分辨率。这对于某些机器学习算法来说可能是多余的。</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor136"/>变量转换</h1>
			<p>一些机器<a id="_idIndexMarker467"/>学习模型，如线性和逻辑回归，假设变量遵循正态分布。更有可能的是，真实数据集中的变量将遵循更偏态的分布。</p>
			<p>通过对这些变量进行一些转换，并将它们的偏态分布映射到正态分布，我们可以提高模型的性能。</p>
			<p>绘制直方图或使用 Q-Q 图可以让您了解数据是正态分布还是偏态分布。</p>
			<p>接下来，我们将看看您可以用来调整数据分布的四种方法。</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor137"/>对数变换</h2>
			<p>这是最简单的<a id="_idIndexMarker468"/>和最流行的<a id="_idIndexMarker469"/>不同类型的转换，并涉及一个显著影响分布形状的实质性转换。</p>
			<p>我们可以使用它(自然对数 ln 或以 10 为底的对数)使极度偏斜的分布<a id="_idIndexMarker470"/>更少<a id="_idIndexMarker471"/>偏斜，特别是对于右偏斜(或正偏斜)的分布。</p>
			<p>在 Optimus 中，您可以使用<code>log</code>方法:</p>
			<pre>print(df.cols.log("A"))</pre>
			<p>这将把日志应用到列:</p>
			<pre>          A
  (float64)
-----------
          0
    0.30103
   0.477121
    1.65321
   0.778151
   0.845098
        nan</pre>
			<p>该方法将来自<code>A</code>的值转换成其对数。另一种可用于转换正偏态分布的方法是平方根。让我们来看看。</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor138"/>平方根变换</h2>
			<p>另一个简单的<a id="_idIndexMarker472"/>变换，这个对分布形状有一个<a id="_idIndexMarker473"/>平均效果:它比对数变换弱，也用于减少正偏分布。</p>
			<p>平方根变换的一个优点是可以应用于零值。</p>
			<p>在 Optimus 中，您可以为此使用<code>sqrt</code>方法:</p>
			<pre>print(df.cols.sqrt("A"))
          A
  (float64)
-----------
          1
    1.41421
    1.73205
     6.7082
    2.44949
    2.64575
        nan</pre>
			<p>正如我们已经知道的，<a id="_idIndexMarker474"/>方法将返回转换后的 dataframe，但是现在在<code>A</code>列上有平方根值。除了平方根变换，您还可以对右偏分布使用倒数变换。</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor139"/>相互转化</h2>
			<p>倒数<a id="_idIndexMarker476"/>变身<a id="_idIndexMarker477"/>是一个强大的变身，具有激进的效果。倒数会反转相同符号值的顺序，因此大值会变小。负倒数保持相同符号的值之间的顺序。</p>
			<p>你应该注意到这个函数不是为 0 定义的。</p>
			<p>在 Optimus 中，你可以像这样使用<code>reciprocal</code>方法:</p>
			<pre>print(df.cols.reciprocal("A"))
          A
  (float64)
-----------
          1
        0.5
   0.333333
  0.0222222
   0.166667
   0.142857
        nan</pre>
			<p>正如您所看到的，这里显示的<a id="_idIndexMarker479"/>值是输入值的倒数。您可以使用其他已知的变换，如指数或幂变换。</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor140"/>指数或幂变换</h2>
			<p>动力转换<a id="_idIndexMarker480"/>对分配形状<a id="_idIndexMarker481"/>有合理的影响；通常，我们应用幂变换(通常是 2 的幂)来减少左偏。</p>
			<p>在 Optimus 中，你可以使用<code>pow</code>或<code>exp</code>方法来完成这个任务。试试看哪一个能给你更好的结果:</p>
			<pre>print(df.cols.pow("A", 2))
          A
  (float64)
-----------
          1
          4
          9
       2025
         36
         49
        nan</pre>
			<p>如您所见，这些值发生了巨大的变化。</p>
			<p>但是如果我们不使用数字列呢？对此，我们有一个方法叫做<code>string_to_index</code>。让我们来看看。</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor141"/>要索引的字符串</h2>
			<p>索引字符串<a id="_idIndexMarker482"/>将一个数值分配给<a id="_idIndexMarker483"/>列中的每个相同值。让我们来看看它是如何工作的。</p>
			<p>首先，让我们创建一个包含几个重复值的数据帧:</p>
			<pre>df = op.create.dataframe({
    "A":["Optimus","Bumblebee","Eject","Optimus","Eject"]
})</pre>
			<p>这将为您提供如下所示的数据帧:</p>
			<pre>A
(object)
----------
Optimus
Bumblebee
Eject
Optimus
Eject</pre>
			<p>现在，让我们应用<code>string_to_index</code>方法:</p>
			<pre>print(df.cols.string_to_index())</pre>
			<p>这将创建一个列，并将值<code>0</code>分配给<code>Bumblebee</code>、<code>1</code>分配给<code>Eject</code>、以及<code>2</code>分配给<code>Optimus</code>:</p>
			<pre>A             A_string_to_index
(object)                (int32)
----------  -------------------
Optimus                       2
Bumblebee                     0
Eject                         1
Optimus                       2
Eject                         1</pre>
			<p>在这个例子中，我们<a id="_idIndexMarker484"/>给<code>A</code>上的每个值分配了一个索引。我们可以这样做，以允许机器学习算法将此列用作数字列。现在，让我们看看另一种方法，也允许这样做，但以更好的方式，称为一热编码。</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor142"/>一键编码</h1>
			<p>One-hot encoding <a id="_idIndexMarker486"/>是一个将分类数据转换为更容易用于机器学习算法的替代形式的过程，这反过来会导致更好的预测。</p>
			<p>为了说明其工作原理，假设我们有以下数据框架:</p>
			<pre>df = op.create.dataframe({"A":["Optimus","Bumblebee","Eject", "Megatron"], "B":["Transformer","Transformer","Transformer","Decepticon"]})
A           B
(object)    (object)
----------  -----------
Optimus     Transformer
Bumblebee   Transformer
Eject       Transformer
Megatron     Decepticon</pre>
			<p>大多数机器学习算法只能处理数字，因此，通过 one-hot 编码，我们将创建一个包含类别名称的列，如果观察值属于特定类别，则将 0 或 1 分配给该行:</p>
			<pre>print(df.encoding.one_hot_encoder("B"))</pre>
			<p>这将导致以下输出:</p>
			<pre>A           B              B_Decepticon    B_Transformer
(object)    (object)            (uint8)          (uint8)
----------  -----------  --------------  ---------------
Optimus     Transformer               0                1
Bumblebee   Transformer               0                1
Eject       Transformer               0                1
Megatron     Decepticon               1                0</pre>
			<p>这里<code>Megatron</code>属于<a id="_idIndexMarker487"/>的<code>Decepticon</code>类，所以编号<code>1</code>被分配给<code>B_Decepticon</code>列，而<code>0</code>被分配给<code>B_Transformer</code>。</p>
			<p>但是，如果我们的值比类别更复杂，我们需要应用其他方法将这些值拆分到多个列中。</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor143"/>特征分割</h1>
			<p>特征分割<a id="_idIndexMarker488"/>是一种技术，包括从一列中分割数值以创建新的数值。一个很好的例子是将保存在一列中的名字和姓氏拆分为两个单独的列，或者将日期拆分为三列，分别表示月中的日期、月份和年份。分割特征的主要目的是为机器学习算法提供更好解释的小数据包数据，并最终提高机器学习模型的性能。</p>
			<p>对于特色分割，我们可以使用<code>unnest</code>方法，我们在第 3 章 的<a href="B17166_03_Final_VK_epub.xhtml#_idTextAnchor064"> <em class="italic">中看到过。然而，在那里，我们专注于如何产生特征来支持我们的机器学习算法。</em></a></p>
			<p>首先，让我们从包含一些字符串值的数据帧开始:</p>
			<pre>df = op.create.dataframe({"A":["Argenis Leon","Luis Aguirre","Favio Vasquez",np.nan]})
print(df.cols.unnest("A"," ", drop=True))</pre>
			<p><code>drop</code>参数<a id="_idIndexMarker489"/>将删除您正在分割的列，返回姓名和姓氏以及数据帧中的任何其他列:</p>
			<pre>A_0         A_1
(object)    (object)
----------  ----------
Argenis     Leon
Luis        Aguirre
Favio       Vasquez
nan</pre>
			<p>另一种常见的情况是将日期拆分为日、月和年。首先，让我们创建一个包含一些日期的数据框架:</p>
			<pre>df = op.create.dataframe({"A":["10/04/1980","20/05/1995","01/08/1990",np.nan]})</pre>
			<p>现在，让我们将它们分成三列，同时保留原始列:</p>
			<pre>df.cols.unnest("A", "/", splits=3, 
               output_cols=["day","month","year"])
A                  day       month        year
(object)      (object)    (object)    (object)
----------  ----------  ----------  ----------
10/04/1980          10          04        1980
20/05/1995          20          05        1995
01/08/1990           1          08        1990</pre>
			<p>我们已经知道，<code>unnest</code>用给定的分隔符将我们的值分开，这对于机器学习的数据准备非常有用。另一种准备数据的方法是缩放数值。让我们来看看。</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>缩放</h1>
			<p>缩放<a id="_idIndexMarker490"/>包括将数据集中的数字特征纳入相同的值范围。例如，在一个数据集中，您可能期望年龄范围在 30 到 75 岁之间，工资在 30，000 美元到 120，000 美元之间。因为两个特征的比例非常不同，这可能会损害模型的性能。</p>
			<p>虽然缩放对于许多算法来说不是强制性的，但一些基于距离计算的算法，如 k-NN 或 k-means，需要具有缩放的连续特征才能运行良好。</p>
			<p>为了帮助你完成这项任务，Optimus 给了你三种缩放方法:</p>
			<ul>
				<li>正常化</li>
				<li>标准化</li>
				<li>最大 abs 定标器</li>
			</ul>
			<p>为了向您展示它们是如何工作的，让我们从创建一个简单的数据帧开始:</p>
			<pre>df = op.create.dataframe({"A":[1.12,3.2,4.35,6.3,7.3,np.nan]})</pre>
			<p>现在，让我们学习如何应用规范化。</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>正常化</h2>
			<p>标准化<a id="_idIndexMarker491"/>(也称为<a id="_idIndexMarker492"/>最小-最大标准化)在 0 和 1 之间的固定范围内缩放<a id="_idIndexMarker493"/>所有值。在 Optimus 中，您可以通过使用<code>cols</code>访问器来使用<code>min_max_scaler</code>方法，就像这样:</p>
			<pre>print(df.cols.min_max_scaler("A"))</pre>
			<p>这里，输出将被缩放:</p>
			<pre>          A
  (float64)
-----------
          0
    0.33657
   0.522654
   0.838188
          1
        nan</pre>
			<p>请记住<a id="_idIndexMarker494"/>和<a id="_idIndexMarker495"/>您总是可以使用<code>output</code>参数将结果输出到另一列，就像这样:</p>
			<pre>print(df.cols.min_max_scaler("A", output_cols="A_normalized"))</pre>
			<p>这对于维护数据集中的两列非常有用，因为该方法应用了一个不可还原的函数。让我们来看一个叫做<code>standard_scaler</code>的类似方法。</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>标准化</h2>
			<p>标准化<a id="_idIndexMarker496"/>(或 Z 分数标准化)重新调整<a id="_idIndexMarker497"/>值<a id="_idIndexMarker498"/>以确保平均值为 0，标准差为 1。在 Optimus 中，您可以使用<code>standard_scaler</code>方法:</p>
			<pre>print(df.cols.standard_scaler("*"))</pre>
			<p>这将导致以下缩放的列:</p>
			<pre>          A
  (float64)
-----------
   -1.51526
  -0.569926
 -0.0472666
   0.838981
    1.29347
        nan</pre>
			<p>正如我们<a id="_idIndexMarker499"/>可以<a id="_idIndexMarker500"/>看到的，我们将得到大于 1 小于 0 的值，不像归一化。另一种缩放方法是 max abs scaler。让我们来看看。</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>最大 abs 定标器</h2>
			<p>此方法用于使用最大绝对值来缩放要素。</p>
			<p>这个估计器<a id="_idIndexMarker501"/>修改<a id="_idIndexMarker502"/>每个特征，使得对于训练集，每个特征的最大绝对值正好是 1.0。它不会移动或更改数据，因此不会消除任何一致性。</p>
			<p>在 Optimus 中，你可以像这样使用<code>max_abs_scaler</code>方法:</p>
			<pre>print(df.cols.max_abs_scaler("*"))</pre>
			<p>作为回报，您将得到一个包含换算值的列:</p>
			<pre>          A
  (float64)
-----------
   0.153425
   0.438356
    0.59589
   0.863014
          1
        nan</pre>
			<p>我们可以看到，这个结果的<a id="_idIndexMarker503"/>最大值<a id="_idIndexMarker504"/>为 1。</p>
			<p>对于不同的情况，我们有很多选项来调整列的值。</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>总结</h1>
			<p>在这一章中，我们讨论了很多为机器学习算法准备数据的技术。</p>
			<p>其中一种技术是插补，它对于包含空值的数据很有用。对于包含意外值的数据，我们可以应用异常值处理。</p>
			<p>通过使用宁滨，我们可以对数字数据进行分类。如果我们的数字数据没有正确分布，我们可以通过应用变量转换来消除偏斜，使用我们在前面章节中看到的方法。</p>
			<p>另一方面，一键编码允许我们将一列中的值分成多个布尔列。我们可以使用特征分割将包含大量数据的一个值分割成多个值。最后，我们学习了如何使用多种方法来扩展我们的数据。</p>
			<p>现在你已经了解了所有这些技术，你可以向机器学习迈出第一步了。</p>
			<p>在下一章中，我们将学习如何使用我们已经准备好的数据，通过 Optimus 中可用的方法来创建模型。</p>
		</div>
	</div>
</body></html>