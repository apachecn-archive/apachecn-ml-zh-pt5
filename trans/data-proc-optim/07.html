<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>
<div><div><h1 id="_idParaDest-98"><em class="italic"> <a id="_idTextAnchor099"/>第五章<a id="_idTextAnchor100"/></em>:数据可视化与剖析</h1>
			<p>当您转换数据时，您通常需要探索您的数据，以便很好地了解如何塑造数据，从而从中获得洞察力。您可能需要检查缺失值，确保列内的一致性，获得唯一值的计数，绘制直方图，获得前<em class="italic"> n </em>个值，或者生成描述性分析。擎天柱给了我们工具让这一切发生。</p>
			<p>在本章中，我们将深入剖析我们在<a href="B17166_03_Final_VK_epub.xhtml#_idTextAnchor064"> <em class="italic">第 3 章</em> </a> <em class="italic">、数据争论、</em>中看到的分析器及其数据类型，并了解我们如何充分利用这一特性对特定数据执行操作，以根据需要设置、删除或替换值。</p>
			<p>Optimus 还可以提供有关数据质量的信息，并提供工具来轻松处理和转换我们的数据。</p>
			<p>我们将在本章中讨论的主题如下:</p>
			<ul>
				<li>数据质量</li>
				<li>探索性数据分析</li>
				<li>数据剖析</li>
				<li>缓存和刷新</li>
			</ul>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>技术要求</h1>
			<p>Optimus 可以与多种后端技术一起处理数据，包括 GPU。有了 GPU，擎天柱用的是<strong class="bold">激流</strong>，需要 NVIDIA 卡。关于需求的更多信息，请前往第一章<a href="B17166_01_Final_SB_epub.xhtml#_idTextAnchor015"><em class="italic"/></a><em class="italic">中的<em class="italic"> GPU 配置</em>部分，嗨擎天柱！</em>。</p>
			<p>你可以在<a href="https://github.com/PacktPublishing/Data-Processing-with-Optimus">https://github . com/packt publishing/Data-Processing-with-Optimus</a>找到本章的所有代码。</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor102"/>数据质量</h1>
			<p>在 Optimus 中，我们称之为对与特定<a id="_idIndexMarker280"/> profiler 数据类型<code>URL</code>匹配的列中的值的数量进行计数的过程，Optimus 将对执行以下操作的列中的值的数量进行计数:</p>
			<ul>
				<li>匹配 URL 格式，比如<code>"google.com"</code>。</li>
				<li>不匹配的网址格式，如<code>"google"</code>。</li>
				<li>它还会计算空值。</li>
			</ul>
			<p>Optimus 在 profiler 中有许多数据类型，这些数据类型是结合正则表达式和数字类型检测推断出来的。作为参考，在下表中，我们列出了探查器数据类型和 Python 数据类型:</p>
			<div><div><img src="img/B17166_Table_01.jpg" alt="Figure 5.1 – Optimus profiler datatypes&#13;&#10;" width="1491" height="980"/>
				</div>
			</div>
			<p class="figure-caption">图 5.1–Optimus profiler 数据类型</p>
			<p>这些数据类型是在运行探查器时推断出来的。此外，如果您<a id="_idIndexMarker281"/>确定分析器数据类型应该具有特定的数据类型，您可以更改分析器:</p>
			<pre>from optimus import Optimus 
op = Optimus("pandas")
df = op.load.file("foo.csv")
df.cols.quality()</pre>
			<p><code>df.cols.quality</code>将返回以下内容:</p>
			<pre>{'name': {'match': 4,
  'missing': 0,
  'mismatch': 0,
  'profiler_dtype': {'dtype': 'str', 'categorical': True}},
'job': {'match': 2,
  'missing': 0,
  'mismatch': 2,
  'profiler_dtype': {'dtype': 'int', 'categorical': True}},
'id': {'match': 4,
  'missing': 0,
  'mismatch': 0,
  'profiler_dtype': {'dtype': 'int', 'categorical': True}}}</pre>
			<p><code>quality</code>方法返回一个字典，以列名作为键，包含匹配、不匹配、缺失值、源文件名(如果适用)和<code>profiler_dtype</code>，T5 是 Optimus 推断的抽象类型。</p>
			<p>第一次运行探查器时，使用数据集的示例来推断列的数据类型。让我们来看一个例子，我们想要改变一个列的推断数据类型:</p>
			<pre>df = df.cols.set_dtype("salary", "int")</pre>
			<p>在前面的代码中，我们更改了<code>salary</code>列的推断数据类型。如果我们获得了概要分析器或者获得了该列的数据质量统计数据，我们将会得到不同的结果。如果我们想改变多列的数据类型，我们可以调用<code>df.cols.dtype</code>，传递一个字典如下:</p>
			<pre>df = df.cols.set_dtype({"salary": "int", "age": "str"}) </pre>
			<p>在本例中，我们将一个列设置为字符串。这可以减少数据质量的不匹配。</p>
			<p>有一些特殊的数据类型在内部被视为一个字符串，但是受到一种格式的约束，比如电子邮件、URL 和一些日期时间值。</p>
			<p>在其他情况下，datetime 列的值在内部可以是本机 datetime 类型(如果所选引擎支持)。</p>
			<p>还可以扩展 Optimus 支持的数据类型。我们将在接下来的章节中看到更多关于这个主题的内容。</p>
			<p>通过设置不同的数据类型，我们能够更精确地检查数据的质量。让我们更多地了解它。</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>处理匹配、不匹配和空值</h2>
			<p>在 Optimus 中，为了识别满足给定条件的每一行的值，我们使用了掩码，这些掩码是告诉我们每个值是否满足条件的布尔值行。例如，当获得具有一些空值的列的空掩码时，该掩码将在除了具有空值的行之外的所有行中具有值<strong class="bold"> False </strong>，这些行将具有<strong class="bold"> True </strong>:</p>
			<pre>df = op.create.dataframe({"numbers": [1, 2, None, 4]})
df.mask.missing("numbers").print()</pre>
			<p>我们将获得以下结果:</p>
			<pre>  numbers
   (bool)
---------
        0
        0
        1
        0</pre>
			<p>该掩码<a id="_idIndexMarker286"/>用于执行不同的行操作，如<a id="_idIndexMarker287"/>行过滤或值替换。稍后我们会看到更多相关内容；首先，我们将看到如何使用掩码处理匹配和不匹配。</p>
			<p>假设我们有以下数据集:</p>
			<pre>df = op.create.dataframe({"numbers": [1, 2, "Hello", 4, "World"]})
numbers
(object)
----------
1
2
Hello
4
World</pre>
			<p>如果我们想知道哪些值匹配主要的数据类型(在本例中是 int ),我们使用<code>mask.match</code>,传递<code>"int"</code>作为第二个参数:</p>
			<pre>df.mask.match("numbers", "int").print()</pre>
			<p>我们将获得以下输出:</p>
			<pre>  numbers
   (bool)
---------
        1
        1
        0
        1
        0</pre>
			<p>要使用这个掩码过滤<a id="_idIndexMarker289"/>，我们可以使用<code>select</code>或<code>drop</code>，将掩码作为第一个参数传递给<a id="_idIndexMarker290"/>:</p>
			<pre>df.rows.select(df.mask.match("numbers", "int")).print()</pre>
			<p>我们将<a id="_idIndexMarker291"/>得到以下输出:</p>
			<pre>   numbers
  (object)
----------
         1
         2
         4</pre>
			<p>现在我们将删除这一行:</p>
			<pre>df.rows.drop(df.mask.match("numbers", "int")).print()</pre>
			<p>我们将获得以下输出:</p>
			<pre>numbers
(object)
----------
Hello
World</pre>
			<p>要使用<code>mask</code>替换这些值，我们可以执行以下操作:</p>
			<pre>df.cols.set("numbers", value=0, where=df.mask.mismatch("numbers", "int")).print()</pre>
			<p>在前面的<a id="_idIndexMarker292"/>示例中，我们使用<code>mismatch</code>而不是<a id="_idIndexMarker293"/>进行匹配。这使我们能够替换列中所有不是数字的值。这样做的结果如下:</p>
			<pre>   numbers 
  (object) 
---------- 
         1 
         2 
         0 
         4 
         0</pre>
			<p>通过不向<code>mask</code>上的<code>mismatch</code>方法传递类型，Optimus 将使用之前推断的可用数据类型，如果它可用的话:</p>
			<pre>df.cols.dtypes("numbers")
df.mask.mismatch("numbers")</pre>
			<p>前面的代码将与下面的代码行为相同:</p>
			<pre>df.cols.dtypes("numbers")
df.mask.mismatch("numbers", df["numbers"].profile.dtypes() )</pre>
			<p>这意味着我们可以简单地调用下面的代码，并且仍然得到相同的结果:</p>
			<pre>df.cols.set("numbers", value=0, where=df.mask.mismatch("numbers"))</pre>
			<p>我们还将获得以下输出:</p>
			<pre>   numbers 
  (object) 
---------- 
         1 
         2 
         0 
         4 
         0</pre>
			<p>如果我们不知道应该在<a id="_idIndexMarker296"/> a 列中使用什么类型，并且我们已经将该信息缓存在我们的数据集中，那么这<a id="_idIndexMarker295"/>是很有帮助的。</p>
			<p>我们<a id="_idIndexMarker297"/>学会了如何根据数据的质量来处理数据，以及如何清理我们的数据。一旦清理完毕，我们就可以使用这些数据来获得一些统计数据。让我们学习如何！</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>探索性数据分析</h1>
			<p><strong class="bold">探索性数据分析</strong> ( <strong class="bold"> EDA </strong>)当你开始探索你的数据时，这是至关重要的一步。它可以<a id="_idIndexMarker298"/>给你它的主要特征的总体概述，比如最小值和最大值，以及平均值和中值。此外，它可以帮助您检测模式、数据不一致和异常值。</p>
			<p>探索数据的第一步是应用 EDA 技术，以便更好地理解要处理的数据。应用该技术的主要目标如下:</p>
			<ul>
				<li>最大限度地深入了解数据集</li>
				<li>来揭开潜在的结构</li>
				<li>提取重要的变量</li>
				<li>检测异常值和异常值</li>
			</ul>
			<p>我们可以通过四种方式对 EDA 进行分类:</p>
			<ul>
				<li><strong class="bold">单变量，非图形</strong>:这里，数据分析只应用于一个变量。单变量分析的主要目的是描述数据并找出其中存在的模式。</li>
				<li><strong class="bold">单个变量，图形化</strong>:单个变量的图形化方法可以是一种非常<a id="_idIndexMarker300"/>直观的方式来浏览您的列。Optimus 中可用的一些图有直方图、频率表和箱线图。</li>
				<li><strong class="bold">多变量，非图形</strong>:当你想分析<a id="_idIndexMarker301"/>多个变量之间的关系时，你可以依靠交叉制表或统计等方法。</li>
				<li><strong class="bold">多变量，图形化</strong>:这些方法让你以图形化的方式探索<a id="_idIndexMarker302"/>多个变量之间的关系。擎天柱可以在散点图和热图方面提供帮助。</li>
			</ul>
			<p>正如你所看到的，在 Optimus 中你可以很容易地计算出几乎所有你需要深入了解的数据。</p>
			<p>在深入一些示例之前，让我们加载一个类似商店库存的数据帧:</p>
			<pre>from optimus import Optimus 
op = Optimus("pandas")
df = op.load.file("store.csv")
df.print(10, ["name", "code"])</pre>
			<p>在前面的代码中，我们调用了<code>print</code>,但是在本例中，我们请求的是这个数据集的前十行和两列。这将打印以下内容:</p>
			<pre>       id  name        code              price
  (int64)  (object)    (object)      (float64)
---------  ----------  ----------  -----------
        1  pants       L15              173.47
        2  shoes       SH                69.99
        3  shirt       RG30              30
        4  pants       J10               34.99
        5  pants       JG15             132.99
        6  shoes       B                 57.99
        7  pants       JG20             179.99
        8  pants       L20               95
        9  shirt       FT50              50
       10  pants       JG15             169.99</pre>
			<p>但是让我们<a id="_idIndexMarker304"/>通过应用一些可用的方法来深入了解整个列。</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>单变量非图形方法</h2>
			<p>在 Optimus 中，您可以使用某些方法来获得对数据的非图形洞察。让我们<a id="_idIndexMarker305"/>看看其中的一些。</p>
			<p>要计算<a id="_idIndexMarker306"/>列中的最小值，使用以下公式:</p>
			<pre>df.cols.min("id")</pre>
			<p>这将返回以下输出:</p>
			<pre>1</pre>
			<p>如果您还想计算列中的最大值，您可以使用<code>max</code>，如下所示:</p>
			<pre>df.cols.max("id")</pre>
			<p>这将返回以下内容:</p>
			<pre>504</pre>
			<p>另一方面，如果您想要计算众数(这是列中最常见的值)，您可以使用以下方法:</p>
			<pre>df.cols.mode("price")</pre>
			<p>这将根据数据返回一个字典或单个值:</p>
			<pre>50.0</pre>
			<p>要计算列中的中值，请使用以下公式:</p>
			<pre>df.cols.median("price")</pre>
			<p>这将返回一个数值:</p>
			<pre>104.99</pre>
			<p>要计算四分位数范围，即 Q1 和 Q3 之间的范围，请使用以下公式:</p>
			<pre>df.cols.iqr("id")</pre>
			<p>我们将<a id="_idIndexMarker308"/>得到以下值:</p>
			<pre>130.01</pre>
			<p>要计算列中的平均值，请使用以下公式:</p>
			<pre>df.cols.mean("id")</pre>
			<p>这将返回以下值:</p>
			<pre>121.30525793650794</pre>
			<p>此外，为了计算列中的标准偏差，我们可以使用<code>std</code>:</p>
			<pre>df.cols.std("price")</pre>
			<p>我们会得到一个数值:</p>
			<pre>93.16652086384731</pre>
			<p>要计算列中的方差，请使用以下公式:</p>
			<pre>df.cols.var("price")</pre>
			<p>我们将获得以下值:</p>
			<pre>8680.000609873696</pre>
			<p>你也可以计算偏斜度。这将告诉您概率分布是向左还是向右倾斜:</p>
			<pre>df.data["price"].skew()</pre>
			<p>我们会得到一个数值:</p>
			<pre>1.0015117495305208</pre>
			<p>对于峰度，它是概率分布“尾部”的一种度量，使用以下公式:</p>
			<pre>df.cols.kurtosis("price")</pre>
			<p>此<a id="_idIndexMarker309"/>将返回以下值:</p>
			<pre>0.45556375186033016</pre>
			<p>我们也可以通过它们可能的属性来计算一些值。让我们看看其中的一些。</p>
			<p>要计算一列中的所有零，可以使用以下方法:</p>
			<pre>df.cols.count_zeros("discount")</pre>
			<p>我们将得到<code>"discount"</code>中零的数量:</p>
			<pre>294</pre>
			<p>要计算一列中所有的空值，可以使用以下方法:</p>
			<pre>df.cols.count_nulls("discount")</pre>
			<p>我们将得到以下整数:</p>
			<pre>0</pre>
			<p>要计算一列中的所有空白值，可以使用以下方法:</p>
			<pre>df.cols.count_na("discount")</pre>
			<p>我们将得到一个整数值:</p>
			<pre>0</pre>
			<p>要计算一列中所有唯一值的个数，可以使用以下方法:</p>
			<pre>df.cols.count_uniques("price")</pre>
			<p>这个<a id="_idIndexMarker311"/>将返回一个包含<code>"price"</code>中所有唯一值的整数:</p>
			<pre>192</pre>
			<p>正如我们<a id="_idIndexMarker312"/>所看到的，通过使用这些方法中的任何一种，您都可以很容易地从一个专栏中获得特定的见解。现在让我们看看如何以图形方式浏览数据。</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>单变量图形方法</h2>
			<p>图形化<a id="_idIndexMarker313"/>数据检查<a id="_idIndexMarker314"/>可以非常直观地洞察您的数据。</p>
			<p>Optimus 使用了<code>matplotlib</code>和<code>seaborn</code>，两个非常有用的绘图库。此外，请记住，您可以以 Python 字典格式输出数据，并使用最适合您需求的库。</p>
			<p>现在，让我们从之前加载的数据集中绘制一些数据。</p>
			<h3>柱状图</h3>
			<p>直方图<a id="_idIndexMarker315"/>告诉我们<a id="_idIndexMarker316"/>中每个数字数据片的数量有多少个值，例如，有多少人属于特定的年龄组。</p>
			<p>要获得数值列的直方图，可以使用以下方法:</p>
			<pre>df.cols.hist("id",5)</pre>
			<p>这将打印一个 Python 字典，显示下限和上限以及它们之间的值计数:</p>
			<pre>{'hist': {'price': [
{'lower': 5.0, 'upper': 103.3675, 'count': 250},   
{'lower': 103.3675, 'upper': 201.735, 'count': 179},   
{'lower': 201.735, 'upper': 300.1025, 'count': 39},
{'lower': 300.1025, 'upper': 398.47, 'count': 36}
]}}</pre>
			<p>要绘制直方图，您可以使用以下方法:</p>
			<pre>df.plot.hist()</pre>
			<p>这将显示以下输出:</p>
			<div><div><img src="img/B17166_05_1.jpg" alt="Figure 5.2 – Histogram chart generated using Optimus&#13;&#10;" width="846" height="263"/>
				</div>
			</div>
			<p class="figure-caption">图 5.2–使用 Optimus 生成的直方图</p>
			<p>这个图表<a id="_idIndexMarker317"/>让我们深入了解一个数字列在<a id="_idIndexMarker318"/>数字范围中的分布。如果列不是数字而是分类的，您可以创建一个频率表。</p>
			<h3>频率</h3>
			<p>使用<code>frequency</code>方法，您可以计算一个值在一个或多个<a id="_idIndexMarker319"/>列中出现的次数。默认情况下，这以降序显示。</p>
			<p>在 Optimus <a id="_idIndexMarker320"/>中，要获得任一(或每一)列的前五个频繁值，可以使用以下代码:</p>
			<pre>df.cols.frequency("code", 5)</pre>
			<p>这将打印一个 Python 字典，其中的值和计数按降序排列:</p>
			<pre>{'frequency': {'code': {'values': [
{'value': 'JG15', 'count': 60},
{'value': 'JG10', 'count': 43},
{'value': 'SK', 'count': 37},
{'value': 'L15', 'count': 33},
{'value': 'J15', 'count': 32}
]}}}</pre>
			<p>您可以使用以下内容绘制频率图表:</p>
			<pre>df.plot.frequency("code", 40)</pre>
			<p>这将显示 40 个像这样的条形:</p>
			<div><div><img src="img/B17166_05_2.jpg" alt="Figure 5.3 – Frequency chart generated using Optimus&#13;&#10;" width="846" height="279"/>
				</div>
			</div>
			<p class="figure-caption">图 5.3-使用 Optimus 生成的频率表</p>
			<p>使用这个，您可以<a id="_idIndexMarker321"/>找出一列中最频繁出现的值，正如第二个参数中输入的数字一样详细。</p>
			<p>现在，让我们了解一种更高级的数值数据可视化。</p>
			<h3>箱形图</h3>
			<p>箱线图是一种基于五个数字汇总(最小值、第一个四分位数(Q1)、中值、第三个四分位数(Q3)和最大值)显示数据分布的标准化方式。</p>
			<p>箱形图对于分析数字列很有用。让我们来看看如何获得生成它们所需的数据:</p>
			<pre>df.cols.boxplot("price")</pre>
			<p>这将打印一个 Python 字典，其中包含打印箱线图所需的所有数据，如均值、中值、第一个和第三个四分位数、胡须和异常点(也称为飞行者):</p>
			<pre>{'price': {
    'mean': 121.30525793650794,
    'median': 104.99,
    'q1': 44.99,
    'q3': 175.0,
    'whisker_low': -150.02499999999998,
    'whisker_high': 370.015,
    'fliers': [
        {'price': 374.99},
        {'price': 395.0},
        {'price': 390.0},
        {'price': 395.0},
        {'price': 398.47},
        {'price': 380.0},
        {'price': 375.0}
    ],
    'label': 'price'
}}</pre>
			<p>要用 Optimus 得到<a id="_idIndexMarker325"/>一个方框图<a id="_idIndexMarker326"/>，你可以使用下面的:</p>
			<pre>df.plot.box("age")</pre>
			<p>这将显示以下图形:</p>
			<div><div><img src="img/B17166_05_3.jpg" alt="Figure 5.5 – Box plot generated using Optimus&#13;&#10;" width="383" height="264"/>
				</div>
			</div>
			<p class="figure-caption">图 5.5-使用 Optimus 生成的箱线图</p>
			<p>这种图可以告诉你你的异常值和它们的值。它还能告诉你你的数据是否对称，你的数据分组有多紧密，你的数据是否以及如何偏斜。</p>
			<p>既然我们已经了解了可以帮助我们单独研究各个列的图表，那么让我们深入研究其他类型的图表，这些图表可以帮助我们更全面地了解多个变量。</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>多变量非图形方法</h2>
			<p>为了<a id="_idIndexMarker329"/>了解<a id="_idIndexMarker330"/>整个数据集以及它的变量是如何相互关联的，你可以使用这些类型的方法。我们来讨论一下。</p>
			<h3>交叉制表</h3>
			<p>交叉列表(也称为<a id="_idIndexMarker331"/>交叉表或列联表)是一个二维表格<a id="_idIndexMarker332"/>，记录了具有表格值中描述的特定特征的受访者的频率。它提供了关于两个变量之间关系的有价值的信息。</p>
			<p>要在 Optimus 中获得一个交叉表，可以使用下面的代码:</p>
			<pre>df = op.create.dataframe(A=[18,21,62,44], B=[45,42,25,21])
df.cols.crosstab("A", "B")</pre>
			<p>这将输出以下内容:</p>
			<pre>{21: {18: 0, 21: 0, 44: 1, 62: 0},
 25: {18: 0, 21: 0, 44: 0, 62: 1},
 42: {18: 0, 21: 1, 44: 0, 62: 0},
 45: {18: 1, 21: 0, 44: 0, 62: 0}}</pre>
			<p>您也可以将它输出到数据帧中:</p>
			<pre>df.cols.crosstab("A", "B", output="dataframe")</pre>
			<p>此<a id="_idIndexMarker334"/>将打印以下内容:</p>
			<pre>         A         21         25         42         45
  (object)    (int64)    (int64)    (int64)    (int64)
----------  ---------  ---------  ---------  ---------
        18          0          0          0          1
        21          0          0          1          0
        44          1          0          0          0
        62          0          1          0          0</pre>
			<p>如您所见，列<code>A</code>是作为索引维护的。让我们用另一种方法来看两列之间的关系。</p>
			<h3>相互关系</h3>
			<p>两个变量的相关性<a id="_idIndexMarker335"/>可以传达<a id="_idIndexMarker336"/>两列的相关程度。该值用介于-1 和 1 之间的数值表示。值为-1 表示每列的值反向相关，值为 1 表示每列依赖于另一列，或者它们甚至可能以不同的方式表示同一变量。</p>
			<p>要获得两列的相关性，可以使用以下方法:</p>
			<pre>df = op.create.dataframe(A=[1,2,3,4], B=[4,5,0,7], C=[-1,-2,-5,-6])
df.cols.correlation(["A", "B"])</pre>
			<p>这将返回一个数值:</p>
			<pre>0.17541160386140586</pre>
			<p>如果不是<a id="_idIndexMarker337"/>而是使用<code>"*"</code>传递超过两列<a id="_idIndexMarker338"/>甚至整个数据集，您将得到一个表示相关矩阵的字典:</p>
			<pre>df.cols.correlation("*")</pre>
			<p>这将显示以下内容:</p>
			<pre>{'A': {'A': 1.0, 'B': 0.17541160386140586, 'C': -0.9761870601839528},
 'B': {'A': 0.17541160386140586, 'B': 1.0, 'C': 0.0},
 'C': {'A': -0.9761870601839528, 'B': 0.0, 'C': 1.0}}</pre>
			<p>让我们看看如何获得整个数据集的图形化视图。</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>多变量图形方法</h2>
			<p>了解多列(甚至整组列)的一个好方法是使用多变量图形方法。让我们看看其中的一些。</p>
			<h3>热图</h3>
			<p>热图<a id="_idIndexMarker341"/>图是笛卡尔<a id="_idIndexMarker342"/>空间中的一种图，显示关于两个变量的信息。它用颜色变化来测量二维现象的大小。</p>
			<p>要获取 Python 字典格式的热点图，您可以使用以下内容:</p>
			<pre>df.cols.heatmap("fare")</pre>
			<p>这将返回以下输出:</p>
			<pre>{'frequency': {'name': {'values': [{'value': 'optimus', 'count': 2},
    {'value': 'bumblebee', 'count': 2}]},
  'job': {'values': [{'value': '1', 'count': 1},
    {'value': 'Leader', 'count': 1},
    {'value': 'Espionage', 'count': 1},
    {'value': '3', 'count': 1}]},
  'id': {'values': [{'value': '1', 'count': 1},
    {'value': '2', 'count': 1},
    {'value': '4', 'count': 1},
    {'value': '3', 'count': 1}]
}}}</pre>
			<p>要从特定列绘制<a id="_idIndexMarker343"/>热图，请使用:</p>
			<pre>df.plot.heatmap("price", "id", 30, 30)</pre>
			<p>这个<a id="_idIndexMarker344"/>会显示如下的剧情:</p>
			<div><div><img src="img/B17166_05_4.jpg" alt="Figure 5.4 – Heat map generated using Optimus&#13;&#10;" width="223" height="263"/>
				</div>
			</div>
			<p class="figure-caption">图 5.4–使用 Optimus 生成的热图</p>
			<p>如您所见，重叠的多个值将显示为深黄色，以表示聚类中有多少个点。</p>
			<h3>相关矩阵</h3>
			<p>相关矩阵将向我们显示所有给定列之间的相关系数。在绘制之前，让我们加载另一个包含更多数字列的数据集:</p>
			<pre>df = op.load.file("titanic3.xls")
df.plot.correlation("*")</pre>
			<p>这将显示<code>df</code>中每一列之间的关联矩阵:</p>
			<div><div><img src="img/B17166_05_5.jpg" alt="Figure 5.6 – Optimus correlation plot&#13;&#10;" width="390" height="252"/>
				</div>
			</div>
			<p class="figure-caption">图 5.6–Optimus 关联图</p>
			<p>每对可比较的列中都有一个颜色编码的值。这对于查看数据中的模式非常有用。</p>
			<p>请记住，Optimus 可以以 Python 字典格式提供所有这些数据，例如:</p>
			<ul>
				<li>使用<code>df.cols.hist()</code>的直方图</li>
				<li>使用<code>df.cols.frequency()</code>的频率图表</li>
				<li>使用<code>df.cols.boxplot()</code>的方框图</li>
				<li>使用<code>df.cols.scatter()</code>的散点图</li>
			</ul>
			<p>为了更全面地了解数据，你可以询问数据集的完整概要。我们去看看。</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>数据剖析</h1>
			<p>Optimus <a id="_idIndexMarker349"/>中有一个方便的函数叫做<code>profile</code>，它返回关于我们数据集的有用统计数据。让我们看看如何使用它:</p>
			<pre>df.profile(bins=5)</pre>
			<p>这段代码将返回一个字典:</p>
			<pre>{'columns': {'id': {'stats': {'match': 504,
    'missing': 0,
    'mismatch': 0,
    'profiler_dtype': {'dtype': 'int', 'categorical': True},
    'frequency': [{'value': 1, 'count': 1},
     {'value': 332, 'count': 1},
     {'value': 345, 'count': 1},
     {'value': 344, 'count': 1},
     {'value': 343, 'count': 1}],
    'count_uniques': 504},
   'dtype': 'int64'},
  'name': {'stats': {'match': 504,
    'missing': 0,
    'mismatch': 0,
    'profiler_dtype': {'dtype': 'str', 'categorical': True},
    'frequency': [{'value': 'pants', 'count': 254},
     {'value': 'shoes', 'count': 134},
     {'value': 'shirt', 'count': 116}],
    'count_uniques': 3},
   'dtype': 'object'},
  'code': {'stats': {'match': 504,
    'missing': 0,
    'mismatch': 0,
    'profiler_dtype': {'dtype': 'str', 'categorical': True},
    'frequency': [{'value': 'JG15', 'count': 60},
     {'value': 'JG10', 'count': 43},
     {'value': 'SK', 'count': 37},
     {'value': 'L15', 'count': 33},
     {'value': 'J15', 'count': 32}],
    'count_uniques': 39},
   'dtype': 'object'},
  'price': {'stats': {'match': 504,
    'missing': 0,
    'mismatch': 0,
    'profiler_dtype': {'dtype': 'decimal', 'categorical': 
False},
    'hist': [{'lower': 5.0, 'upper': 103.3675, 'count': 250},
     {'lower': 103.3675, 'upper': 201.735, 'count': 179},
     {'lower': 201.735, 'upper': 300.1025, 'count': 39},
     {'lower': 300.1025, 'upper': 398.47, 'count': 36}]},
   'dtype': 'float64'},
  'discount': {'stats': {'match': 294,
    'missing': 0,
    'mismatch': 210,
    'profiler_dtype': {'dtype': 'int', 'categorical': True},
    'frequency': [{'value': '0', 'count': 294},
     {'value': '5%', 'count': 65},
     {'value': '20%', 'count': 63},
     {'value': '15%', 'count': 54},
     {'value': '50%', 'count': 16}],
    'count_uniques': 6},
   'dtype': 'object'}},
'name': 'store.csv',
'file_name': ['store.csv'],
'summary': {'cols_count': 5,
  'rows_count': 504,
  'dtypes_list': ['float64', 'int64', 'object'],
  'total_count_dtypes': 3,
  'missing_count': 0,
  'p_missing': 0.0}
}</pre>
			<p>使用这个 Python 字典，您可以获得关于特定列的信息和关于整个数据帧的统计信息。</p>
			<p>对于 dataframe stats，您可以使用<code>profile.summary()</code>获得以下内容:</p>
			<ul>
				<li><code>cols_count</code>:数据帧中的列数</li>
				<li><code>rows_count</code>:数据帧中的行数</li>
				<li><code>dtypes_list</code>:数据帧中的数据类型列表</li>
				<li><code>total_count_dtypes</code>:数据帧中数据类型的计数</li>
				<li><code>missing_count</code>:数据帧中缺失值的数量</li>
				<li><code>p_missing</code>:数据帧中缺失值的百分比</li>
			</ul>
			<p>使用<code>profile.columns()</code>，您可以获得数据帧中每一列的信息<a id="_idIndexMarker351"/>。在这里面，你可以使用两个键，<code>stats</code>和<code>dtype.</code></p>
			<p>在<code>stats</code>中，您可以获得以下信息:</p>
			<ul>
				<li><code>match</code>:与<code>profiler_dtype</code>匹配的列中值的个数</li>
				<li><code>missing</code>:缺失值的个数</li>
				<li><code>Mismatch</code>:列中与<code>profiler_dtype</code>不匹配的值的数量，不包括空值</li>
				<li><code>profiler_dtype</code>:Optimus 推断的数据类型</li>
				<li><code>Frequency</code>:前<em class="italic"> n </em>值降序排列</li>
				<li><code>Hist</code>:每个箱中的值的密度</li>
				<li><code>count_uniques</code>:唯一值的个数</li>
			</ul>
			<p>Optimus 将根据数据类型计算频率或直方图。它将计算数字数据类型的直方图和字符串数据类型的频率。</p>
			<p>所有这些显示的信息可以让我们快速了解数据集中的内容，但是通过缓存这些元数据，我们可以赢得一些时间。让我们了解更多。</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/>缓存刷新</h1>
			<p>探索大数据<a id="_idIndexMarker352"/>可能是一个非常耗时的过程。您需要对一列进行操作，转换它的数据，检查输出是否是您想要的，并将它与另一列中的数据进行比较，包括它的频率、直方图和描述性分析。</p>
			<p>为了帮助您加速工作，Optimus 知道何时需要重新计算 profiler 统计数据，因此您不必等待，如果您正在处理大数据，这将非常有帮助。</p>
			<p>在内部，Optimus 声明了<a id="_idIndexMarker353"/>一些触发列概要重新计算的动作。要获得需要重新计算的操作的完整列表，可以使用以下命令:</p>
			<pre>from optimus.helpers.constants import Actions
Actions.list()</pre>
			<p><code>Actions.list()</code>会给我们一个 Python 列表:</p>
			<pre>['profiler_dtype', 'lower', 'upper', 'proper', 'pad', 'trim', 'reverse', 'remove', 'left', 'right', 'mid', 'replace', 'fill_na', 'cast', 'is_na', 'z_score', 'nest', 'unnest', 'set', 'string_to_index', 'date_format', 'index_to_string', 'min_max_scaler', 'max_abs_scaler', 'apply_cols', 'impute', 'extract', 'abs', 'math', 'variance', 'slice', 'clip', 'drop', 'keep', 'cut', 'to_float', 'to_integer', 'to_boolean', 'to_string', 'years', 'append', 'port', 'domain', 'domain_scheme', 'subdomain', 'host', 'domain_params', 'domain_path', 'email_domain', 'email_user', 'select_row', 'drop_row', 'between_drop', 'sort_row']</pre>
			<p>如果你看看这些名字，它们中的一些与我们已经使用过的处理数据的函数相匹配。</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>总结</h1>
			<p>在这一章中，我们学习了如何从我们的数据中提取高质量的数据，这样我们就可以应用一个转换来塑造它，并开始获取高质量的统计数据，这可以帮助我们理解数据之间的关系，并提取更好的见解。</p>
			<p>此外，我们还看到 Optimus 如何绘制这些数据，并将其转换成易于使用和理解的格式。</p>
			<p>现在我们知道了如何深入研究我们的数据，在下一章中，我们将学习如何应用字符串聚类技术来轻松地找到不同值的组，这些值可能是同一事物的替代表示。</p>
		</div>
	</div>
</body></html>