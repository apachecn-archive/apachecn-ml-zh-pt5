<html><head/><body>


	
		<title>B17076_08_ePub_RK</title>
		
	
	
		<div><h1 id="_idParaDest-146"><em class="italic"> <a id="_idTextAnchor149"/>第八章</em>:创建无代码数据分析/处理系统</h1>
			<p>创建<strong class="bold"> Danfo.js </strong>的一个主要目的是方便在浏览器中处理数据。这提供了将数据分析和处理数据无缝集成到 web 应用程序中的能力。除了给网络应用添加数据处理的能力，我们还有工具让数据处理和分析看起来更像设计师使用<strong class="bold"> Photoshop </strong>和<strong class="bold"> Figma </strong>时所做的事情；他们如何通过点击在画布上混合笔触，或者他们如何通过在画布上放置画布，通过拖放和点击按钮来操纵图像。</p>
			<p>有了 Danfo.js，我们可以轻松地实现这样一个环境(使用诸如<strong class="bold"> React.js </strong>和<strong class="bold"> Vue.js </strong>之类的工具)，在这个环境中，数据科学家变成了艺术家，只需点击几下按钮，就可以处理数据，并获得所需的输出，而无需实际编写任何代码。</p>
			<p>很多具有这种特性的工具普遍存在，但是 Danfo.js 最酷的地方是用 JavaScript 工具构建整个应用程序。事实上，在不调用服务器的情况下，在浏览器中完成所有操作是非常神奇的。</p>
			<p>本章的目的是展示如何使用 Danfo.js 和 React.js 构建这样一个环境。此外，请注意，此处使用的工具(除了 Danfo.js 之外)对于构建应用程序不是强制性的；这些只是我比较熟悉的工具。</p>
			<p>本章将涵盖以下主题:</p>
			<ul>
				<li>设置项目环境</li>
				<li>构建和设计应用程序</li>
				<li>应用程序布局和<code>DataTable</code>组件</li>
				<li>创建不同的<code>DataFrame</code>操作组件</li>
				<li>实现<code>Chart</code>组件</li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor150"/>技术要求</h1>
			<p>以下是本章的基本环境和知识要求:</p>
			<ul>
				<li>现代网络浏览器，如 Chrome 浏览器</li>
				<li>合适的代码编辑器，如<strong class="bold"> VScode </strong></li>
				<li><strong class="bold"> Node.js </strong>已安装</li>
				<li>关于<code>tailwindcss</code>和<code>React-chart-js</code>的一点知识</li>
				<li>需要 React.js 的基础知识。要复习 React.js，请查看 https://reactjs.org/docs/hello-world.html<a href="https://reactjs.org/docs/hello-world.html">的官方网站</a></li>
				<li>本章的代码可以从 GitHub 获得，可以从 https://GitHub . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/tree/main/chapter 08</li>
			</ul>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor151"/>设置项目环境</h1>
			<p>React.js 用于<a id="_idIndexMarker720"/>项目，为了设置 React app，我们将使用<code>create-react-app</code>包为我们自动生成一个前端构建管道。但是首先，确保你有 Node.js 和<code>npx</code>，一个<em class="italic"> npm 5.2+ </em>自带的包运行器工具。</p>
			<p>在我们进入<a id="_idIndexMarker721"/>设置我们的环境之前，这里是需要的工具，它们将被安装在本章中:</p>
			<ul>
				<li><strong class="bold"> React.js </strong>:用于构建 UI 的 JavaScript <a id="_idIndexMarker722"/>框架</li>
				<li><strong class="bold"> Draggable </strong>:一个拖放库，使得<a id="_idIndexMarker723"/>移动 HTML 元素成为可能</li>
				<li><code>chart</code>组件</li>
				<li><strong class="bold"> React-table-v6 </strong>:显示表格的 React 库<a id="_idIndexMarker725"/></li>
			</ul>
			<p>以下是上述工具的一些替代工具:</p>
			<ul>
				<li><strong class="bold"> Vue.js </strong>:用于<a id="_idIndexMarker726"/>构建 UI 的 JavaScript 库</li>
				<li>rechart.js :基于 React.js 构建的可组合<a id="_idIndexMarker727"/>图表库</li>
				<li><strong class="bold"> Material-table </strong>:基于<strong class="bold"> material-UI </strong>进行反应的数据表<a id="_idIndexMarker728"/></li>
			</ul>
			<p>为了创建 React app <a id="_idIndexMarker729"/>管道，我们使用<code>npx</code>调用<code>create-react-app</code>，然后指定我们项目的名称，如下所示:</p>
			<pre>$ npx create-react-app data-art</pre>
			<p>该命令将在启动该命令的父目录中创建一个名为<code>data-art</code>的目录。这个<code>data-art</code>目录预先填充了 React.js 模板和所有需要的包。</p>
			<p>下面是<code>data-art</code>文件夹的结构:</p>
			<div><div><img src="img/B17076_8_01.jpg" alt="Figure 8.1 – React.js directory structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.1–react . js 目录结构</p>
			<p>安装完成后，我们始终可以使用以下命令启动应用程序(假设您不在终端的<code>data-art</code>目录中):</p>
			<pre>$ cd data-art
$ yarn start</pre>
			<p>以下命令将启动应用服务器，并在终端中输出应用运行的服务器端口:</p>
			<div><div><img src="img/B17076_8_02.jpg" alt="Figure 8.2 – yarn start output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.2–纱线开始输出</p>
			<p>如<em class="italic">图 8.1 </em>所示，app 服务于<code>http://localhost:3000</code>。如果一切正常，那么一旦服务器启动，它将自动打开 web 浏览器来显示 React 应用程序。</p>
			<p>对于<a id="_idIndexMarker730"/>app 的开发，我们不会在造型上花更多的时间，但我们会在未来更容易集成造型，也能实现快速原型制作；我们将利用<code>tailwindcss</code>。</p>
			<p>为了让 Tailwind 与 React.js 应用程序一起工作，我们需要做一些额外的配置。</p>
			<p>让我们通过<code>tailwindcss</code>文档中的<a href="https://tailwindcss.com/docs/guides/create-react-app">https://tailwindcss.com/docs/guides/create-react-app</a>所示的<code>npm</code>安装 Tailwind 及其对等依赖项:</p>
			<pre>npm install -D tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9</pre>
			<p>安装完成后，我们将继续安装<code>craco</code>模块，这允许我们覆盖<code>postcss</code>配置，如下所示:</p>
			<pre>npm install @craco/craco</pre>
			<p>安装完<code>craco</code>之后，我们可以继续配置如何构建、启动和测试 React 应用程序。这将通过将<code>package.json</code>中的<code>"start"</code>、<code>"build"</code>和<code>"test"</code>命令更改为以下命令来完成:</p>
			<pre>{
  "start": "craco start",
  "build": "craco build",
  "test": "craco test",
}</pre>
			<p>根据前面所做的更改，让我们创建一个配置文件，使<code>craco</code>在构建 React 应用程序时能够始终注入<code>tailwindcss</code>和<code>autoprefixer</code>，如下面的<a id="_idIndexMarker731"/>代码所示:</p>
			<pre>// craco.config.js
module.exports = {
  style: {
    postcss: {
      plugins: [
        require('tailwindcss'),
        require('autoprefixer'),
      ],
    },
  },
}</pre>
			<p>我们来配置一下<code>tailwindcss</code>本身。有了这个配置，我们可以告诉<code>tailwindcss</code>删除生产中未使用的样式，我们可以添加自定义主题，我们还可以添加<code>tailwindcss</code>包中未包含的自定义颜色、字体、宽度和高度，如下所示:</p>
			<pre>//tailwind.config.js
module.exports = {
  purge: ["./src/**/*.{js,jsx,ts,tsx}", "./public/index.html"],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};</pre>
			<p>配置好 Tailwind 之后，我们将编辑<code>src</code>目录中的<code>css</code>文件<code>index.css</code>。我们将在文件中添加以下内容:</p>
			<pre>/* ./src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;</pre>
			<p>我们完成了<a id="_idIndexMarker732"/>配置；我们现在可以在<code>index.js</code>进口<code>index.css</code>:</p>
			<pre>//index.js
. . . . . .
import "./index.css
. . . . . .</pre>
			<p>注意，在<code>App.js</code>中，我们仍然拥有<code>create-react-app</code>包附带的默认代码；让我们编辑代码。下面是初始代码:</p>
			<pre>function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}</pre>
			<p>我们编辑<code>App</code>注释中的<a id="_idIndexMarker733"/> HTML 代码，方法是编辑 HTML 并用应用程序的名称替换它:</p>
			<pre>function App() {
  return (
    &lt;div className=""&gt;
      Data-Art
    &lt;/div&gt;
  );
}</pre>
			<p>通过使用前面的代码更新<code>App.js</code>并保存它，您应该可以直接在浏览器中看到所做的更改，如下面的屏幕截图所示:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B17076_8_03.jpg" alt="Figure 8.3 – React app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.3–反应应用程序</p>
			<p>让我们测试一下我们的<code>tailwindcss</code>配置，确保它设置正确。我们将通过在前面的代码中添加一些<a id="_idIndexMarker734"/>样式来做到这一点，如下所示:</p>
			<pre>function App() {
  return (
    &lt;div className="max-w-2xl border mx-auto text-3xl mt-60 text-center"&gt;
      Data-Art
    &lt;/div&gt;
  );
}</pre>
			<p>在名为<code>className</code>的<code>div</code>属性中声明了<code>css</code>样式。首先，我们设置最大宽度和边框，然后沿着<em class="italic"> x </em>轴创建一个边距(左右边距为<code>auto</code>)，声明字体大小为<code>text-3xl</code>，设置边距顶部为<code>60</code>，然后在<code>div</code>实例内居中文本。</p>
			<p>根据样式，我们应该看到以下输出:</p>
			<div><div><img src="img/B17076_8_04.jpg" alt="Figure 8.4 – Centering the div and text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.4–将 div 和文本居中</p>
			<p>代码库已经设置好了，我们已经准备好实现我们的无代码环境。</p>
			<p>在本节中，我们看到了如何为我们的应用程序设置一个 React 环境。我们还看到了如何为我们的应用配置<code>tailwindcss</code>。在下一部分，我们将学习如何构建和设计应用程序。</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor152"/>构建和设计应用程序</h1>
			<p>React.js 有一些<a id="_idIndexMarker735"/>应用程序设计的核心理念，主要是将 UI 分解成一个组件层次，其中一个想法是确定你的状态应该在哪里。</p>
			<p>在本节中，我们将<a id="_idIndexMarker736"/>了解如何使用 React.js 设计我们的无代码应用程序的结构，并考虑应用程序设计的 React 理念。有了这个原则，我们会发现在 React 中实现一个基本的 UI 很容易。</p>
			<p>首先，让我们了解什么是无代码环境，以及我们想要用它来实现什么。无代码环境用于简化数据处理和分析，只需点击几个按钮。</p>
			<p>我们将创建一个平台，用户可以在其中上传数据、执行分析，并使用代码做他们想做的事情，例如:</p>
			<ul>
				<li>数据帧到数据帧的操作，如<code>concat</code></li>
				<li>算术运算，如<code>cummax</code>和<code>cumsum</code></li>
				<li>通过列值过滤出数据帧的查询</li>
				<li>描述数据帧</li>
			</ul>
			<p>我们希望能够在不实际编码的情况下完成所有这些工作，一切都将在浏览器中完成。我们还希望通过使用条形图、折线图和饼图的数据可视化来获得对数据的洞察。下图是 app 设计的草图:</p>
			<div><div><img src="img/B17076_8_05.jpg" alt="Figure 8.5 – App structure and design sketch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.5–应用程序结构和设计草图</p>
			<p><em class="italic">图 8.5 </em>显示了<a id="_idIndexMarker737"/>app 的结构和设计。<a id="_idIndexMarker738"/>应用程序分为三个主要组件，如下所示:</p>
			<ul>
				<li><code>Navbar</code>组件，包含文件上传、条形图、折线图和<code>DataFrame</code>操作选择字段</li>
				<li>主体包含一个<code>Data Table</code>组件和一个<code>chart</code>组件</li>
				<li><code>SideBar</code>，包含图表和<code>DataFrame</code>操作的侧面</li>
			</ul>
			<p>app 工作流程可描述如下:</p>
			<ol>
				<li>首先，上传一个数据文件(<code>csv</code>)。</li>
				<li>通过上传文件，创建了第一个<code>Data Table</code>。这是一个包含数据帧显示的组件。</li>
				<li>为了执行任何操作，例如<code>DataFrame</code>操作或图表操作，选择数据表，以便我们可以识别要在其上执行操作的正确表格。</li>
				<li>对于图表操作，可以单击条形图、折线图或饼图。该点击事件激活图表操作的<code>Side Plane</code>。</li>
				<li>如果选择了<code>DataFrame</code>操作，则<code>Side Plane</code>被激活用于<code>DataFrame</code>操作。</li>
				<li>当您填写完<code>Side Plane</code>中的<a id="_idIndexMarker739"/>必要字段后，一个新的图表组件和<code>Data Table</code>组件<a id="_idIndexMarker740"/>被创建。</li>
			</ol>
			<p>下图描述了整个工作流程:</p>
			<div><div><img src="img/B17076_8_06.jpg" alt="Figure 8.6 – App workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.6–应用程序工作流程</p>
			<p>工作流显示了每个组件如何相互响应。例如，不上传文件，主体和<code>Side Plane</code>将不可见。即使上传了文件，<code>Side Plane</code>仍然是隐藏的，只有在特定数据表上执行数据帧或图表操作时才会出现。</p>
			<p>由此可见，我们需要创建一个状态来管理文件上传时主体的激活，还需要创建一个状态来管理在数据表上执行操作时如何激活<code>Side Plane</code>。另外，请注意<code>Side Plane</code>包含两个操作，我们必须根据所选的操作类型显示这些操作的字段。</p>
			<p>如果选择的是<a id="_idIndexMarker741"/>图表操作，<code>Side Plane</code>需要显示所选曲线图的必要字段，无论是条形图、折线图还是饼图，如果选择的是<code>DataFrame</code>操作，<code>Side Plane</code>需要<a id="_idIndexMarker742"/>显示 DataFrame 操作字段，如下图所示:</p>
			<div><div><img src="img/B17076_8_07.jpg" alt="Figure 8.7 – Side plane operation fields&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.7–侧面操作区域</p>
			<p>从<em class="italic">图 8.7 </em>中我们可以看到数据表和<code>chart</code>组件有一个<code>Data Table</code>组件和<code>chart</code>组件。每个组件都有一个状态，这使得我们可以根据需要创建、更新和删除组件。</p>
			<p>如应用程序工作流程中所述，<code>Side Plane</code>操作需要用于可视化和<code>DataFrame</code>操作的数据，这些数据是通过点击我们想要处理的<code>Data Table</code>获得的。每个<code>Data Table</code>存储它自己的 DataFrame 对象(我们将在实现这些步骤时深入研究)。因此，每当单击一个数据表时，它在数据表状态中的索引被获取，并被传递到与数据表状态并排的侧平面中，该侧平面指示要对哪个数据表进行操作。</p>
			<p>此外，为了让侧平面知道操作需要哪种图表类型(条形图、折线图或饼图)或要完成哪种类型的<code>DataFrame</code>操作，我们创建了一个状态来管理当前选择了哪种类型的<a id="_idIndexMarker743"/>图表或<code>DataFrame</code>。</p>
			<p>总之，所需的状态集<a id="_idIndexMarker744"/>描述如下:</p>
			<ul>
				<li>管理<code>DataTable</code>列表的状态</li>
				<li>管理图表列表的状态</li>
				<li>状态显示来管理<code>SidePlane</code>的可见性</li>
				<li>管理当前<code>DataTable</code>索引的状态</li>
				<li>管理所选图表类型的状态</li>
				<li>管理当前选择的<code>DataFrame</code>操作的状态</li>
			</ul>
			<p>这里创建的状态没有得到很好的优化。可以管理创建的状态的数量；例如，管理<code>Side Plane</code>可见性的相同状态也可用于管理所选图表的类型。</p>
			<p>由于我们将使用不止一个或两个状态，并且一些状态与另一个状态交互，我们可以使用<code>useReducer</code>(一个 React 钩子)来管理状态交互，但是我们希望在不增加额外知识的情况下使这变得简单。</p>
			<p>在这一部分，我们讨论了应用程序的设计和结构。我们还设计了应用程序工作流程，并讨论了要为应用程序创建的不同状态。下一节，我们将讨论 app 布局和<code>DataTable</code>组件。我们将看到如何创建数据表组件以及如何管理状态。我们还将研究用 Danfo.js 在浏览器中上传文件。</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor153"/>应用布局和数据表组件</h1>
			<p>在本节中，我们将看到<a id="_idIndexMarker745"/>如何根据上一节中讨论的设计和工作流程来布局应用程序。此外，我们将实现<code>DataTable</code>组件，负责显示<code>DataFrame</code>表。我们还将实现<code>DataTables</code>组件，负责显示不同的<code>DataTable</code>组件。</p>
			<p>我们已经看到了<a id="_idIndexMarker746"/>应用程序的草图，也看到了应用程序的基本工作流程。我们将开始实施步骤<a id="_idIndexMarker747"/>，首先构建应用程序的基本布局，然后实施数据表组件。</p>
			<p>有了<code>tailwindcss</code>，布局 app 相当容易。让我们创建一个名为<code>App.js</code>的文件，并输入以下代码:</p>
			<pre>function App() {
  return (
    &lt;div className="max-w-full mx-auto border-2 mt-10"&gt;
      &lt;div className="flex flex-col"&gt;
        &lt;div className="border-2 mb-10 flex flex-row"&gt;
          Nav
        &lt;/div&gt;
        &lt;div className="flex flex-row justify-between border-2"&gt;
          &lt;div className="border-2 w-full"&gt;
            &lt;div&gt;
              Main Body
            &lt;/div&gt;
 
          &lt;/div&gt;
          &lt;div className="border-2 w-1/3"&gt;
            Side Plane
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      
    &lt;/div&gt;
  );
}</pre>
			<p>前面的代码片段创建了带有<code>flex</code>框的应用程序布局。该布局显示了 app 的基本<a id="_idIndexMarker748"/>组件，分别是<code>Nav</code>、<code>Main Body</code>和<code>Side Plane</code>。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">教程中使用的<code>css</code>实例就不解释了。我们的主要重点是建立应用程序的功能。</p>
			<p>如果一切运行良好，我们应该<a id="_idIndexMarker749"/>得到如下输出:</p>
			<div><div><img src="img/B17076_8_08.jpg" alt="Figure 8.8 – App layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.8–应用程序布局</p>
			<p>我们已经设计好了应用程序。让我们继续实现<code>DataTable</code>组件来显示所有<code>DataFrame</code>操作的结果。</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor154"/>实现数据表组件</h2>
			<p>一个<code>DataTable</code>组件是<a id="_idIndexMarker750"/>负责数据表的显示。对于每个数据帧操作，我们生成一个显示操作结果的<a id="_idIndexMarker751"/>新数据表，如下图所示:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B17076_8_09.jpg" alt="Figure 8.9 – Data table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.9-数据表</p>
			<p>对于表格的显示，我们将使用一个名为<code>react-table-v6</code>的 React 包，因为我们希望<code>DataTable</code>组件可以在页面上拖动，所以有一个名为<code>react-draggable</code>的包，这使得实现这个特性更加容易。</p>
			<p class="callout-heading">注意</p>
			<p class="callout"><code>DataTable</code>的代码可以从这里拉出来:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/DataTable.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/datatable . js</a>。</p>
			<p>我们需要使用<code>yarn</code>将<a id="_idIndexMarker752"/>这些包添加到我们的<a id="_idIndexMarker753"/>代码库中:</p>
			<pre>yarn add react-table-v6 react-draggable</pre>
			<p>一旦安装了这些包，让我们按照以下步骤在<code>src/component/DataTable.js</code>文件中创建一个<code>DataTable</code>组件:</p>
			<ol>
				<li value="1">我们导入必要的包:<pre>import React from "react"; import ReactTable from 'react-table-v6' import Draggable from 'react-draggable'; import 'react-table-v6/react-table.css'</pre></li>
				<li>We create the <code>DataTable</code> component:<pre>export default function DataTable({ columns, values, setCompIndex, index }) {
  // DataTable component code here
}</pre><p><code>DataTable</code>组件接收以下<code>props</code>值:</p><ul><li><code>columns</code>:数据表列名。</li><li><code>values</code>:数据表各列数值。</li><li><code>setCompIndex</code>:这是一个状态函数，用于管理当前选中的数据表。</li><li><code>index</code>:这是当前表格的索引。</li></ul></li>
				<li>For the <code>react-table</code> component, we need to reshape the column and the values to fit the desired input for the <code>react-table</code> component.<p>让我们重塑要传递到<code>react-table</code>中的列<a id="_idIndexMarker754"/>值:</p><pre>const dataColumns = columns.map((val, index) =&gt; {
    return { Header: val, 
      accessor: val,
      Cell: (props) =&gt; (
        &lt;div className={val || ''}&gt;
          &lt;span&gt;{props.value}&lt;/span&gt;
        &lt;/div&gt;
      ),
      width:
        index === 0 &amp;&amp; (1280 * 0.8333 - 30) / columns.length &lt; 130
          ? 130
          : undefined,
    }
  });</pre><p>使用前面的<a id="_idIndexMarker755"/>代码，列名(即表的<code>Header</code>)被转换为以下形状:</p><pre>[{
  Header: "A",
  accessor: "A"
},{
  Header: "B",
  accessor: "B"
},{
  Header: "C",
  accessor: "C"
}]</pre><p><code>Header</code>键是表格中要显示的列的名称，<code>accessor</code>是数据中的键。</p></li>
				<li>我们需要将<a id="_idIndexMarker756"/>数据表的值转换成<code>react-table</code>需要的格式。下面的代码用于转换数据表的值:<pre>const data = values.map(val =&gt;{     let rows_data = {}     val.forEach((val2, index) =&gt; {       let col = columns[index];       rows_data[col] = val2;     })     return rows_data;   })</pre></li>
			</ol>
			<p>如前面的代码所示，我们<a id="_idIndexMarker757"/>将把数据表值转换成以下数据形式:</p>
			<pre>[{
  A: 2,
  B: 3,
  C: 5
},{
  A: 1,
  B: 20,
  C: 50
},{
  A: 23,
  B: 43,
  C: 55
}]</pre>
			<p>最初，<code>values</code>是一个数组的数组，该数组被转换成前面的数据格式，然后被赋给<code>data</code>变量。</p>
			<p>在<a id="_idIndexMarker758"/>前面的列格式中声明的访问器指向字典中每个键的值。有时，我们可能有以下格式的<a id="_idIndexMarker759"/>嵌套数据:</p>
			<pre>[{
  dummy: {
    A: 1.0,
    B: 3.0
  },
  dummy2: {
    J: "big",
    k: "small"
  }
}, . . . . ]</pre>
			<p>对于这种类型的数据格式，我们可以将<code>data</code>列声明为以下格式:</p>
			<pre>[{
  Header: "A",
  accessor: "dummy.A"
},
{
  Header: "B",
  accessor: "dummy.B"
},
{
  Header: "J",
  accessor: "dummy2.J"
},
{
  Header: "K",
  accessor: "dummy2.K"
}]</pre>
			<p>对于这个项目，我们不会使用这种嵌套的数据格式，所以没有必要深入研究，但是如果你有兴趣，你可以查看一下文档。</p>
			<p>包括<code>Header</code>在内的列名和表数据现在都是正确的格式，可以传递到<code>react</code>表中了。<code>DataTable</code>组件现已更新，包含以下<a id="_idIndexMarker761"/>代码:</p>
			<pre>function DataTable({ columns, values, setCompIndex, index }) {
 . . . . . . . . . . . . . . . . . . . .
const handleSidePlane = ()=&gt;{
    setCompIndex(index)
  }
  return (
    &lt;Draggable &gt;
        &lt;div className="w-1/2" onClick={()=&gt; handleSidePlane()}&gt;
        &lt;ReactTable
          data={data}
          columns={dataColumns}
          getTheadThProps={() =&gt; {
            return { style: { wordWrap: 'break-word', whiteSpace: 'initial' } }
          }}
          showPageJump={true}
          showPagination={true}
          defaultPageSize={10}
          showPageSizeOptions={true}
          minRows={10}
        /&gt;
    &lt;/div&gt;
    &lt;/Draggable&gt;
  )  
}</pre>
			<p><code>ReactTable</code>组件被<a id="_idIndexMarker762"/>包裹在<code>Draggable</code>组件中，使<code>DataTable</code>组件<a id="_idIndexMarker763"/>可拖动。在<code>ReactTable</code>组件中，我们设置了一些分页字段，比如设置默认页面为<code>10</code>。</p>
			<p>回想一下在设计我们提到的应用程序的工作流程时，如何在点击时跟踪一个<code>Data Table</code>的 ID。<code>handleSide Plane</code>函数用于调用<code>setCompIndex</code>。<code>setCompIndex</code>用于更新<code>compIndex</code>状态，存储所选<code>Data Table</code>的索引。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里有<code>DataTables</code>的代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/DataTables.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/datatables . js</a>。</p>
			<p>每个<a id="_idIndexMarker764"/>操作都会生成几个数据表，因此我们需要管理这个<code>Data Table</code>的显示。我们将创建一个组件来管理所有生成的<code>Data Tables</code>的显示；因此，我们将在组件目录中创建一个文件，并将其命名为<code>Data Tables</code>，包含下面的<a id="_idIndexMarker765"/>代码:</p>
			<pre>import React from 'react'
import DataTable from './DataTable'
export default function DataTables({datacomp, setCompIndex,}) {
  return (
    &lt;div&gt;
      {datacomp.map((val,index) =&gt; {
        return( 
                &lt;&gt;
                &lt;DataTable 
                  key={index} 
                  columns={val.columns} 
                  values={val.values} 
                  setCompIndex={setCompIndex}
                  index={index}                /&gt;
                &lt;/&gt;
                )
      })}
    &lt;/div&gt;
  )
}</pre>
			<p>该组件循环通过<code>datacomp</code>状态，并将每个道具传递给<code>DataTable</code>组件。</p>
			<p>在下一小节中，我们将继续<a id="_idIndexMarker766"/>并初始化不同的状态，还将展示如何上传 CSV 并获取我们的<a id="_idIndexMarker767"/>数据。</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>文件上传和状态管理</h2>
			<p>从应用程序的设计中，我们看到<a id="_idIndexMarker768"/>对于任何要发生的操作，我们需要先上传一个文件。通过上传文件，我们创建了将被<code>DataTable</code>和<code>chart</code>组件使用的<code>DataFrame</code>。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">在本章中，<code>App.js</code>中的代码是根据新组件的实现逐步更新的。不过<code>App.js</code>的最终代码在这里有:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/App.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/app . js</a>。</p>
			<p>我们将通过以下步骤更新<code>App.js</code>中的代码，以包含<code>Data</code>组件状态、文件上传和状态更新:</p>
			<ol>
				<li value="1">我们导入了<code>React</code>和一个名为<code>useState</code> : <pre>import React, { useState } from 'react';</pre>的 React 钩子</li>
				<li>我们导入<code>read_csv</code>方法，该方法将用于读取上传的 CSV 文件:<pre>import { read_csv } from 'danfojs/src/io/reader' // step 2</pre></li>
				<li>我们为生成的每个<code>DataTable</code>组件创建一个状态来存储数据列表:<pre>const [dataComp, setDataComp] = useState([])</pre></li>
				<li>We then create a<a id="_idIndexMarker770"/> function to manage<a id="_idIndexMarker771"/> file upload and read the uploaded file into a <code>DataFrame</code>:<pre>const changeHandler = function (event) {
    const content = event.target.files[0]
    const url = URL.createObjectURL(content)
 
    read_csv(url).then(df =&gt; { 
      const columns = df.columns
      const values = df.values
      setDataComp(prev =&gt; {
        let new_data = prev.slice()
        let key = new_data.length + 1
        let dict = {
          columns: columns,
          values: values,
          df: df,
          keys: "df" + key
        }
        new_data.push(dict)
        return new_data
      })
     
    }).catch((error) =&gt; {
      console.log(error)
    })
  }</pre><p>在前面的代码中，我们用<code>URL.createObjectURL</code>从上传的文件中生成一个 blob URL。这样做是因为<code>Danfo.js</code>中的<code>read_csv</code>代码仅取自<a id="_idIndexMarker772"/> CSV 文件的本地路径、CSV 文件的 HTTP URL 和 CSV 文件的 blob URL。</p><p>生成的 URL 是<a id="_idIndexMarker773"/>，然后传递给<code>read_csv</code>函数。由于<code>read_csv</code>是一个异步函数，我们需要等待承诺被解析，然后通过<code>then</code>方法从承诺中收集返回值。解析承诺的返回值是一个<code>DataFrame</code>。</p><p>使用<code>read_csv</code>，CSV 数据被转换为<code>DataFrame</code>，然后<code>DataComponent</code>状态被更新。使用<code>setDataComp</code>状态函数，我们创建了一个包含以下键的对象:</p><p>a) <code>columns</code>:存储 CSV 文件的标题(列名)</p><p>b) <code>values</code>:存储 CSV 数据点，即<code>DataFrame</code>值</p><p>c) <code>df</code>:存储生成的<code>DataFrame</code></p><p>d) <code>keys</code>:为每个数据成分生成一个密钥<code>data</code></p><p>需要做出一个决定，是将数据帧本身保存在每个组件的状态数据中。因为我们已经存储了列名和<code>DataFrame</code>值，所以看起来是多余的。</p><p>但是我们最终存储它的原因是，每次我们需要执行<code>DataFrame</code>操作时，总是从列和值创建一个<code>DataFrame</code>在计算上会很昂贵。</p><p>此外，<code>columns</code>和<code>values</code>被存储起来，以便在我们想要从<code>react-table</code>组件生成一个表时可以方便地访问。但是，它仍然感觉是多余的，作为一个个人练习(在这一节末尾列出的待办事项列表中)，你可以继续清理它。</p></li>
				<li>We print out the<a id="_idIndexMarker775"/> output of the <code>dataComp</code> state in the browser console once the state is updated:<pre>if (dataComp.length) { //step 8
    console.log("dataComp column", dataComp[0].columns)
    console.log("dataComp values", dataComp[0].values)
    console.log("dataComp dataFame", dataComp[0].df)
  }</pre><p>下面的截图显示了应用程序更新后的用户界面:</p></li>
			</ol>
			<div><div><img src="img/B17076_8_10.jpg" alt="Figure 8.10 – Updated UI for file upload&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.10-文件上传的更新用户界面</p>
			<p>上传文件后，我们应该会在浏览器控制台中看到以下输出:</p>
			<div><div><img src="img/B17076_8_11.jpg" alt="Figure 8.11 – dataComp state output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.11–数据组件状态输出</p>
			<p>我们已经为每个<code>DataTable</code>组件设置了文件上传<a id="_idIndexMarker776"/>和状态管理。让我们<a id="_idIndexMarker777"/>将创建的<code>DataTables</code>组件集成到应用程序中。</p>
			<h3>将数据表组件集成到 App.js 中</h3>
			<p><code>App.js</code>将通过以下步骤进行更新:</p>
			<ol>
				<li value="1">我们导入<code>DataTables</code>组件并创建一个<code>compIndex</code>状态，这使我们能够存储我们想要在<a id="_idIndexMarker778"/>时刻处理的<code>DataTable</code>组件的索引:<pre>. . . . . . . . . . . .  import DataTables from './components/DataTables'; function App() {    . . . . . . . . . .    const [compIndex, setCompIndex] = useState()   . . . . . . . . . . }</pre></li>
				<li>We then add the <code>DataTables</code> component to the <code>App</code> component:<pre>&lt;div&gt;
    {(dataComp.length &gt; 0) &amp;&amp;
        &lt;DataTables
            datacomp={dataComp}
            setCompIndex={setCompIndex}
        /&gt;
     }
&lt;/div&gt;</pre><p>为了启用<code>DataTable</code>组件可见性，我们检查<code>dataComp</code>状态是否为空。上传文件前，如果<code>dataComp</code>状态为空，<code>DataTable</code>组件将不可见。一旦文件被更新，<code>DataTable</code>组件<a id="_idIndexMarker779"/>变得可见，因为<code>dataComp</code>状态不再为空。</p><p>上传文件后，上面的代码应该会给出以下输出:</p></li>
			</ol>
			<div><div><img src="img/B17076_8_12.jpg" alt="Figure 8.12 – Display of the DataTable component on file upload&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.12–文件上传时数据表组件的显示</p>
			<p>在本节中，我们讨论了文件上传和<code>DataTable</code>创建和管理，并了解了如何管理状态。在下一节中，我们将实现不同的<code>DataFrame</code>操作组件，还将为<code>DataFrame</code>操作实现<code>Side Plane</code>。</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor156"/>创建不同的数据帧操作组件</h1>
			<p>在本节中，我们将<a id="_idIndexMarker780"/>创建不同的<code>DataFrame</code>操作组件，并为<code>DataFrame</code>操作组件实现<code>Side Plane</code>。Danfo.js 包含了很多<code>DataFrame</code>操作。如果我们要为每一个设计一个组件，这将是非常紧张和多余的。</p>
			<p>为了防止为每个<code>DataFrame</code>方法创建一个组件，我们根据它们的(关键字)参数，即根据传递给它们的变量，对每个<code>DataFrame</code>操作进行分组。例如，有些<code>DataFrame</code>方法只接受操作轴，因此我们可以将这些类型的方法组合在一起。</p>
			<p>下面是要创建的<code>DataFrame</code>操作组件和分组在它们下面的<code>DataFrame</code>方法的列表:</p>
			<ul>
				<li><code>DataFrame</code>参数仅为操作轴的方法，可以是<code>1</code>或<code>0</code>。对<code>DataFrame</code>进行算术运算的方法有<code>min</code>、<code>max</code>、<code>sum</code>、<code>std</code>、<code>var</code>、<code>sum</code>、<code>cumsum</code>、<code>cummax</code>、<code>cummin</code>。</li>
				<li><code>DataFrame</code>组件，如<code>DataFrame</code>与一个序列、一个值或一个<code>DataFrame</code>之间的逻辑运算。用于执行这些操作的方法有<code>concat</code>、<code>lt</code>、<code>gte</code>、<code>lte</code>、<code>gt</code>和<code>neq</code>。</li>
				<li><code>DataFrame</code>查询。</li>
				<li><code>DataFrame</code>统计。</li>
			</ul>
			<p>我们将开始查看这些组件的实现，从最不复杂的开始，顺序是:<code>Describe</code>、<code>query</code>、<code>Df2df</code>和<code>Arithmetic</code>。</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor157"/>实现描述组件</h2>
			<p>在本节中，我们将<a id="_idIndexMarker785"/>实现<code>Describe</code>组件，并集成<code>Side Plane</code>组件。</p>
			<p>在<code>src/Components/</code>目录中，让我们创建另一个名为<code>Side Planes</code>的文件夹。该文件夹将包含<code>DataFrame</code>操作的所有组件。</p>
			<p>在<code>Side Planes/</code>文件夹中，让<a id="_idIndexMarker786"/>创建一个名为<code>Describe.js</code>的<code>".js" </code>文件，并按照以下步骤更新它:</p>
			<ol>
				<li value="1">我们创建<code>Describe</code>功能组件，接受<code>dataComp</code>状态和<code>setDataComp</code>状态函数，用生成的<code>DataFrame</code> : <pre>export default function Describe({ dataComp, setDataComp}) { }</pre>更新<code>dataComp</code>状态</li>
				<li>We create a button named <code>Describe</code>:<pre>return (
    &lt;div&gt;
      &lt;button onClick={()=&gt; describe()} className="bg-blue-700 text-white rounded-sm p-2"&gt;Describe&lt;/button&gt;
    &lt;/div&gt;
)</pre><p><code>Describe</code>组件有一个按钮接口，因为它不接受任何参数。按钮有一个<code>onClick</code>事件，每当点击按钮时，该事件触发<code>Describe</code>功能。</p></li>
				<li>We then implement the <code>describe()</code> function, which is triggered anytime the <code>describe</code> button<a id="_idIndexMarker787"/> is clicked:<pre>const describe = ()=&gt; {
    const df = dataComp.df.describe()
    let column = df.columns.slice()
    column.splice(0,0, "index")
    const values = df.values 
    const indexes = df.index
 
    const new_values = values.map((val, index)=&gt; {
      let new_val = val.slice()
      new_val.splice(0,0, indexes[index]) 
       return new_val
    })
 . . . . . . . . 
}</pre><p>我们从<code>dataComp</code>状态获取包含<code>DataFrame</code>的<code>df</code>键，然后调用<code>describe</code>方法。</p><p>从由<code>describe</code>操作生成的<code>DataFrame</code>中，我们获得列，并向列名列表添加一个索引。索引被添加到列表的开头；这样做是因为需要从<code>describe </code>方法生成的索引来捕获数据中的每一行。</p><p>接下来，我们获取<code>DataFrame</code>值，对其进行循环，并将索引值添加到获取的<code>DataFrame</code>值中。</p></li>
				<li>我们用新生成的列、值和<code>DataFrame</code> : <pre>setDataComp(prev =&gt; { // step 7     let new_data = prev.slice()     let dict = {       columns: column,       values: new_values,       df: df     }     new_data.push(dict)     return new_data })</pre>更新<code>dataComp</code>状态</li>
			</ol>
			<p>为了查看该组件的运行情况，我们需要实现<code>DataFrame</code>操作选择字段，如图<em class="italic">图 8.5 </em>中的<code>App</code>设计草图所示的<a id="_idIndexMarker789"/>。该<code>DataFrame</code>操作选择域使我们能够选择在<code>Side Plane</code>中显示哪个<code>DataFrame</code>操作组件。</p>
			<p>为此，我们需要在<code>Navbar</code>组件中为<code>DataFrame</code>操作添加<a id="_idIndexMarker790"/>字段，以及用于文件上传的输入字段。此外，我们需要为<code>Side Plane</code>中显示的每个<code>DataFrame</code>操作组件实现条件渲染。</p>
			<h3>为描述组件设置侧面板</h3>
			<p>在<code>Side Planes/</code>文件夹中，我们创建一个名为<code>Side Plane.js</code>的文件，并输入以下<a id="_idIndexMarker791"/>代码:</p>
			<pre>import React from 'react'
import Describe from './Describe'
export default function SidePlanes({dataComp, 
  dataComps,
  setDataComp,
  df_index,
  dfOpsType}) {
 
    if(dfOpsType === "Arithemtic") {
      return &lt;div&gt; Arithmetic &lt;/div&gt;
    }
    else if(dfOpsType === "Describe") {
      return &lt;Describe 
          dataComp={dataComp}
          setDataComp={setDataComp}
      /&gt;
    }
    else if(dfOpsType === "Df2df") {
      return &lt;div&gt; Df2df &lt;/div&gt;
    } 
    else if(dfOpsType === "Query") {
      return &lt;div&gt; Query &lt;/div&gt;
    }
  return (
    &lt;div&gt;
      No Plane
    &lt;/div&gt;
  )
}</pre>
			<p>在前面的代码中，我们创建了一个<code>Side Plane</code>组件。该组件包含基于所选数据操作类型的条件呈现。选择的<code>DataFrame</code>操作由<code>dfOpsType</code>状态管理。</p>
			<p><code>Side Plane</code>进入<code>dataComp</code>状态，它可以是存储在<code>dataComps</code>状态的任何数据。一些<code>DataFrame</code>操作将需要选定的<code>dataComp</code>状态以及整个状态，也就是<code>dataComps</code>状态，用于其操作。</p>
			<p>在<code>Side Plane</code>组件中，我们将检查<code>dfOpsType</code>以找出传递的操作类型和要在侧平面中呈现的<a id="_idIndexMarker792"/>接口。</p>
			<p>在我们将<code>Side Plane</code>集成到<code>App.js</code>之前，让我们在<code>Side Planes/</code>文件夹中创建一个<code>index.js</code>文件。这样，我们就可以定义要导入的组件。由于我们使用的是来自<code>Side Plane</code>组件的条件渲染，我们只需要在<code>index.js</code>实例中导出<code>Side Plane</code>组件，如以下代码所示:</p>
			<pre>import SidePlane from './SidePlane'
export { SidePlane }</pre>
			<p>前面的代码使我们能够在<code>App.js</code>中导入<code>Side Plane</code>。</p>
			<h3>将 SidePlane 集成到 App.js</h3>
			<p><code>Side Plane</code>被创造出来。让我们将<a id="_idIndexMarker793"/>集成到<code>App.js</code>中，并将用于<code>DataFrame</code>操作的 HTML <code>select</code>字段添加到<code>App.js,</code>中，如以下代码所示:</p>
			<ol>
				<li value="1">我们导入<code>SidePlane</code>组件:<pre>import { SidePlane } from './components/SidePlanes' </pre></li>
				<li>We update the <code>App</code> component functionality with the following code:<pre>function App() {
  . . . . . . . . 
  const [dfOpsType, setDfOpsType] = useState() // step 2
  const [showSidePlane, setSidePlane] = useState(false) //step 3
  . . . . . . . . . 
  const dataFrameOps = ["Arithemtic", "Describe", "Df2df", "Query"] // step 4
  const handleDfops = (e) =&gt; { //step 6
    const value = e.target.value
    setDfOpsType(value)
    setSidePlane("datatable")
  }
 . . . . . . . . . . . . . . 
}</pre><p>在前面的代码中，我们创建了<code>dfOpsType</code>状态来存储当前选择的<code>DataFrame</code>操作的类型。</p><p><code>showSidePlane</code>也被创建<a id="_idIndexMarker794"/>来管理<code>SidePlane</code>可见性。此外，还创建了一个<code>DataFrame</code>操作数组。然后我们创建一个函数来处理每当点击<code>DataFrame</code>操作时更新<code>dfOpsType</code>和<code>showSidePlane</code>状态。</p></li>
				<li>We then add the <code>SidePlane</code> component:<pre>&lt;div className="border-2 w-1/3"&gt;
     {showSidePlane
          &amp;&amp;
          (
           showSidePlane === "datatable" ?
              &lt;div className="border-2 w-1/3"&gt;
                &lt;SidePlane
                  dataComp={dataComp[compIndex]}
                  dataComps={dataComp}
                  df_index={compIndex}
                  setDataComp={setDataComp}
                  dfOpsType={dfOpsType}
                 /&gt;
              &lt;/div&gt; :
              &lt;div className="border-2 w-1/3"&gt;
                    Chart Plane
              &lt;/div&gt;
         )
    }
&lt;/div&gt;</pre><p>在前面的代码中，我们通过首先检查<code>SidePlane</code>状态不为<em class="italic">假</em>来显示<code>SidePlane</code>，然后我们检查要显示的<code>SidePlane</code>的类型。因为我们只实现了<code>DataFrame</code>操作列表中的<a id="_idIndexMarker795"/>组件，所以让我们上传一个文件，然后执行一个<code>DataFrame</code>操作。下面的截图显示了对<code>DataTable</code>执行<code>Describe</code>操作的结果:</p></li>
			</ol>
			<div><div><img src="img/B17076_8_13.jpg" alt="Figure 8.13 – Describe operation on DataTable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.13–描述对数据表的操作</p>
			<p>在前面的截图中，左上角的数据表是上传文件时生成的，右下角的<code>DataFrame</code>是<code>Describe</code>操作的结果。</p>
			<p>在本节中，我们看到了如何<a id="_idIndexMarker796"/>实现<code>Describe</code>组件以及如何管理<code>Side Plane</code>可见性。在下一节中，我们将为<code>DataFrame</code>中的<code>Query</code>方法实现<code>Query</code>组件。</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor158"/>实现查询组件</h2>
			<p>在本节中，我们将为<code>DataFrame</code>查询<a id="_idIndexMarker798"/>方法创建一个<a id="_idIndexMarker797"/>组件。该组件将帮助根据<code>Data Table</code>按列值过滤<code>DataFrame</code>。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里有一个<code>Query</code>组件的代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Query.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/query . js</a>。</p>
			<p>让我们在<code>components/Side Planes/</code>文件夹中创建一个名为<code>Query.js</code>的文件，并按照以下步骤更新它:</p>
			<ol>
				<li value="1">We create the <code>Query</code> component:<pre>import React, { useRef } from 'react'
 
export default function Query({ dataComp, setDataComp}) {
  // step 1
  const columnRef = useRef()
  const logicRef = useRef()
  const valuesRef = useRef()
 . . . . . . . . . . . . 
}</pre><p>我们创建了一个<code>useRef</code>钩子变量，它使我们能够获得以下输入字段的输入的当前值:列字段(接受用于<a id="_idIndexMarker799"/>查询的列的名称)、逻辑字段(接受用于查询的逻辑值)和值字段(接受用于查询所选列的值)。</p></li>
				<li>We then update the <code>Query</code> component with the following code:<pre>  const columns = dataComp.columns
  const logics = ["&gt;", "&lt;", "&lt;=", "&gt;=", "==", "!="]</pre><p>在前面的代码中，我们获得了当前<code>Data Table</code>的<code>DataFrame</code>中可用的列名。该列名将用于填充选择字段，用户可以选择要查询的列。</p><p>我们还创建了一个符号列表来描述我们想要执行的逻辑操作的类型。该符号也将用于填充选择字段，用户可以<a id="_idIndexMarker800"/>选择用于查询的逻辑操作。</p></li>
				<li>创建一个<code>query</code>函数。每当点击<a id="_idIndexMarker801"/><strong class="bold">查询</strong>按钮时，该功能将被触发执行查询操作:<pre>const query = ()=&gt;{     const qColumn = columnRef.current.value     const qLogic = logicRef.current.value     const qValue = valuesRef.current.value        const  df = dataComp.df.query({column: qColumn, is: qLogic, to: qValue})     setDataComp(prev =&gt; {       let new_data = prev.slice()       let dict = {         columns: df.columns,         values: df.values,         df: df       }       new_data.push(dict)       return new_data     })   }</pre></li>
			</ol>
			<p>每当触发<code>query </code>功能时，我们获得每个输入字段(选择字段)的值。例如，为了获得列字段的值，我们使用了<code>columnRef.current.value</code>。同样的事情也适用于获取另一个字段中的值。</p>
			<p>我们还调用属于当前<code>dataComp</code>状态的<code>DataFrame</code>的查询方法。从每个输入字段获得的值被传递到查询方法中，以执行<a id="_idIndexMarker802"/>操作。</p>
			<p>使用<code>setDataComp</code>状态功能更新<code>dataComps</code>状态。通过更新<code>dataComps</code>状态，创建一个新的<a id="_idIndexMarker803"/>状态，包含<code>query</code>方法的结果。</p>
			<h3>实现查询组件接口</h3>
			<p>我们已经看到了<code>Query</code>组件的<a id="_idIndexMarker804"/>后端，所以现在让我们为它构建一个接口。让我们用以下步骤更新<code>Query.js</code>中的代码:</p>
			<ol>
				<li value="1">For the query UI, we create a form containing three different input fields. First, we create the input field for the column field:<pre>&lt;div&gt;
  &lt;span className="mr-2"&gt;Column&lt;/span&gt;
    &lt;select ref={columnRef} className="border"&gt;
      {
         columns.map((column, index)=&gt; {
          return &lt;option value={column}&gt;{column}&lt;/option&gt;
         })
      }
    &lt;/select&gt;
&lt;/div&gt;</pre><p>对于列字段，我们遍历列数组，为<code>DataFrame</code>中的列列表创建 HTML 选择字段选项。我们还包括<code>columnRef</code>来跟踪所选择的列名。</p></li>
				<li>We then create the logic input field:<pre>&lt;div&gt;
  &lt;span className="mr-2"&gt;is&lt;/span&gt;
  &lt;select ref={logicRef} className="border"&gt;
     {
       logics.map((logic, index)=&gt; {
         return &lt;option value={logic}&gt;{logic}&lt;/option&gt;
       })
     }
  &lt;/select&gt;
&lt;/div&gt;</pre><p>我们遍历<code>logic</code>数组<a id="_idIndexMarker805"/>并用逻辑运算符填充 HTML 选择字段。另外，<code>logicRef</code>被添加到 HTML 选择字段中，以获得所选择的逻辑运算符。</p></li>
				<li>然后，我们为查询值<pre>&lt;div&gt;   &lt;span className="mr-2"&gt;to&lt;/span&gt;     &lt;input ref={valuesRef} placeholder="value" className="border"/&gt; &lt;/div&gt;</pre>创建<code>input</code>字段</li>
				<li>We create a <code>button</code> class name to make a call to the <code>query</code> function:<pre>&lt;button onClick={()=&gt;query()} className="btn btn-default dq-btn-add"&gt;Query&lt;/button&gt;</pre><p>为了可视化主应用程序<a id="_idIndexMarker806"/>中的<code>query</code>组件，让我们更新<code>SidePlane.js</code>中的<code>SidePlane</code>组件:</p><pre>Previous code:
 . . . . . . . .
else if(dfOpsType === "Query") {
      return &lt;div&gt; Query &lt;/div&gt;
    }
Updated code:
else if(dfOpsType === "Query") {
      return &lt;Query 
            dataComp={dataComp}
            setDataComp={setDataComp}
      /&gt;
    }</pre></li>
			</ol>
			<p>前面的代码更新了<code>Side Plane</code>以包含<code>Query</code>组件。如果我们对上传的文件执行查询操作，应该会得到以下结果:</p>
			<div><div><img src="img/B17076_8_14.jpg" alt="Figure 8.14 – Query operation run on column C, checking whether its value is greater than 20&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.14–在列 C 上运行查询操作，检查其值是否大于 20</p>
			<p>在本节中，我们创建了一个<code>query</code>组件。在下一节中，我们将研究如何为涉及<code>DataFrame</code>到<code>DataFrame</code>操作、序列和标量值的<a id="_idIndexMarker807"/>操作创建一个组件。</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor159"/>实现 Df2df 组件</h2>
			<p>在本节中，我们将<a id="_idIndexMarker808"/>实现一个<a id="_idIndexMarker809"/>组件，用于在一个<code>DataFrame</code>和另一个<code>DataFrame</code>、<code>Series</code>和<code>Scalar</code>值之间执行运算。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里有<code>Df2df</code>组件的代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Df2df.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/df2df . js</a>。</p>
			<p>Danfo.js 中有不同的组件来执行<code>DataFrame</code>和<code>Series</code>以及<code>DataFrame</code>和<code>Scalar</code>值之间的操作。为了避免为每个方法创建一个组件，我们可以将它们组合在一起形成一个组件。</p>
			<p>我们计划组合在一起的<code>DataFrame</code>方法列表如下:</p>
			<ul>
				<li>小于(<code>df.lt</code>)</li>
				<li>大于(<code>df.gt</code>)</li>
				<li>不等于(<code>df.ne</code>)</li>
				<li>等于(<code>df.eq</code>)</li>
				<li>大于或等于(<code>df.ge</code>)</li>
				<li>加法(<code>df.add</code>)</li>
				<li>减法(<code>df.sub</code>)</li>
				<li>乘法(<code>df.mul</code>)</li>
				<li>司(<code>df.div</code>)</li>
				<li>力量(<code>df.pow</code>)</li>
			</ul>
			<p>在前面的<a id="_idIndexMarker810"/>方法列表中，一个共同的属性是它们都接受相同类型的参数，即值(可以是<code>DataFrame</code>、<code>Series</code>或<code>scalar</code>值)和要执行操作的轴。</p>
			<p>如果我们看一下<code>DataFrame</code> <code>concat</code>方法，它也接受与前面列表中的方法相似的相同模式的参数。唯一的区别是对于<code>concat</code>方法来说，<code>df_list</code>参数是一个<code>DataFrames</code>的数组。</p>
			<p>让我们在<code>Side Planes/</code>文件夹中创建一个名为<code>Df2df.js</code>的文件。在该文件中，我们将通过以下步骤实现<code>Df2df</code>组件:</p>
			<ol>
				<li value="1">First, we import <code>concat</code> from Danfo.js, and then create the <code>Df2df</code> component:<pre>import React, { useRef } from 'react'
import { concat } from 'danfojs/src/core/concat'
 
export default function Df2df({dataComp, dataComps,df_index, setDataComp}) {
  const dfRef = useRef()
  const inpRef = useRef()
  const axisRef = useRef()
  const opsRef = useRef()
 
  const allOps = [
    "lt", "ge", "ne",
    "eq", "gt", "add",
    "sub", "mul", "div",
    "pow", "concat"
  ]
 . . . . . . . . .  . . . . 
}</pre><p>我们为每个输入字段创建了一个引用变量<a id="_idIndexMarker811"/>。对于<code>Df2df</code>操作，我们有四个输入域(<code>DataFrame</code>选择域、<code>scalar</code>值输入域、<code>axis</code>域和<code>operation</code>类型域)。</p><p><code>operation</code>类型字段包含<code>Df2df</code>组件中所有可用操作的列表。这将是一个选择字段，因此用户可以选择要处理的任何操作。</p><p>我们还创建了一个由<code>Df2df </code>组件提供的所有操作的<code>allOps</code>列表。</p></li>
				<li>We also need to create a function to perform the <code>Df2df</code> operation whenever the <code>submit</code> button is clicked:<pre>const df2df = () =&gt; {
    // step 4
    let dfIndex = dfRef.current.value
    let inp = parseInt(inpRef.current.value)
    let axis = parseInt(axisRef.current.value)
    let ops = opsRef.current.value
 . . . . . . . . . . . . . .
}</pre><p>我们从属于每个输入字段的所有参考变量中获得了<a id="_idIndexMarker812"/>值。</p></li>
				<li>We update the <code>df2df</code> function with the following code:<pre>  if( ops != "concat") {
      let value = dfIndex === "None" ? inp : dataComps[dfIndex].df
      let df = dataComp.df
 
      let rslt = eval('df.${ops}(value, axis=${axis})') // step 6
 
      setDataComp(prev =&gt; {
        let new_data = prev.slice()
        let key = new_data.length +1
        let dict = {
          columns: rslt.columns,
          values: rslt.values,
          df: rslt,
          keys: "df" + key
        }
        new_data.push(dict)
        return new_data
      })
    }</pre><p>我们检查选择的操作不是<code>concat</code>操作。这样做是因为<code>concat</code>操作接受一个<code>DataFrames</code>列表，而不仅仅是一个<code>DataFrame</code>或<code>Series</code>。</p><p>我们利用<code>eval</code>函数来防止编写多个<code>if</code>条件来检查调用哪个<code>DataFrame</code>操作。</p></li>
				<li>我们为<code>concat</code>操作实现<a id="_idIndexMarker813"/>条件。我们还调用了<code>DataFrame</code> : <pre>. . . . . . . . . else { // step 7       let df2 = dataComps[dfIndex].df       let df1 = dataComp.df       let rslt = concat({ df_list: [df1, df2], axis: axis })         let column = rslt.columns.slice()       column.splice(0,0,"index")       let rsltValues = rslt.values.map((val, index) =&gt; {         let newVal = val.slice()         newVal.splice(0,0, rslt.index[index])         return newVal       })      . . . . . . . . . . .  }</pre>中的<code>concat</code>方法</li>
			</ol>
			<p>前面的步骤显示了<code>Df2df</code>组件的后端实现。</p>
			<h3>实现 Df2df 组件接口</h3>
			<p>让我们通过以下步骤更新<a id="_idIndexMarker814"/>UI 的代码:</p>
			<ol>
				<li value="1">For the UI, we need to create a form containing  four input fields. First, we create an input field to select the type of <code>DataFrame</code> operation we want:<pre>&lt;div&gt;
  &lt;span className="mr-2"&gt; Operations&lt;/span&gt;
   &lt;select ref={opsRef}&gt;
    {
      allOps.map((val,index) =&gt; {
       return &lt;option value={val} key={index}&gt;{val}&lt;/option&gt;
       })
     }
   &lt;/select&gt;
&lt;/div&gt;</pre><p>我们遍历<code>allops</code>数组来创建一个<code>input</code>字段，以选择不同类型的<code>DataFrame</code>操作。</p></li>
				<li>We then create an <code>input</code> field to select the <code>DataFrame</code> we want to perform the operation <a id="_idIndexMarker815"/>selected on:<pre>&lt;div&gt;
  &lt;span className="mr-2"&gt; DataFrames&lt;/span&gt;
   &lt;select ref={dfRef}&gt;
      &lt;option key={-1}&gt;None&lt;/option&gt;
        {
          dataComps.map((val,index) =&gt; {
            if( df_index != index) {
              return &lt;option value={index} key={index}&gt;{'df${index}'}&lt;/option&gt;
            } 
         })
        }
   &lt;/select&gt;
&lt;/div&gt;</pre><p>我们还循环遍历<code>dataComps</code>状态，以获得除了我们正在执行操作的<code>dataComp</code>状态之外的所有<code>dataComp</code>状态。</p></li>
				<li>然后我们创建一个<code>input</code>字段来输入我们的值；在这种情况下，我们正在执行<code>DataFrame</code>和<code>Scalar</code>值之间的运算:<pre>&lt;div&gt;   &lt;span&gt;input a value&lt;/span&gt;   &lt;input ref={inpRef} className="border" /&gt; &lt;/div&gt;</pre></li>
				<li>我们创建一个<code>input</code>字段来选择操作轴:<pre>&lt;div&gt;   &lt;span&gt;axis&lt;/span&gt;   &lt;select ref={axisRef} className="border"&gt;     {       [0,1].map((val, index) =&gt; {         return &lt;option value={val} key={index}&gt;{val}&lt;/option&gt;        })     }  &lt;/select&gt; &lt;/div&gt;</pre></li>
				<li>We then create a button<a id="_idIndexMarker816"/> that triggers the <code>df2df</code> function to perform a Df2df operation based on the input fields:<pre>&lt;button onClick={()=&gt;df2df()} className="bg-blue-500 p-2 text-white rounded-sm"&gt;generate Dataframe&lt;/button&gt;</pre><p>在前面的步骤中，我们为组件创建了 UI。</p><p>让我们更新<code>SidePlane</code>组件以包含 Df2df 组件:</p><pre>import Df2df from './Df2df'
export default function SidePlanes({dataComp, 
  dataComps,
  setDataComp,
  df_index,
  dfOpsType}) {
    . . . . . . . . 
    else if(dfOpsType === "Df2df") {
      return &lt;Df2df 
          dataComp={dataComp}
          dataComps={dataComps}
          df_index={df_index}
          setDataComp={setDataComp}
      /&gt;
    } 
   . . . . . . . . .
   
   }</pre><p>前面的代码将<code>Df2df</code>组件添加到<code>SidePlane</code>组件中，并且<a id="_idIndexMarker817"/>在<code>Df2df</code>组件中传递所需的道具。以下屏幕截图显示了两个内容相同的 CSV 文件的上传:</p></li>
			</ol>
			<div><div><img src="img/B17076_8_15.jpg" alt="Figure 8.15 – Uploading CSV files with the same content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.15–上传具有相同内容的 CSV 文件</p>
			<p>下面显示了对选中的<code>Data Table</code>执行<code>Df2df</code>操作(具体为<code>concat</code>操作)的输出<a id="_idIndexMarker818"/>:</p>
			<div><div><img src="img/B17076_8_16.jpg" alt="Figure 8.16 – Performing a concat operation on the Data Table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.16–对数据表执行 concat 操作</p>
			<p>在本节中，我们创建了用于在两个<code>DataFrames</code>之间以及一个<code>DataFrame</code>和一个<code>Series</code> / <code>Scalar</code>值之间执行运算的<code>Df2df</code>组件。</p>
			<p>在下一节中，我们<a id="_idIndexMarker819"/>将实现最后一个<code>DataFrame</code>组件，这是用于<code>DataFrame</code>算术运算的<code>arithmetic</code>组件。</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>实现算术组件</h2>
			<p>我们将实现<code>arithmetic</code>组件来执行<code>Danfo.js</code>中提供的一些算术运算<a id="_idIndexMarker820"/>。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里有<code>Arithmetic</code>组件的代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Arithemtic.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/arith em TIC . js</a>。</p>
			<p>让我们在<code>Side Planes/</code>文件夹中创建一个名为<code>Arithmetic.js</code>的文件。以下步骤将用于创建<code>Arithmetic</code>组件:</p>
			<ol>
				<li value="1">We create an <code>Arithmetic</code> component:<pre>import React, { useRef } from 'react'
export default function Arithmetic({ dataComp, setDataComp}) {
 
  const seriesOps = ["median", "min", "max", "std", "var", "count", "sum"]
  const dfOps = ["cumsum", "cummax", "cumprod", "cummin"]
  const all = ["median", "min", "max", "std", "var", "count", "sum",
               "cumsum", "cummax", "cumprod", "cummin"]
 
  const axisRef = useRef()
  const opsRef = useRef()
 . . . . . . . . . . . .
}</pre><p>我们创建不同的数组<a id="_idIndexMarker821"/>来存储不同的操作，比如<code>seriesOps</code>用于串行操作，而<code>dfOps</code>用于数据帧操作。我们还创建了一个<code>all</code>数组，将所有这些操作(<code>Series</code>和<code>DataFrame</code>)存储在一起。</p></li>
				<li>We create a function called <code>arithmetic</code>. This function is used to perform the arithmetic operations:<pre>const arithemtic = () =&gt; {
 
    let sOps = opsRef.current.value
    let axis = axisRef.current.value
    if( seriesOps.includes(sOps)) {
      let df_comp = dataComp.df
      let df = eval('df_comp.${sOps}(axis=${axis})')
      
      let columns = Array.isArray(df.columns) ? df.columns.slice() : [df.columns]
      columns.splice(0,0, "index")
      let values = df.values.map((val,index) =&gt; {
 
        return [df.index[index], val]
      })
. . . . . . . . . . . 
}</pre><p>我们从输入字段<code>opsRef.current.value</code>和<code>axisRef.current.value</code>中获取值。我们还<a id="_idIndexMarker822"/>检查选择的操作是否属于<code>seriesOps</code>。如果是，我们执行选择的操作。</p></li>
				<li>We perform a <code>DataFrame</code> operation if the operation does not belong to <code>seriesOps</code>:<pre>else {
 
      let df_comp2 = dataComp.df
      let df = eval('df_comp2.${sOps}({axis:${axis}})')
 
      setDataComp(prev =&gt; {
        let new_data = prev.slice()
        let dict = {
          columns: df.columns,
          values: df.values,
          df: df
        }
        new_data.push(dict)
        return new_data
      })
    }</pre><p>上述步骤用于创建<code>Arithmetic</code>组件。<code>Arithmetic</code>的 UI 是与创建的其他<code>DataFrame</code>操作组件相同的<a id="_idIndexMarker823"/>。</p><p>让我们将<code>arithmetic</code>组件添加到<code>SidePlane</code>组件中:</p><pre>import Arithmetic from './Arithmetic'
export default function SidePlanes({dataComp, 
  dataComps,
  setDataComp,
  df_index,
  dfOpsType}) {
    . . . . . . . . 
    if(dfOpsType === "Arithmetic") {
      return &lt;Arithmetic 
            dataComp={dataComp}
            setDataComp={setDataComp}
      /&gt;
    }
   . . . . . . . . .
   
   }</pre><p>前面的代码导入<code>Arithmetic</code>组件并检查<code>dfOpsType</code>组件是否为<code>Arithmetic</code>。</p><p>以下截图<a id="_idIndexMarker824"/>显示了对<code>Data Table</code>执行算术运算的示例:</p></li>
			</ol>
			<div><div><img src="img/B17076_8_17.jpg" alt="Figure 8.17 – Arithmetic operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.17–算术运算</p>
			<p>在本节中，我们讨论并实现了作为 React 组件的不同的<code>DataFrame</code>操作。我们能够将一些方法组织成一个单独的组件，以避免为每个操作创建组件<a id="_idIndexMarker825"/>。</p>
			<p>在下一节中，我们将为不同的可视化实现一个<code>chart</code>组件。</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor161"/>实现图表组件</h1>
			<p>在本节中，我们将<a id="_idIndexMarker826"/>创建<code>chart</code>组件来显示常见和简单的图表，如条形图、折线图和饼图。然后我们将实现图表<code>Side Plane</code>来启用图表组件变量的设置。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">实现的<code>Chart</code>和<code>ChartPlane</code>组件的代码可从这里获得:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/ChartPlane.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/chart plane . js</a>。</p>
			<p>在<code>src/components/</code>目录中，让我们创建一个名为<code>Chart.js</code>的文件，通过以下步骤实现<code>Chart</code>组件:</p>
			<ol>
				<li value="1">We import our desired plotting component from <code>react-chartjs-2</code>, and then create the <code>Chart</code> component:<pre>import { Bar as BarChart } from 'react-chartjs-2';
import { Line as LineChart } from "react-chartjs-2";
import { Pie as PieChart} from "react-chartjs-2";
import Draggable from 'react-draggable';
 
export default function Chart({labels, dataset,type}) {
  let data = {
    labels: labels,
    datasets: [{
      backgroundColor: [
      . . . . . . . .  
      ],
      borderColor: [
      . . . . . . . .  
      ],
      borderWidth:1,
      data: dataset,
    }]
  };</pre><p>在前面的代码中，<code>Chart</code>组件接受以下道具:<code>labels</code>、<code>dataset</code>和<code>type</code>。<code>labels</code>表示列名，<code>dataset</code>表示<code>dataComp</code>值，<code>type</code>表示我们要绘制的图表类型。</p><p>在<code>Chart</code>组件中，我们<a id="_idIndexMarker827"/>创建一个名为<code>data</code>的变量，这是一个按照<code>react-chartjs-2</code>绘制我们想要的图表所需的方式格式化的对象。</p></li>
				<li>We create a set of conditional rendering here, as we want to render a specific type of chart, based on the <code>prop</code> type passed into the <code>Chart</code> component:<pre>if(type==="BarChart"){
    return(
      &lt;Draggable&gt;
        &lt;div className="max-w-md"&gt;
         &lt;BarChart data={data} options={options} width="100" height="100" /&gt;
      &lt;/div&gt;
      &lt;/Draggable&gt; 
    )
  }
. . . . . . .</pre><p>我们检查要呈现的图表类型。如果是条形图，我们从<code>react-chartjs-2</code>调用<code>BarChart</code>组件，并传入必要的道具。<code>BarChart</code>组件被包装在<code>Draggable</code>组件中，以使<code>chart</code>组件被<a id="_idIndexMarker828"/>呈现为可拖动。上述代码适用于渲染所有其他<code>Chart</code>组件，如<code>react-chartjs-2</code>中的<code>LineChart</code>和<code>PieChart</code>。</p></li>
			</ol>
			<p>要深入研究<code>react-chartjs-2</code>，你可以查看这里的文档:<a href="https://github.com/reactchartjs/react-chartjs-2">https://github.com/reactchartjs/react-chartjs-2</a>。</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor162"/>实现图表平面组件</h2>
			<p>我们已经创建了<code>chart</code>组件，现在让我们创建图表<code>Side Plane</code>。在<code>components/</code>文件夹中，让我们创建一个名为<code>ChartPlane.js</code>的<a id="_idIndexMarker829"/>文件，步骤如下:</p>
			<ol>
				<li value="1">We create a <code>ChartPlane</code> component:<pre>export default function ChartPlane({setChartComp, dataComp, chartType}) {
  const df = dataComp.df
  const compCols = dataComp.columns
  let x;
  let y;
  if( compCols[0] === "index") {
    x = compCols
    y = dataComp.values[0].map((val, index)=&gt; {
        if(typeof val != "string") {
          return compCols[index]
        }
    })
  } else {
    x = df.columns
    const dtypes = df.dtypes
    y = dtypes.map((val, i)=&gt;{
        if(val != "string") {
          return x[i]
        }
    })
  }</pre><p>在前面的代码中，我们创建了一个接受以下属性的<code>ChartPlane</code>组件:</p><p>a) <code>SetChartComp</code>:更新<code>chartComp</code>状态的函数<a id="_idIndexMarker830"/></p><p>b) <code>dataComp</code>:生成图表的当前<code>DataTable</code>组件</p><p>c) <code>chartType</code>:我们想要生成的图表类型</p><p>首先，在组件中，我们获得可能的<em class="italic"> x </em>轴变量列表，并将它们存储在<code>x</code>变量中。这些<em class="italic">x</em>-轴变量可以是带有<code>String</code>的列名，也可以是数字<code>dtypes</code>。</p><p>因为我们是相对于<em class="italic"> x </em>轴绘制<em class="italic"> y </em>轴，所以我们的<em class="italic"> y </em>轴(变量<code>y</code>)必须是一个整数。因此，我们检查<code>DataFrame</code>的列不是字符串，如果不是，我们将该列添加到<em class="italic"> y </em>轴变量列表中。</p><p class="callout-heading">注意</p><p class="callout">这是灵活的。有时可以翻转图表，使 y 轴实际上是标签，x 轴包含数据。</p></li>
				<li>We create the UI for the <code>ChartPlane</code> component. Depending on how we've designed the UI for other components, the <code>x</code> and <code>y</code> variables are used to create an input field with which the <a id="_idIndexMarker831"/>user can select the <em class="italic">x</em>-axis label and the <em class="italic">y</em>-axis label:<pre>&lt;select ref={xRef} className="border"&gt;
  {
     x.map((val, index)=&gt; {
      return &lt;option value={val} key={index} &gt;{val}&lt;/option&gt;
     })
   }
&lt;/select&gt;
&lt;select ref={yRef} className="border"&gt;
  {
    y.map((val, index) =&gt; {
      return &lt;option value={val} key={index}&gt;{val}&lt;/option&gt;
    })
  }
 &lt;/select&gt;</pre><p>这个 UI 还包含一个按钮，该按钮触发一个名为<code>handleChart</code>的函数，该函数更新<code>chart</code>组件:</p><pre>&lt;button onClick={()=&gt;handleChart()} className="bg-blue-500 p-2 text-white rounded-sm"&gt;generate Chart&lt;/button&gt;</pre></li>
				<li>We create a function called <code>handleChart</code>, which obtains the value of the <em class="italic">x</em>-axis and <em class="italic">y</em>-axis input<a id="_idIndexMarker832"/> fields and uses them to create the respective charts as requested:<pre>const handleChart = () =&gt; {
  const xVal = xRef.current.value
  const yVal = yRef.current.value
  const labels = xVal === "index" ? df.index : df[xVal].values
  const data = yVal === "index" ? df.index : df[yVal].values
    setChartComp((prev) =&gt; {
      const newChart = prev.slice()
      const key = newChart.length + 1
      const dict = {
        labels: labels,
        data: data,
        key: "chart" + key,
        type: chartType
      }
      newChart.push(dict)
      return newChart
    })
  }</pre><p><code>xVal</code>和<code>yVal</code>是<em class="italic"> x </em>轴和<em class="italic"> y </em>轴的输入域值。创建<code>labels</code>和<code>data</code>变量<a id="_idIndexMarker833"/>，以包含<code>xVal</code>和<code>yVal</code>中相应列的值。标签和数据随后用于更新<code>chartComp</code>状态。</p></li>
			</ol>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>实现 ChartViz 组件</h2>
			<p>前面的步骤用于创建<a id="_idIndexMarker834"/>图表<code>Side Plane</code>，但是现在，我们看不到更新的<code>chartComp</code>组件。要查看图表，让我们创建一个组件来管理所有要显示的图表组件。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里有<code>ChartViz</code>要实现的代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/ChartsViz.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/charts viz . js</a>。</p>
			<p>让我们在<code>components/</code>文件夹中创建一个名为<code>ChartViz.js</code>的文件。将以下代码添加到文件中:</p>
			<pre>import React from 'react'
import Chart from './Chart'
 
export default function ChartsViz({chartComp,setChartComp}) {
  return (
    &lt;div&gt;
      {
        chartComp.map((chart)=&gt; {
          return(
            &lt;&gt;
            &lt;Chart 
              labels={chart.labels}
              dataset={chart.data}
              type={chart.type}
          /&gt;
          &lt;/&gt;
          )
        })
      }
    &lt;/div&gt;
  )
}</pre>
			<p>在前面的代码中，我们<a id="_idIndexMarker835"/>导入我们的<code>chart </code>组件，然后创建一个包含以下<code>chartComp</code>和<code>setChartComp</code>道具的<code>ChartViz</code>组件。我们遍历<code>chartComp</code>状态，并将每个状态值作为道具传递给<code>chart</code>组件。</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>将 ChartViz 和 ChartPlane 集成到 App.js 中</h2>
			<p>现在我们完成了<a id="_idIndexMarker836"/>组件的所有必要部分。让我们根据以下步骤更新我们的<code>App.js</code>组件来激活<code>chart</code>组件:</p>
			<ol>
				<li value="1">我们将<code>ChartViz</code>和<code>ChartPlane</code>导入到<code>App.js</code> : <pre>import ChartsViz from './components/ChartsViz' import ChartPlane from './components/ChartPlane'</pre></li>
				<li>We need to create some state to manage the type of chart we want, and the <code>chart</code> component:<pre>const [chartType, setChartType] = useState()
const [chartComp, setChartComp] = useState([])
const charts = ["BarChart", "LineChart", "PieChart"]</pre><p>在前面的代码中，我们还创建了一个数组变量来存储我们希望在我们的<code>Navbar</code>中显示<a id="_idIndexMarker838"/>的图表列表。</p></li>
				<li>We create a function to<a id="_idIndexMarker839"/> update the <code>chartType</code> component and the <code>Side Plane</code> component whenever a chart is created:<pre>const handleChart = (e) =&gt; { // step 4
    const value = e.target.innerHTML
    setChartType(value)
    setSidePlane("chart")
  }</pre><p>在<code>handleChart</code>函数中，我们获得目标值，即用户选择的图表类型。该值用于更新<code>chartType</code>组件，并且我们通过用<code>chart</code>字符串更新<code>showSidePlane</code>状态来通知<code>Side Plane</code>显示图表<code>Side Plane</code>。</p></li>
				<li>We loop the <code>charts</code> variable in the <code>nav</code> field and display them as buttons:<pre> . . . . . .
{ 
  charts.map((chart, i) =&gt; {
    return &lt;button disabled={dataComp.length &gt; 0 ? false : true}
    className={classes}
    onClick={handleChart}
   &gt;
      {chart}
   &lt;/button&gt;
 })
}
. . . . . . </pre><p>在前面的代码中，我们<a id="_idIndexMarker840"/>循环遍历<code>charts</code>数组，并为数组中的每个值创建一个按钮。我们<a id="_idIndexMarker841"/>通过检查<code>dataComp</code>状态不为空，即是否没有文件上传，禁用了该按钮。</p></li>
				<li>We call the <code>ChartViz</code> component and pass in the necessary props:<pre>{(chartComp.length &gt; 0) &amp;&amp;
    &lt;ChartsViz
     chartComp={chartComp}
     setChartComp={setChartComp}
    /&gt;
}</pre><p>我们检查<code>chartComp</code>状态是否不为空。如果不是，我们调用<code>ChartViz</code>组件，然后显示创建的图表。</p></li>
				<li>然后我们添加<code>ChartPlane</code>组件:<pre>&lt;div className="border-2 w-1/3"&gt;     &lt;ChartPlane        dataComp={dataComp[compIndex]}        setChartComp={setChartComp}        chartType={chartType}     /&gt; &lt;/div&gt;</pre></li>
			</ol>
			<p>如果<code>showSide Plane</code>图是数值图，则<code>Side</code> <code>Plane</code>中显示<code>ChartPlane</code>组件。</p>
			<p>下面的截图显示了图表更新<a id="_idIndexMarker842"/>，在<a id="_idIndexMarker843"/>可用的<code>Data Table</code>上绘制条形图、折线图和饼图:</p>
			<div><div><img src="img/B17076_8_18.jpg" alt="Figure 8.18 – Chart component displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 8.18-显示的图表组件</p>
			<p>在本节中，我们<a id="_idIndexMarker844"/>实现了<code>ChartComponent</code>和<code>ChartPlane</code>。我们利用<code>React-chart-js</code>来简化每个图表<a id="_idIndexMarker845"/>组件的开发。</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor165"/>总结</h1>
			<p>在这一章中，我们看到了如何创建一个无代码环境，在这里你可以上传你的数据，然后立即开始处理和分析数据。我们还看到了如何将 Danfo.js 中的每个<code>DataFrame</code>方法转换成 React 组件。这提供了将所有 Danfo.js 方法转换成 React 组件的能力，因此为 Danfo.js 创建了 React 组件库。</p>
			<p>此外，我们还看到了如何为应用程序设计流程，以及如何在 React 中管理状态。即使创建的一些状态是多余的，这也是您贡献和更新应用程序以使其健壮的机会。如果您可以更新应用程序，使删除、更新和保存正在进行的每个操作成为可能，这将使应用程序变得健壮，甚至可以投入生产。</p>
			<p>下一章，我们将介绍机器学习。本章将以尽可能简单的形式涵盖机器学习背后的基本思想。</p>
		</div>
	

</body></html>