<html><head/><body>


	
		<title>B17076_10_ePub_RK</title>
		
	
	
		<div><h1 id="_idParaDest-177"><em class="italic"> <a id="_idTextAnchor180"/>第十章</em>:tensor flow . js 简介</h1>
			<p>在上一章中，您已经了解了<strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)的基础知识，并且学习了一些构建和使用 ML 模型所需的理论基础。</p>
			<p>在本章中，我们将向您介绍一个高效且受欢迎的 JavaScript 库 TensorFlow.js。在本章结束时，您将了解如何安装和使用 TensorFlow.js，如何创建张量，如何使用核心<strong class="bold">应用程序编程接口</strong> ( <strong class="bold"> API </strong>)对张量进行操作，以及如何使用 TensorFlow.js 的层 API 构建回归模型。</p>
			<p>在本章中，我们将讨论以下主题:</p>
			<ul>
				<li>TensorFlow.js 是什么？</li>
				<li>安装和使用 TensorFlow.js</li>
				<li>张量和张量上的基本运算</li>
				<li>使用 TensorFlow.js 构建简单的回归模型</li>
			</ul>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor181"/>技术要求</h1>
			<p>要学习本章内容，您应该拥有以下工具或资源:</p>
			<ul>
				<li>Chrome、Safari、Opera 或 Firefox 等现代浏览器。</li>
				<li>系统上安装的 Node.js</li>
				<li>用于下载包和数据集的稳定互联网连接</li>
				<li>本章的代码可以从 GitHub 获得，可以从 https://GitHub . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/tree/main/chapter 10</li>
			</ul>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor182"/>tensor flow . js 是什么？</h1>
			<p><strong class="bold">TensorFlow . js</strong>(<strong class="bold">tfjs</strong>)是一个<a id="_idIndexMarker893"/> JavaScript 库，用于在浏览器或 Node.js 中创建、训练和部署 ML 模型。它由 Nikhil Thorat 和 Daniel Smilkov 在谷歌创建，最初称为 Deeplearn.js，在 2018 年并入 tensor flow 团队并更名为 TensorFlow.js</p>
			<p>TensorFlow.js 提供了<a id="_idIndexMarker894"/>两个主要层，概述如下:</p>
			<ul>
				<li><strong class="bold"> CoreAPI </strong>:这是直接处理 tensors 的底层 API——tensor flow . js 的核心数据结构。</li>
				<li>LayerAPI:构建在 CoreAPI 层之上的高级层，用于轻松构建 ML 模型。</li>
			</ul>
			<p>在后面的章节中，<em class="italic">张量和对张量的基本操作</em>和<em class="italic">使用 TensorFlow.js 构建简单的回归模型</em>，您将了解更多关于 CoreAPI 和 LayerAPI 层的详细信息。</p>
			<p>使用 TensorFlow.js，您可以执行以下操作:</p>
			<ul>
				<li>执行硬件加速的数学运算</li>
				<li>为浏览器或 Node.js 开发 ML 模型</li>
				<li>使用<strong class="bold">转移学习</strong> ( <strong class="bold"> TL </strong>)重新培训现有的 ML <a id="_idIndexMarker895"/>型号</li>
				<li>重用用 Python 训练的现有 ML 模型</li>
			</ul>
			<p>在本章中，我们将介绍使用 TensorFlow.js 执行硬件加速的数学运算和开发 ML 模型。如果您想了解最后两种用例——重新训练和重用 ML 模型——那么 TensorFlow.js 官方文档(<a href="https://www.tensorflow.org/js/guide">https://www.tensorflow.org/js/guide</a>)是一个很好的起点。</p>
			<p>现在我们已经介绍完了，在下一节中，我们将向您展示如何在浏览器和 Node.js 环境中安装和使用 TensorFlow.js。</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor183"/>安装和使用 TensorFlow.js</h1>
			<p>正如我们<a id="_idIndexMarker897"/>之前提到的<a id="_idIndexMarker898"/>，TensorFlow.js 可以在浏览器和 Node.js 环境下安装和运行。在下面的段落中，我们将向您展示如何实现这一点，从浏览器开始。</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor184"/>在浏览器中设置 TensorFlow.js</h2>
			<p>有两种安装 TensorFlow <a id="_idIndexMarker900"/>的方法。浏览器中的 js。这些概述如下:</p>
			<ul>
				<li>通过脚本标签</li>
				<li>使用<a id="_idIndexMarker901"/>包<a id="_idIndexMarker902"/>管理器，如<strong class="bold">节点包管理器</strong> ( <strong class="bold"> npm </strong>)或<strong class="bold">纱线</strong></li>
			</ul>
			<h3>通过脚本标签安装</h3>
			<p>通过<code>script</code>标签安装<a id="_idIndexMarker903"/> TensorFlow.js 很容易。只需<a id="_idIndexMarker904"/>将<code>script</code>标签放在你的<strong class="bold">超文本标记语言</strong> ( <strong class="bold"> HTML </strong>)文件的头文件中，如下面的代码片段所示:</p>
			<pre>&lt;script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.6.0/dist/tf.min.js"&gt;&lt;/script&gt;</pre>
			<p>要确认 TensorFlow.js 已安装，请在浏览器中打开 HTML 文件，并检查网络选项卡。您应该会看到名称<code>tf.min.js</code>和状态代码<code>200</code>，如下图所示:</p>
			<div><div><img src="img/B17076_10_01.jpg" alt="Figure 10.1 – Network tab showing the successful installation of tfjs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.1–显示 tfjs 成功安装的网络选项卡</p>
			<p>您可以在 HTML 文件的主体中添加一个简单的脚本来确认<code>tfjs</code>的成功安装。在 HTML 文件的<code>script</code>部分，添加以下代码:</p>
			<pre>...
&lt;script&gt;
         tf.ready().then(()=&gt;{
            console.log("Tensorflow.js loaded successfully!");
        })
 &lt;/script&gt;
...</pre>
			<p>一旦 TensorFlow.js 在页面上加载并准备就绪，前面的代码片段就将文本<code>Tensorflow.js loaded</code> <code>successfully!</code>记录到浏览器控制台。要查看输出，请在浏览器中打开 HTML 文件并检查控制台输出。你<a id="_idIndexMarker905"/>应该会看到一个输出结果，如下截图所示:</p>
			<div><div><img src="img/B17076_10_02.jpg" alt="Figure 10.2 – Tensor output from add operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.2–加法运算的张量输出</p>
			<p>接下来，让我们看看如何通过包管理器安装<code>tfjs</code>。</p>
			<h3>通过软件包管理器安装</h3>
			<p>你可以通过<code>npm</code>或<code>yarn</code>等包管理器<a id="_idIndexMarker906"/>安装<code>tfjs</code>。当您需要在客户端项目(如 React 和 Vue 项目)中使用<code>tfjs</code>时，这很有用。</p>
			<p>要安装<code>npm</code>，在您的<strong class="bold">命令行界面</strong> ( <strong class="bold"> CLI </strong>)中运行<a id="_idIndexMarker907"/>以下命令:</p>
			<pre>npm install @tensorflow/tfjs</pre>
			<p>要安装<code>yarn</code>，只需在 CLI 中运行以下命令:</p>
			<pre>yarn add @tensorflow/tfjs</pre>
			<p class="callout-heading">注意</p>
			<p class="callout">在您可以通过 CLI 使用<code>npm</code>或<code>yarn</code>成功安装软件包之前，您必须在您的系统中安装它们中的任何一个——最好是全局安装。如果你已经安装了 Node.js，那么你已经有了<code>npm</code>。要安装<code>yarn</code>，可以按照这里的步骤:<a href="https://classic.yarnpkg.com/en/docs/install/#mac-stable">https://classic.yarnpkg.com/en/docs/install/#mac-stable</a>。</p>
			<p>成功安装<a id="_idIndexMarker908"/>后，您可以导入并使用<code>tfjs</code>，如以下代码片段所示:</p>
			<pre>import * as tf from '@tensorflow/tfjs';
const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
const y = tf.tensor2d([1, 3, 5, 7], [2, 2]);
const sum = x.add(y)
 sum.print()</pre>
			<p>运行上述代码片段将在控制台中产生以下输出:</p>
			<div><div><img src="img/B17076_10_03.jpg" alt="Figure 10.3 – Output from testing tfjs installed with package managers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.3–测试与包管理器一起安装的 tfj 的输出</p>
			<p>通过遵循前面代码块中的步骤，您应该能够在浏览器或客户端框架中安装和使用<code>tfjs</code>。在下一节中，我们将向您展示如何在 Node.js 环境中安装<code>tfjs</code>。</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor185"/>在 Node.js 中安装 TensorFlow.js</h2>
			<p>在节点中安装<code>tfjs</code>。<a id="_idIndexMarker909"/> js 非常简单，但是首先，确保<a id="_idIndexMarker910"/>您的系统上安装了 Node.js、<code>npm</code>或<code>yarn</code>。</p>
			<p>Node.js 中的 TensorFlow.js 有三个选项，安装的选择将取决于您的系统规格。在下面的小节中，我们将向您展示这三个选项。</p>
			<h3>使用本机 C++绑定安装 TensorFlow.js</h3>
			<p><code>tfjs</code>的<code>@tensorflow/tfjs-node</code>(<a href="mailto:https://www.npmjs.com/package/%40tensorflow/tfjs-node?subject=">https://www.npmjs.com/package/@tensorflow/tfjs-node</a>)版本直接连接到<a id="_idIndexMarker911"/> TensorFlow 的原生 C++绑定。这使得它的速度很快，并使它的性能接近 Python 版本的 TensorFlow。这意味着<code>tfjs-node</code>和<code>tf.keras</code>使用相同的 C++绑定。</p>
			<p>要安装<code>tfjs-node</code>，只需通过 CLI 运行以下命令:</p>
			<pre>npm install @tensorflow/tfjs-node</pre>
			<p>或者，如果使用<code>yarn</code>，通过 CLI 运行以下命令:</p>
			<pre>yarn add @tensorflow/tfjs-node</pre>
			<h3>使用 GPU 支持安装 TensorFlow.js</h3>
			<p><code>tfjs</code>的<code>@tensorflow/tfjs-node-gpu</code>版本支持在<code>tfjs-node-gpu</code>上运行操作<a id="_idIndexMarker912"/>通常比<code>tfjs-node</code>更快，因为操作可以很容易地矢量化。</p>
			<p>要安装<code>tfjs-node-gpu</code>，只需通过 CLI 运行以下命令:</p>
			<pre>npm install @tensorflow/tfjs-node-gpu</pre>
			<p>或者，如果您使用的是<code>yarn</code>，通过 CLI 运行以下命令:</p>
			<pre>yarn add @tensorflow/tfjs-node-gpu</pre>
			<h3>安装 plain TensorFlow.js</h3>
			<p><code>@tensorflow/tfjs</code>版本是<code>tfjs</code>的纯 JavaScript 版本。就性能而言，它是最慢的<a id="_idIndexMarker915"/>，应该很少使用。</p>
			<p>要安装此版本，只需通过 CLI 运行以下命令:</p>
			<pre>npm install @tensorflow/tfjs</pre>
			<p>或者，如果您使用的是<code>yarn</code>，通过 CLI 运行以下命令:</p>
			<pre>yarn add @tensorflow/tfjs</pre>
			<p>如果您遵循了前面的步骤，那么您应该至少安装了<code>tfjs</code>的一个版本。您可以使用下面的代码示例测试安装是否成功:</p>
			<pre>const tf = require('@tensorflow/tfjs-node')
// const tf = require('@tensorflow/tfjs-node-gpu') GPU version
// const tf = require('@tensorflow/tfjs') Pure JS version
const xs = tf.randomNormal([100, 10])
const ys = tf.randomNormal([100, 1])
const sum = xs.add(ys)
const xsSum = xs.sum()
const xsMean = xs.mean()
 
console.log("Sum of xs and ys")
sum.print()
console.log("Sum of xs")
xsSum.print()
console.log("Mean of xs")
xsMean.print()</pre>
			<p class="callout-heading">注意</p>
			<p class="callout">当我们想要查看底层数据时，我们调用张量上的<code>print()</code>函数。如果我们使用默认的<code>console.log</code>，我们得到的是<code>Tensor</code>对象。</p>
			<p>运行上述代码应该会在控制台中输出以下内容:</p>
			<div><div><img src="img/B17076_10_04.jpg" alt="Figure 10.4 – Output from testing tfjs installed in Node.js&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.4–测试安装在 Node.js 中的 tfjs 的输出</p>
			<p>现在你<a id="_idIndexMarker917"/>已经将<a id="_idIndexMarker918"/>成功安装到你的项目中，在下一节，我们将向你介绍<code>tfjs</code>的核心数据结构——张量。</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor186"/>张量和张量上的基本运算</h1>
			<p>张量<a id="_idIndexMarker919"/>是<code>tfjs</code>中基本的<a id="_idIndexMarker920"/>数据结构。你可以把张量想象成向量、矩阵或者高维数组的推广。<strong class="bold"> CoreAPI </strong>，也就是我们在<em class="italic">中介绍的<a id="_idIndexMarker921"/>什么是 TensorFlow.js？</em>部分，展示了创建和使用张量的不同功能。</p>
			<p>下面的屏幕截图显示了标量、向量和带张量的矩阵之间的简单比较:</p>
			<div><div><img src="img/B17076_10_05.jpg" alt="Figure 10.5 – Comparison between simple n-dimensional arrays and a tensor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.5–简单 n 维数组和张量之间的比较</p>
			<p class="callout-heading">小费</p>
			<p class="callout">一个矩阵是由<code>m x n</code>个数字组成的<a id="_idIndexMarker922"/>一个<a id="_idIndexMarker923"/>网格，其中<code>m</code>代表行数<code>n</code>代表列数。矩阵可以是一维的，也可以是多维的，相同形状的矩阵支持直接的数学运算。</p>
			<p class="callout">另一方面，向量是一维矩阵，形状为(1，1)；也就是说，它只有一行和一列，例如，[2，3]，[3，1，4]。</p>
			<p>我们之前提到张量更像是一个广义矩阵，也就是说，它扩展了矩阵的概念。张量可以用它们的秩来描述。等级类似于形状的概念，但是由与形状相对的单个数字来表示。在下面的列表中，我们看到了不同类型的张量秩及其示例:</p>
			<ul>
				<li>秩为 0 的张量是标量，例如 1、20 或 100。</li>
				<li>秩为 1 的张量是一个向量，例如，[1，20]或[20，100，23.6]。</li>
				<li>秩为 2 的张量是矩阵——例如[[1，3，6]，[2.3，5，7]]。</li>
			</ul>
			<p>请注意，我们可以有秩为 4 或更多的张量，这些被称为更高维的张量，可能很难可视化。为了更好地理解张量，请参见下面的截图:</p>
			<div><div><img src="img/B17076_10_06.jpg" alt="Figure 10.6 – Comparison of tensors with different ranks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.6–不同等级张量的比较</p>
			<p>除了<a id="_idIndexMarker924"/>等级，张量<a id="_idIndexMarker925"/>还有其他属性如<code>dtype</code>、<code>data</code>、<code>axis</code>、<code>shape</code>。这些在这里有更详细的描述:</p>
			<ul>
				<li><code>dtype</code>属性(数据类型)是张量持有的数据类型——例如，具有以下数据[2.5，3.8]的秩 1 张量的数据类型为<code>float32</code>。默认情况下，数值张量的 dtype 为<code>float32</code>，但这可以在创建过程中更改。TensorFlow.js 支持<code>float32</code>、<code>int32</code>、<code>bool</code>、<code>complex64</code>和<code>string</code>数据类型。</li>
				<li><code>data</code>属性是张量的内容。这通常存储为数组。</li>
				<li><code>axis</code>属性是张量的特定维度——例如，<em class="italic"> m x n </em>张量的轴为<em class="italic"> m </em>或<em class="italic"> n </em>。轴可用于指定在哪个维度上执行操作。</li>
				<li><code>shape</code>属性是张量的维数。把形状想象成张量每个轴上的元素数量。</li>
			</ul>
			<p>现在你对张量有了一个基本的了解，在下一小节，我们将向你展示如何<a id="_idIndexMarker926"/>创建<a id="_idIndexMarker927"/>张量并对它们执行一些基本的操作。</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor187"/>创建张量</h2>
			<p>张量可以用<code>tf.tensor()</code>方法创建<a id="_idIndexMarker928"/>，如下面的代码片段所示:</p>
			<pre>const tf = require('@tensorflow/tfjs-node')
 
const tvector = tf.tensor([1, 2, 3, 4]);
console.log(tvector)
//output
Tensor {
  kept: false,
  isDisposedInternal: false,
  shape: [ 4 ],
  dtype: 'float32',
  size: 4,
  strides: [],
  dataId: {},
  id: 0,
  rankType: '1'
}</pre>
			<p>在前面的代码片段中，我们将一个平面数组(向量)传递给<code>tf.tensor()</code>方法来创建一个<code>tfjs</code>张量。创建这个之后，我们现在可以使用不同的属性和函数来操纵或转换张量。</p>
			<p>一个这样的属性是<code>shape</code>属性，我们可以调用它，如下面的代码片段所示:</p>
			<pre>console.log('shape:', tvector.shape);
//outputs: shape: [ 4 ]</pre>
			<p>注意，当你用<code>console.log</code>记录张量时，你会得到一个张量对象。如果需要查看底层张量数组，可以对张量调用<code>print()</code>函数，如下面的代码片段中的<a id="_idIndexMarker929"/>所示:</p>
			<pre>tvector.print();
//outputs
Tensor
    [1, 2, 3, 4]</pre>
			<p>如果需要访问一个张量的底层数据，可以调用<code>array()</code>或者<code>arraySync()</code>方法。两者的区别在于<code>array()</code>异步运行并返回解析到底层数组的承诺，而<code>arraySync()</code>同步运行。你可以在这里看到一个例子:</p>
			<pre>const tvectorArray = tvector.array()
const tvectorArraySync = tvector.arraySync()
console.log(tvectorArray)
console.log(tvectorArraySync)
//outputs
Promise { &lt;pending&gt; }
[ 1, 2, 3, 4 ]</pre>
			<p>您也可以通过指定一个<code>shape</code>参数来创建张量。例如，在下面的代码片段中，我们<a id="_idIndexMarker930"/>从一个平面数组中创建一个 2 x 2 ( <strong class="bold">二维</strong> ( <strong class="bold"> 2D </strong>))张量:</p>
			<pre>const ts = tf.tensor([1, 2, 3, 4], [2, 2]);
console.log('shape:', ts.shape);
ts.print();
//outputs
shape: [ 2, 2 ]
Tensor
    [[1, 2],
     [3, 4]]</pre>
			<p>或者，我们可以<a id="_idIndexMarker931"/>创建<a id="_idIndexMarker932"/>一个 1 x 4 ( <strong class="bold">一维</strong> ( <strong class="bold"> 1D </strong>))张量，如下面的代码片段所示:</p>
			<pre>const ts = tf.tensor([1, 2, 3, 4], [1, 4]);
console.log('shape:', ts.shape);
ts.print();
//outputs
shape: [ 1, 4 ]
Tensor
     [[1, 2, 3, 4],]</pre>
			<p>但是，请注意，形状必须与元素的数量相匹配——例如，您不能从一个包含四个元素的平面数组中创建一个<code>2 x 5</code>维张量。以下代码将引发形状错误:</p>
			<pre>const ts = tf.tensor([1, 2, 3, 4], [2, 5]);</pre>
			<p>输出如下所示:</p>
			<div><div><img src="img/B17076_10_07.jpg" alt="Figure 10.7 – Error thrown from shape mismatch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.7-形状不匹配引发的错误</p>
			<p><code>Tfjs</code> <a id="_idIndexMarker933"/>明确<a id="_idIndexMarker934"/>提供<a id="_idIndexMarker935"/>功能<a id="_idIndexMarker936"/>用于创建 1D，<code>shape</code>参数。你可以从官方<code>tfjs</code> API 这里阅读更多关于创建张量的内容:<a href="https://js.tensorflow.org/api/latest/#Tensors-Creation">https://js.tensorflow.org/api/latest/#Tensors-Creation</a>。</p>
			<p>默认情况下，张量有一个<code>float32</code>的<code>dtype</code>属性，所以你创建的任何一个张量<a id="_idIndexMarker937"/>都有一个<code>float32</code>的<code>dtype</code>。如果这不是所需的<code>dtype</code>，您可以指定张量创建的类型，如我们在以下代码片段中演示的:</p>
			<pre>const tsInt = tf.tensor([1, 2, 3, 4], [1, 4], 'int32');
console.log('dtype:', tsInt.dtype);
//outputs
dtype: int32</pre>
			<p>现在你知道如何创建一个张量，我们将继续操作张量。</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor188"/>对张量进行运算</h2>
			<p>正如我们<a id="_idIndexMarker938"/>之前所说，张量将数据存储在网格中，并允许对这些数据进行大量的操作或转换。<code>tfjs</code>为线性代数和 ML 提供了许多运算符。</p>
			<p><code>tfjs</code>中的操作被分成不同的部分。以下是一些常见操作的说明:</p>
			<ul>
				<li><code>add()</code>用于张量的加法，<code>sub()</code>用于张量的减法，<code>mul()</code>用于张量的乘法，<code>div()</code>用于张量的除法。请看完整的列表<a id="_idIndexMarker940"/>和这里的例子:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic">https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic</a>。</li>
				<li><code>cos()</code>用于计算张量的余弦，<code>sin()</code>用于计算张量的正弦，<code>exp()</code>用于计算张量的指数，<code>log()</code>用于计算张量的自然对数。请看<a id="_idIndexMarker941"/>完整的<a id="_idIndexMarker942"/>列表和这里的例子:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math">https://js . tensor flow . org/API/3 . 7 . 0/# Operations-Basic % 20 math</a>。</li>
				<li><strong class="bold">矩阵</strong>:这些运算符用于矩阵运算，如点积、范数或转置。你可以在这里看到支持的运营商的完整列表:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Matrices">https://js.tensorflow.org/api/3.7.0/#Operations-Matrices</a>。</li>
				<li><code>conv1d</code>计算输入<code>x</code>的 1D 卷积，<code>maxpool3D</code>计算 3D max-pooling 运算。在这里看完整的名单:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Convolution">https://js.tensorflow.org/api/3.7.0/#Operations-Convolution</a>。</li>
				<li><code>min</code>、<code>max</code>、<code>sum</code>、<code>mean</code>、<code>argMax</code>、<code>argMin</code>。你可以在这里看到例子<a id="_idIndexMarker945"/>的完整列表:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Reduction">https://js.tensorflow.org/api/3.7.0/#Operations-Reduction</a>。</li>
				<li><code>equal</code>、<code>greater</code>、<code>greaterEqual</code>和<code>less</code>。你可以在这里看到<a id="_idIndexMarker946"/>例子的完整列表:<a href="https://js.tensorflow.org/api/3.7.0/#Operations-Logical">https://js.tensorflow.org/api/3.7.0/#Operations-Logical</a>。</li>
			</ul>
			<p>你可以在这里看到官方 API 支持操作的完整列表:<a href="https://js.tensorflow.org/api/3.7.0/#Operations">https://js.tensorflow.org/api/3.7.0/#Operations</a>。</p>
			<p>现在你对可用的张量算符有了基本的了解，我们将展示一些代码<a id="_idIndexMarker947"/>例子。</p>
			<h3>对张量应用算术运算</h3>
			<p>我们可以通过对第一个张量直接调用<a id="_idIndexMarker949"/>的<code>add()</code>方法并将第二个张量作为参数传递来<a id="_idIndexMarker948"/>添加两个张量，如下面的代码片段所示:</p>
			<pre>const tf = require('@tensorflow/tfjs-node')
const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40]);
a.add(b).print();
//outputs
Tensor
    [11, 22, 33, 44]</pre>
			<p>请注意，您也可以通过调用<code>tf</code>对象上的操作符来直接添加或应用任何操作符，如以下代码片段所示:</p>
			<pre>const tf = require('@tensorflow/tfjs-node')
const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40]);
const sum = tf.add(a, b)
sum.print()
//outputs
Tensor
    [11, 22, 33, 44]</pre>
			<p>使用这些知识，您可以执行其他算术运算，如减法、乘法、除法和<a id="_idIndexMarker950"/>幂运算，正如我们在下面的代码片段中所演示的那样:</p>
			<pre>const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40]);
 
const tfsum = tf.add(a, b)
const tfsub = tf.sub(b, a)
const tfdiv = tf.div(b, a)
const tfpow = tf.pow(b, a)
const tfmax = tf.maximum(a, b)
 
tfsum.print()
tfsub.print()
tfdiv.print()
tfpow.print()
tfmax.print()
//outputs
Tensor
    [11, 22, 33, 44]
Tensor
    [9, 18, 27, 36]
Tensor
    [10, 10, 10, 10]
Tensor
    [10, 400, 27000, 2560000]
Tensor
    [10, 20, 30, 40]</pre>
			<p>值得一提的是，传递给操作符的张量的顺序很重要，因为顺序的改变会导致结果不同。例如，如果我们将前面的<code>div</code>操作的顺序从<code>const tfsub = tf.sub(b, a)</code>交换到<code>const tfsub = tf.sub(a, b)</code>，那么我们会得到一个否定的结果，如下面的输出所示:</p>
			<pre>Tensor
    [-9, -18, -27, -36]</pre>
			<p>注意<a id="_idIndexMarker952"/>所有涉及两个张量的<a id="_idIndexMarker953"/>运算只有在两个张量具有相同的形状时才有效。例如，以下操作将引发无效形状错误:</p>
			<pre>const a = tf.tensor1d([1, 2, 3, 4]);
const b = tf.tensor1d([10, 20, 30, 40, 50]);
const tfsum = tf.add(a, b)</pre>
			<div><div><img src="img/B17076_10_08.jpg" alt="Figure 10.8 – Invalid shape error when performing an operation on tensors with a different shape&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.8–对不同形状的张量执行操作时的无效形状错误</p>
			<p>在下一小节中，我们看一些关于张量的基本数学运算的例子。</p>
			<h3>对张量应用基本数学运算</h3>
			<p>遵循前一小节<em class="italic">对张量</em>应用算术运算的<a id="_idIndexMarker954"/>和<a id="_idIndexMarker955"/>示例格式，我们给出一些计算张量数学运算的示例，如下所示:</p>
			<pre>const tf = require('@tensorflow/tfjs-node')
 
const x = tf.tensor1d([-1, 2, -3, 4]);
x.abs().print();  // Computes the absolute values of the tensor
x.cos().print(); // Computes the cosine of the tensor
x.exp().print(); // Computes the exponential of the tensor
x.log().print(); // Computes the natural logarithm  of the tensor
x.square().print(); // Computes the sqaure of the tensor</pre>
			<p>输出如下所示:</p>
			<pre>Tensor
    [1, 2, 3, 4]
Tensor
    [0.5403023, -0.4161468, -0.9899925, -0.6536436]
Tensor
    [0.3678795, 7.3890562, 0.0497871, 54.5981522]
Tensor
    [NaN, 0.6931472, NaN, 1.3862944]
Tensor
    [1, 4, 9, 16]</pre>
			<p>正如我们前面提到的<a id="_idIndexMarker956"/>，你可以直接从<code>tf</code>对象中调用操作符——例如，<code>x.cos()</code>变成了<code>tf.cos(x)</code>。</p>
			<h3>对张量应用归约运算</h3>
			<p>我们还可以<a id="_idIndexMarker957"/>将<code>mean</code>、<code>min</code>、<code>max</code>、<code>argMin</code>和<code>argMax</code>等归约运算<a id="_idIndexMarker958"/>应用于张量。以下是以下代码片段中<code>mean</code>、<code>min</code>、<code>max</code>、<code>argMin</code>和<code>argMax</code>的一些示例:</p>
			<pre>const x = tf.tensor1d([1, 2, 3]);
x.mean().print();  // or tf.mean(x)  Returns the mean value of the tensor
x.min().print();  // or tf.min(x) Returns the smallest value in the tensor
x.max().print();  // or tf.max(x) Returns the largest value in the tensor
x.argMax().print();  // or tf.argMax(x) Returns the index of the largest value
x.argMin().print();  // or tf.argMin(x) Returns the index of the smallest value</pre>
			<p>输出如下所示:</p>
			<pre>Tensor 2
Tensor 1
Tensor 3
Tensor 2
Tensor 0</pre>
			<p>有了 ML、张量和可以在张量上执行的运算的基础知识，现在就可以构建一个简单的 ML 模型了。在本章的下一节中，我们将巩固您在本节中学到的所有内容。</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor189"/>使用 TensorFlow.js 构建简单的回归模型</h1>
			<p>在<a id="_idIndexMarker959"/>上一章，<a href="B17076_09_ePub_RK.xhtml#_idTextAnchor166"> <em class="italic">第九章</em> </a>，<em class="italic">机器学习基础知识</em>，各位<a id="_idIndexMarker960"/>都介绍了 ML 的基础知识，尤其是回归和分类模型的理论方面。在本节中，我们将向您展示如何使用<code>tfjs</code> <strong class="bold"> LayerAPI </strong>创建和训练回归模型。具体来说，在本节结束时，您将拥有一个可以根据超市数据预测销售价格的回归模型。</p>
			<h2 id="_idParaDest-187">在本地设置您的环境</h2>
			<p>在构建回归模型之前，您必须在本地设置您的环境。在本节中，我们将在 Node.js 环境中工作。这意味着我们将使用 TensorFlow.js 和 Danfo.js 的<code>node</code>版本。</p>
			<p>按照以下步骤设置您的环境:</p>
			<ol>
				<li>在新的工作目录中，为您的项目创建一个文件夹。我们将创建一个名为<code>sales_predictor</code>的，如下面的代码片段所示:<pre><strong class="bold">mkdir sales_predictor</strong> <strong class="bold">cd sales_predictor</strong></pre></li>
				<li>接下来，在文件夹目录中打开一个终端，通过运行下面的命令初始化一个新的<code>npm</code>项目:<pre><strong class="bold">npm init</strong></pre></li>
				<li>接下来，安装<code>Danfo.js</code>节点包，如下:<pre><strong class="bold">yarn add danfojs-node</strong> <strong class="bold">or if using npm</strong> <strong class="bold">npm install danfojs-node</strong></pre></li>
				<li>同样从终端创建一个<code>src</code>文件夹，添加<code>train.js</code>、<code>model.js</code>和<code>data</code>、<code>_proc.js</code>文件。您可以从代码编辑器中手动创建这些文件夹/文件，或者在终端中运行以下命令:<pre><code>data_proc.js</code>, and <code>model.js</code>) in the <code>src</code> folder. These files will contain code for processing data, creating a <code>tfjs</code> model, and model training, respectively.</pre></li>
			</ol>
			<p>现在你已经建立了你的项目和文件，我们将进入下一部分的数据检索和处理步骤。</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor191"/>检索和处理训练数据集</h2>
			<p>我们将用于模型训练的数据集<a id="_idIndexMarker963"/>是<a id="_idIndexMarker965"/>，称为<em class="italic"> BigMart 销售数据集</em>(<a href="https://www.kaggle.com/devashish0507/big-mart-sales-prediction">https://www . ka ggle . com/deva shish 0507/big-mart-sales-prediction</a>)。它在 Kaggle 上作为公共数据集提供，ka ggle 是一个流行的数据科学竞赛平台。</p>
			<p>你可以直接从本章的代码库这里下载数据集:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js-/blob/main/chapter 10/sales _ predictor/src/dataset/train . CSV</a>。下载成功后，在项目目录中创建一个名为<code>dataset</code>的文件夹，并将数据集复制到其中。</p>
			<p>为了确认一切正常，您的项目<code>src</code>文件夹应该具有以下文件结构:</p>
			<pre>|-data-proc.js
|-dataset
|   └── Train.csv
|-model.js
|-train.js</pre>
			<p>与所有数据科学问题一样，一般问题陈述可用于指导您解决问题。就 BigMart 销售数据集而言，问题陈述如下:</p>
			<p><em class="italic"> BigMart 收集了 2013 年不同城市的 10 家商场的 1559 种产品的销售数据。此外，还定义了每个产品和商店的某些属性。目的是建立一个预测模型，并找出特定商店中每种产品的销售额。</em></p>
			<p>从<a id="_idIndexMarker966"/>前面的<a id="_idIndexMarker967"/>问题陈述中，您会注意到构建该模型的目的是帮助 BigMart 有效地预测特定商店中每种产品的销售额。现在，销售价格在这里意味着一个连续的值，因此，我们有一个回归问题。</p>
			<p>现在您已经可以访问数据并理解了问题陈述，您将使用<code>Danfo.js</code>加载数据集并执行一些数据处理和清理。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">我们在这里的代码库中提供了一个<a id="_idIndexMarker968"/>单独的<strong class="bold">Danfo Notebook</strong>(<strong class="bold">Dnotebook</strong>)文件:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json">https://github . com/packt publishing/Building-Data-Driven-Applications-with-Danfo . js-/blob/main/chapter 10/sales _ predictor/src/bigmart % 20 sales % 20 Notebook . JSON</a>。在笔记本中，我们对销售数据集进行了一些数据探索和分析，其中大部分将有助于我们的后续处理步骤。</p>
			<p>在代码编辑器中打开<code>data_proc.js</code>文件，按照这里给出的步骤处理 BigMart 销售数据集:</p>
			<ol>
				<li value="1">首先，我们将导入<code>danfojs-node</code>，如下:<pre>const dfd = require("danfojs-node")</pre></li>
				<li>然后，我们创建一个名为<code>processData</code>的函数，它接受数据集路径，如下:<pre>async function processData(trainDataPath) {     //… process code goes here }</pre></li>
				<li>接下来，在<code>processData</code>函数的<a id="_idIndexMarker969"/>和<a id="_idIndexMarker970"/>主体中，我们使用<code>read_csv</code>函数加载数据集并打印头部，如下所示:<pre>const salesDf = await dfd.read_csv(trainDataPath) salesDf.head().print()</pre></li>
				<li>为了确保数据加载工作，您可以将数据集的路径传递给<code>processData</code>函数，如下面的代码片段所示:<pre>processData("./dataset/train.csv")</pre></li>
				<li>And in your terminal, run the <code>data_proc.js</code> file using the following command:<pre><strong class="bold">node data_proc.js</strong></pre><p>这将输出以下内容:</p><div><img src="img/B17076_10_09.jpg" alt="Figure 10.9 – Displaying the head value of the BigMart sales dataset&#13;&#10;"/></div><p class="figure-caption">图 10.9-显示 BigMart 销售数据集的头部值</p></li>
				<li>根据对 Dnotebook 文件的分析，我们注意到两列<code>Item_Weight</code>和<code>Outlet_Sales</code>缺少值。在下面的代码片段中，我们将<a id="_idIndexMarker971"/>分别使用平均值和模态值来填充这些<a id="_idIndexMarker972"/>缺失值:<pre>...     salesDf.fillna({         columns: ["Item_Weight", "Outlet_Size"],         values: [salesDf['Item_Weight'].mean(), "Medium"],         inplace: true     }) ...</pre></li>
				<li>正如我们已经注意到的，数据集是分类(字符串)列和数字(<code>float32</code>和<code>int32</code>)列的混合。这意味着我们必须将所有分类列转换成数字形式，然后才能将它们传递给我们的模型。在下面的代码片段中，我们使用 Danfo.js 的<code>LabelEncoder</code>将每个分类列编码为数字列:<pre>...      let encoder = new dfd.LabelEncoder()      let catCols = salesDf.select_dtypes(includes = ['string']).column_names // get all categorical column names      catCols.forEach(col =&gt; {         encoder.fit(salesDf[col])         enc_val = encoder.transform(salesDf[col])         salesDf.addColumn({ column: col, value: enc_val })      })      ...</pre></li>
				<li>接下来，我们将从训练数据集中分离出目标。正如我们从问题陈述中注意到的，目标是销售价格。这对应于最后一列<code>Item_Outlet_Sales</code>。在下面的代码片段中，我们将使用<code>iloc</code>函数:<pre>...       let Xtrain, ytrain;       Xtrain = salesDf.iloc({ columns:         [`1:${salesDf.columns.length - 1}`] })       ytrain = salesDf['Item_Outlet_Sales']       console.log(`Training Dataset Shape: ${Xtrain.shape}`) ...</pre>分割数据集</li>
				<li>接下来，我们将标准化数据集。标准化我们的数据集迫使每一列都在标度中，因此改进了模型训练。在下面的代码片段中，我们使用 Danfo.js 的<code>StandardScaler</code>来标准化数据集:<pre>      ...   let scaler = new dfd.MinMaxScaler()       scaler.fit(Xtrain)       Xtrain = scaler.transform(Xtrain) ...</pre></li>
				<li>Finally, to complete the <code>processData</code> function, we'll return the raw tensors, as shown<a id="_idIndexMarker975"/> in<a id="_idIndexMarker976"/> the following code snippet:<pre>...
       return [Xtrain.tensor, ytrain.tensor]
...</pre><p class="callout-heading">注意</p><p class="callout">在这里可以看到代码库中的完整代码:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 10/sales _ predictor/src/Data-proc . js</a>。</p></li>
			</ol>
			<p>执行并打印最终<code>data_proc.js</code>文件中的张量应该会得到如下截图所示的张量:</p>
			<div><div><img src="img/B17076_10_10.jpg" alt="Figure 10.10 – Final BigMart data tensors after processing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.10-处理后的最终 BigMart 数据张量</p>
			<p>现在您有了一个可以处理原始数据集并返回张量的函数，让我们继续用<code>tfjs</code>创建模型。</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor192"/>使用 TensorFlow.js 创建模型</h2>
			<p>正如我们前面提到的<a id="_idIndexMarker977"/>,<code>tfjs</code>提供了一个层 API，可以用来定义和创建 ML 模型。Layers API 类似于流行的 Keras API，因此，已经熟悉 Keras 的 Python 开发人员可以很容易地将他们的代码移植到<code>tfjs</code>。</p>
			<p>Layers API 提供了两种创建模型的方法——顺序格式和模型格式。我们将在下面的小节中简要解释并给出例子。</p>
			<h3>创建模型的顺序方式</h3>
			<p>这是最简单也是最常见的创建模型的方法。它只是一个由多个模型层组成的堆栈，堆栈中的第一层定义输入，最后一层定义输出，而中间层可以是任意多个。</p>
			<p>下面的代码片段显示了一个两层顺序模型的示例:</p>
			<pre>const model = tf.sequential();
// First layer must have an input shape defined.
model.add(tf.layers.dense({units: 32, inputShape: [50]}));
model.add(tf.layers.dense({units: 24})); 
model.add(tf.layers.dense({units: 1}));</pre>
			<p>您将从前面的代码片段中注意到，序列中的第一层提供了一个<code>inputShape</code>参数。这意味着模型需要一个带有<code>50</code>列的输入。</p>
			<p>您也可以通过传递层列表来创建连续层，如以下代码片段所示:</p>
			<pre>const model = tf.sequential({
   layers: [tf.layers.dense({units: 32, inputShape: [50]}),
           tf.layers.dense({units: 24}),
           tf.layers.dense({units: 1})]
});</pre>
			<p>接下来，我们来看看模型格式。</p>
			<h3>创建模型的模型方式</h3>
			<p>创建模型的模型格式<a id="_idIndexMarker979"/>在创建模型时提供了更多的灵活性。与简单地接受一堆线性层不同，用模型层定义的模型可以是非线性的、循环的，并且可以根据您的需要进行高级或连接。</p>
			<p>例如，在下面的代码片段中，我们使用模型格式创建了一个双层网络:</p>
			<pre>const input = tf.input({ shape: [5] });
const denseLayer1 = tf.layers.dense({ units: 16, activation: 'relu' });
const denseLayer2 = tf.layers.dense({ units: 8, activation: 'relu' });
const denseLayer3 = tf.layers.dense({ units: 1 })
const output = denseLayer3.apply(denseLayer2.apply(denseLayer1.apply(input)))
const model = tf.model({ inputs: input, outputs: output });</pre>
			<p>从前面的示例代码中，您可以看到我们正在显式调用<code>apply</code>函数，并将我们想要连接的层作为参数传递。通过这种方式，我们可以构建具有图形连接的混合和高度复杂的模型。</p>
			<p>你可以从官方的<code>tfjs</code>文档中了解更多关于 Layers API 的信息:<a href="https://js.tensorflow.org/api/latest/#Models">https://js.tensorflow.org/api/latest/#Models</a>。</p>
			<p>现在您已经知道如何使用层 API 创建模型，我们将在下一节创建一个简单的三层回归模型。</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor193"/>创建简单的三层回归模型</h2>
			<p>一个回归模型，正如我们在前一章<a id="_idIndexMarker980"/><a href="B17076_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">第九章</em></a><em class="italic">机器学习基础知识</em>中所解释的，是一个有连续输出的模型。为了用<code>tfjs</code>创建回归模型，我们定义了层的堆栈，在最后一层，我们将<code>units</code>的数量设置为<code>1</code>。例如，打开代码库中的<code>model.js</code>文件。在<em class="italic">第 7-11 行</em>上，您应该看到以下顺序模型定义:</p>
			<pre>...
const model = tf.sequential();
model.add(tf.layers.dense({ inputShape: [11], units: 128, kernelInitializer: 'leCunNormal' }));
model.add(tf.layers.dense({units: 64, activation: 'relu' }));
model.add(tf.layers.dense({units: 32, activation: 'relu' }));
model.add(tf.layers.dense({units: 1}))
...</pre>
			<p>注意，在<a id="_idIndexMarker981"/>第一层，我们将<code>inputShape</code>参数设置为<code>11</code>。这是因为我们的 BigMart 数据集中有<code>11</code>训练列。你可以通过打印处理过的张量的形状来确认这一点。在最后一层，我们将<code>units</code>属性设置为<code>1</code>，因为我们想要预测一个连续的值。</p>
			<p>中间的层可以是我们想要的任何数量，单元可以是任何数量。所以，本质上，在中间增加更多的层给我们一个更深的模型，增加更多的单元给我们一个更宽的模型。所使用的层的选择不仅取决于问题，还取决于执行的多次实验和训练。</p>
			<p>仅仅通过这几行代码，您已经成功地在<code>tfjs</code>中创建了一个三层回归模型。</p>
			<p>在创建模型之后，您通常要做的下一件事是编译模型。那么，编译是做什么的？嗯，编译是为训练和评估准备模型的过程。这意味着，在编译阶段，我们必须设置模型的优化器、损失和/或训练指标。</p>
			<p>必须先编译一个<code>tfjs</code>模型，然后才能开始训练。那么，我们如何在<code>tfjs</code>编译一个模型呢？这可以通过在已定义的模型上调用<code>compile</code>函数并设置您想要计算的优化器和指标来完成。</p>
			<p>在<code>model.js</code>文件的第 13-17 行，我们通过将优化器设置为<code>Adam</code>，并将<code>loss</code>和<code>metrics</code>属性设置为<code>meanSquaredError</code>来编译我们的回归模型。请参见下面的代码片段来查看这一点:</p>
			<pre>...
    model.compile({
        optimizer: tf.train.adam(LEARNING_RATE),
        loss: tf.losses.meanSquaredError,
        metrics: ['mse']
    });
...</pre>
			<p>值得一提的是，有不同类型的优化器可供选择；在 https://js.tensorflow.org/api/latest/#Training-Optimizers 查看完整列表。选择使用哪种优化器将取决于您的经验以及多次实验。</p>
			<p>就损失而言，这个问题会告诉你使用哪个损失函数。在我们的例子中，由于这是一个回归问题，我们<a id="_idIndexMarker983"/>可以使用<strong class="bold">均方误差</strong> ( <strong class="bold"> MSE </strong>)函数。要查看可用损失函数的完整列表，请访问<a href="https://js.tensorflow.org/api/latest/#Training-Losses">https://js.tensorflow.org/api/latest/#Training-Losses</a>。</p>
			<p>最后，就模型训练期间计算和显示的指标而言，我们可以指定多个选项，正如损失一样，指定的指标将取决于您试图解决的问题。在我们的例子中，我们也可以计算一个 MSE。要查看受支持指标的完整列表，请访问<a href="https://js.tensorflow.org/api/latest/#Metrics">https://js.tensorflow.org/api/latest/#Metrics</a>。</p>
			<p>现在您已经定义并编译了模型，我们将进入本章的下一个也是最后一个部分，即训练模型。</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor194"/>用处理后的数据集训练模型</h2>
			<p><code>train.js</code>文件<a id="_idIndexMarker984"/>包含<a id="_idIndexMarker985"/>在处理过的数据集上训练三层回归模型的代码。在以下步骤中，我们将带您了解模型训练的整个过程:</p>
			<ol>
				<li value="1">首先，让我们使用<code>processData</code>函数加载和处理数据集，如下所示:<pre>… const data = await processData("./dataset/train.csv") const Xtrain = data[0] const ytrain = data[1] …</pre></li>
				<li>接下来，我们<a id="_idIndexMarker986"/>使用<code>getModel</code>函数加载<a id="_idIndexMarker987"/>模型，如下:<pre>… const model = getModel() …</pre></li>
				<li>Next, and very importantly, we call the <code>fit</code> function on the model, pass the training data, the target, and a couple of parameters such as the <code>epoch</code>, <code>batchSize</code>, and <code>validationSplits</code> parameters, and a callback function called <code>onEpochEnd</code>, as follows:<pre>…
    await model.fit(Xtrain, ytrain, {
        batchSize: 24,
        epochs: 20,
        validationSplit: 0.2,
        callbacks: {
            onEpochEnd: async (epoch, logs) =&gt; {
                const progressUpdate = `EPOCH (${epoch + 1}): Train MSE: ${Math.sqrt(logs.mse)}, Val MSE:  ${Math.sqrt(logs.val_mse)}\n`
                console.log(progressUpdate);
            }
        }
    });
...</pre><p>让我们<a id="_idIndexMarker988"/>了解一下<a id="_idIndexMarker989"/>传递给<code>fit</code>函数的参数是做什么的，如下所示:</p><ul><li><code>Xtrain</code>:训练数据。</li><li><code>ytrain</code>:目标数据。</li><li><code>epoch</code>:历元大小是迭代训练数据的次数。</li><li><code>batchSize</code>:批量大小是计算一次梯度更新时使用的数据点或样本的数量。</li><li><code>validationSplit</code>:验证分割是一个方便的参数，它告诉<code>tfjs</code>为验证保留指定百分比的数据。当我们不想手动将数据集分为训练集和测试集时，可以使用这种方法。</li><li><code>callbacks</code>:回调，顾名思义，接受在模型训练的不同生命周期中调用的函数列表。回调在监控模型训练中很重要。点击这里查看完整的试镜名单:<a href="https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset">https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset </a>。</li></ul></li>
				<li>最后，我们保存模型，以便我们可以使用它进行新的预测，如下所示:<pre>      ...       await model.save("file://./sales_pred_model")  ...</pre></li>
			</ol>
			<p>运行<code>train.js</code>文件将加载并处理数据集，加载模型，并运行指定数量的时期的模型训练。我们指定的回调(<code>onEpochEnd</code>)将在每个时期后打印出损失和根 MSE，如下面的屏幕截图所示:</p>
			<div><div><img src="img/B17076_10_11.jpg" alt="Figure 10.11 – Model training logs showing loss and root MSE&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 10.11–显示损失和均方根误差的模型训练日志</p>
			<p>就是这样！您<a id="_idIndexMarker990"/>已经成功地<a id="_idIndexMarker991"/>创建、训练并保存了一个可以使用 TensorFlow.js 预测销售价格的回归模型。在本章的下一节也是最后一节，我们将向您展示如何加载您保存的模型并使用它进行预测。</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor195"/>用训练好的模型做预测</h2>
			<p>为了进行<a id="_idIndexMarker992"/>预测，我们必须加载保存的模型，并对其调用<code>predict </code>函数。TensorFlow.js 提供了一个<code>loadLayersModel</code>函数，可以用来从文件系统加载保存的模型。在以下步骤中，我们将向您展示如何实现这一点:</p>
			<ol>
				<li value="1">创建一个名为<code>predict.js</code>的新文件。</li>
				<li>In the <code>predict.js</code> file, add the following code:<pre>const dfd = require("danfojs-node")
const tf = dfd.tf
async function loadModel() {
    const model = await tf.loadLayersModel('file://./sales_pred_model/model.json');
    model.summary()
    return model
}
loadModel()</pre><p>前面的<a id="_idIndexMarker993"/>代码从文件路径加载保存的模型，并打印摘要。摘要的输出应该类似于下面的屏幕截图:</p><div><img src="img/B17076_10_12.jpg" alt="Figure 10.12 – Model summary of the saved model&#13;&#10;"/></div><p class="figure-caption">图 10.12–已保存模型的模型摘要</p></li>
				<li>Now, create a new function called <code>predict</code> that uses the saved model to make a prediction, as shown in the following code snippet:<pre>...
async function predict() {
    //You'll probably have to do some data pre-processing as we did before training
    const data = [0.1, 0.21, 0.25, 0.058, 0.0, 0.0720, 0.111, 1, 0, 0.5, 0.33] //sample processed test data
    const model = await loadModel()
    const value = model.predict(tf.tensor(data, [1, 11])) //cast data to required shape
    console.log(value.arraySync());
 
}
predict()</pre><p>这里显示了<a id="_idIndexMarker994"/>输出:</p><pre>[ [ 738.65380859375 ] ]
...</pre><p>在前面的函数中，我们调用模型上的<code>predict</code>函数，并传递一个具有我们的模型所期望的正确形状(batch，11)的张量。这返回了预测的张量，从这个张量，我们得到了潜在的值。由此，我们可以看出，具有这些特定价值的产品售价大约为<strong class="bold">美元</strong> ( <strong class="bold">美元</strong> ) $739。</p><p class="callout-heading">注意</p><p class="callout">在现实世界的<a id="_idIndexMarker995"/>应用程序中，您通常会从另一个<strong class="bold">逗号分隔值</strong> ( <strong class="bold"> CSV </strong>)文件中加载一个测试数据集，并应用与我们在培训期间所做的相同的数据处理步骤。该示例使用内联数据点，只是为了演示如何使用保存的模型进行预测。</p></li>
			</ol>
			<p>这就把我们带到了本章的结尾！恭喜你走到这一步。我相信你已经学到了很多。在下一章中，我们将通过构建一个更实际的应用程序——一个<a id="_idIndexMarker996"/>推荐系统来进行更深入的探讨！</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor196"/>总结</h1>
			<p>在本章中，我们向您介绍了 TensorFlow.js 的基础知识。具体来说，您学习了如何在浏览器和 Node.js 环境中安装 TensorFlow.js，学习了 tensors 和<code>tfjs</code>的核心数据结构，学习了核心和层 API，最后，您学习了如何构建、训练和保存回归模型。</p>
			<p>在下一章中，我们将深入到一个更实际的动手项目中，这里获得的知识将帮助你用 TensorFlow.js 和 Danfo.js 构建伟大的产品。</p>
		</div>
	

</body></html>