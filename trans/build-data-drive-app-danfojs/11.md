<title>B17076_08_ePub_RK</title>

# *第八章*:创建无代码数据分析/处理系统

创建 **Danfo.js** 的一个主要目的是方便在浏览器中处理数据。这提供了将数据分析和处理数据无缝集成到 web 应用程序中的能力。除了给网络应用添加数据处理的能力，我们还有工具让数据处理和分析看起来更像设计师使用 **Photoshop** 和 **Figma** 时所做的事情；他们如何通过点击在画布上混合笔触，或者他们如何通过在画布上放置画布，通过拖放和点击按钮来操纵图像。

有了 Danfo.js，我们可以轻松地实现这样一个环境(使用诸如 **React.js** 和 **Vue.js** 之类的工具)，在这个环境中，数据科学家变成了艺术家，只需点击几下按钮，就可以处理数据，并获得所需的输出，而无需实际编写任何代码。

很多具有这种特性的工具普遍存在，但是 Danfo.js 最酷的地方是用 JavaScript 工具构建整个应用程序。事实上，在不调用服务器的情况下，在浏览器中完成所有操作是非常神奇的。

本章的目的是展示如何使用 Danfo.js 和 React.js 构建这样一个环境。此外，请注意，此处使用的工具(除了 Danfo.js 之外)对于构建应用程序不是强制性的；这些只是我比较熟悉的工具。

本章将涵盖以下主题:

*   设置项目环境
*   构建和设计应用程序
*   应用程序布局和`DataTable`组件
*   创建不同的`DataFrame`操作组件
*   实现`Chart`组件

# 技术要求

以下是本章的基本环境和知识要求:

*   现代网络浏览器，如 Chrome 浏览器
*   合适的代码编辑器，如 **VScode**
*   **Node.js** 已安装
*   关于`tailwindcss`和`React-chart-js`的一点知识
*   需要 React.js 的基础知识。要复习 React.js，请查看 https://reactjs.org/docs/hello-world.html[的官方网站](https://reactjs.org/docs/hello-world.html)
*   本章的代码可以从 GitHub 获得，可以从 https://GitHub . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/tree/main/chapter 08

# 设置项目环境

React.js 用于项目，为了设置 React app，我们将使用`create-react-app`包为我们自动生成一个前端构建管道。但是首先，确保你有 Node.js 和`npx`，一个 *npm 5.2+* 自带的包运行器工具。

在我们进入设置我们的环境之前，这里是需要的工具，它们将被安装在本章中:

*   **React.js** :用于构建 UI 的 JavaScript 框架
*   **Draggable** :一个拖放库，使得移动 HTML 元素成为可能
*   `chart`组件
*   **React-table-v6** :显示表格的 React 库

以下是上述工具的一些替代工具:

*   **Vue.js** :用于构建 UI 的 JavaScript 库
*   rechart.js :基于 React.js 构建的可组合图表库
*   **Material-table** :基于 **material-UI** 进行反应的数据表

为了创建 React app 管道，我们使用`npx`调用`create-react-app`，然后指定我们项目的名称，如下所示:

```
$ npx create-react-app data-art
```

该命令将在启动该命令的父目录中创建一个名为`data-art`的目录。这个`data-art`目录预先填充了 React.js 模板和所有需要的包。

下面是`data-art`文件夹的结构:

![Figure 8.1 – React.js directory structure
](img/B17076_8_01.jpg)

图 8.1–react . js 目录结构

安装完成后，我们始终可以使用以下命令启动应用程序(假设您不在终端的`data-art`目录中):

```
$ cd data-art
$ yarn start
```

以下命令将启动应用服务器，并在终端中输出应用运行的服务器端口:

![Figure 8.2 – yarn start output
](img/B17076_8_02.jpg)

图 8.2–纱线开始输出

如*图 8.1* 所示，app 服务于`http://localhost:3000`。如果一切正常，那么一旦服务器启动，它将自动打开 web 浏览器来显示 React 应用程序。

对于app 的开发，我们不会在造型上花更多的时间，但我们会在未来更容易集成造型，也能实现快速原型制作；我们将利用`tailwindcss`。

为了让 Tailwind 与 React.js 应用程序一起工作，我们需要做一些额外的配置。

让我们通过`tailwindcss`文档中的[https://tailwindcss.com/docs/guides/create-react-app](https://tailwindcss.com/docs/guides/create-react-app)所示的`npm`安装 Tailwind 及其对等依赖项:

```
npm install -D tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9
```

安装完成后，我们将继续安装`craco`模块，这允许我们覆盖`postcss`配置，如下所示:

```
npm install @craco/craco
```

安装完`craco`之后，我们可以继续配置如何构建、启动和测试 React 应用程序。这将通过将`package.json`中的`"start"`、`"build"`和`"test"`命令更改为以下命令来完成:

```
{
  "start": "craco start",
  "build": "craco build",
  "test": "craco test",
}
```

根据前面所做的更改，让我们创建一个配置文件，使`craco`在构建 React 应用程序时能够始终注入`tailwindcss`和`autoprefixer`，如下面的代码所示:

```
// craco.config.js
module.exports = {
  style: {
    postcss: {
      plugins: [
        require('tailwindcss'),
        require('autoprefixer'),
      ],
    },
  },
}
```

我们来配置一下`tailwindcss`本身。有了这个配置，我们可以告诉`tailwindcss`删除生产中未使用的样式，我们可以添加自定义主题，我们还可以添加`tailwindcss`包中未包含的自定义颜色、字体、宽度和高度，如下所示:

```
//tailwind.config.js
module.exports = {
  purge: ["./src/**/*.{js,jsx,ts,tsx}", "./public/index.html"],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
```

配置好 Tailwind 之后，我们将编辑`src`目录中的`css`文件`index.css`。我们将在文件中添加以下内容:

```
/* ./src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
```

我们完成了配置；我们现在可以在`index.js`进口`index.css`:

```
//index.js
. . . . . .
import "./index.css
. . . . . .
```

注意，在`App.js`中，我们仍然拥有`create-react-app`包附带的默认代码；让我们编辑代码。下面是初始代码:

```
function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}
```

我们编辑`App`注释中的 HTML 代码，方法是编辑 HTML 并用应用程序的名称替换它:

```
function App() {
  return (
    <div className="">
      Data-Art
    </div>
  );
}
```

通过使用前面的代码更新`App.js`并保存它，您应该可以直接在浏览器中看到所做的更改，如下面的屏幕截图所示:

![Figure 8.3 – React app
](img/B17076_8_03.jpg)

图 8.3–反应应用程序

让我们测试一下我们的`tailwindcss`配置，确保它设置正确。我们将通过在前面的代码中添加一些样式来做到这一点，如下所示:

```
function App() {
  return (
    <div className="max-w-2xl border mx-auto text-3xl mt-60 text-center">
      Data-Art
    </div>
  );
}
```

在名为`className`的`div`属性中声明了`css`样式。首先，我们设置最大宽度和边框，然后沿着 *x* 轴创建一个边距(左右边距为`auto`)，声明字体大小为`text-3xl`，设置边距顶部为`60`，然后在`div`实例内居中文本。

根据样式，我们应该看到以下输出:

![Figure 8.4 – Centering the div and text
](img/B17076_8_04.jpg)

图 8.4–将 div 和文本居中

代码库已经设置好了，我们已经准备好实现我们的无代码环境。

在本节中，我们看到了如何为我们的应用程序设置一个 React 环境。我们还看到了如何为我们的应用配置`tailwindcss`。在下一部分，我们将学习如何构建和设计应用程序。

# 构建和设计应用程序

React.js 有一些应用程序设计的核心理念，主要是将 UI 分解成一个组件层次，其中一个想法是确定你的状态应该在哪里。

在本节中，我们将了解如何使用 React.js 设计我们的无代码应用程序的结构，并考虑应用程序设计的 React 理念。有了这个原则，我们会发现在 React 中实现一个基本的 UI 很容易。

首先，让我们了解什么是无代码环境，以及我们想要用它来实现什么。无代码环境用于简化数据处理和分析，只需点击几个按钮。

我们将创建一个平台，用户可以在其中上传数据、执行分析，并使用代码做他们想做的事情，例如:

*   数据帧到数据帧的操作，如`concat`
*   算术运算，如`cummax`和`cumsum`
*   通过列值过滤出数据帧的查询
*   描述数据帧

我们希望能够在不实际编码的情况下完成所有这些工作，一切都将在浏览器中完成。我们还希望通过使用条形图、折线图和饼图的数据可视化来获得对数据的洞察。下图是 app 设计的草图:

![Figure 8.5 – App structure and design sketch
](img/B17076_8_05.jpg)

图 8.5–应用程序结构和设计草图

*图 8.5* 显示了app 的结构和设计。应用程序分为三个主要组件，如下所示:

*   `Navbar`组件，包含文件上传、条形图、折线图和`DataFrame`操作选择字段
*   主体包含一个`Data Table`组件和一个`chart`组件
*   `SideBar`，包含图表和`DataFrame`操作的侧面

app 工作流程可描述如下:

1.  首先，上传一个数据文件(`csv`)。
2.  通过上传文件，创建了第一个`Data Table`。这是一个包含数据帧显示的组件。
3.  为了执行任何操作，例如`DataFrame`操作或图表操作，选择数据表，以便我们可以识别要在其上执行操作的正确表格。
4.  对于图表操作，可以单击条形图、折线图或饼图。该点击事件激活图表操作的`Side Plane`。
5.  如果选择了`DataFrame`操作，则`Side Plane`被激活用于`DataFrame`操作。
6.  当您填写完`Side Plane`中的必要字段后，一个新的图表组件和`Data Table`组件被创建。

下图描述了整个工作流程:

![Figure 8.6 – App workflow
](img/B17076_8_06.jpg)

图 8.6–应用程序工作流程

工作流显示了每个组件如何相互响应。例如，不上传文件，主体和`Side Plane`将不可见。即使上传了文件，`Side Plane`仍然是隐藏的，只有在特定数据表上执行数据帧或图表操作时才会出现。

由此可见，我们需要创建一个状态来管理文件上传时主体的激活，还需要创建一个状态来管理在数据表上执行操作时如何激活`Side Plane`。另外，请注意`Side Plane`包含两个操作，我们必须根据所选的操作类型显示这些操作的字段。

如果选择的是图表操作，`Side Plane`需要显示所选曲线图的必要字段，无论是条形图、折线图还是饼图，如果选择的是`DataFrame`操作，`Side Plane`需要显示 DataFrame 操作字段，如下图所示:

![Figure 8.7 – Side plane operation fields
](img/B17076_8_07.jpg)

图 8.7–侧面操作区域

从*图 8.7* 中我们可以看到数据表和`chart`组件有一个`Data Table`组件和`chart`组件。每个组件都有一个状态，这使得我们可以根据需要创建、更新和删除组件。

如应用程序工作流程中所述，`Side Plane`操作需要用于可视化和`DataFrame`操作的数据，这些数据是通过点击我们想要处理的`Data Table`获得的。每个`Data Table`存储它自己的 DataFrame 对象(我们将在实现这些步骤时深入研究)。因此，每当单击一个数据表时，它在数据表状态中的索引被获取，并被传递到与数据表状态并排的侧平面中，该侧平面指示要对哪个数据表进行操作。

此外，为了让侧平面知道操作需要哪种图表类型(条形图、折线图或饼图)或要完成哪种类型的`DataFrame`操作，我们创建了一个状态来管理当前选择了哪种类型的图表或`DataFrame`。

总之，所需的状态集描述如下:

*   管理`DataTable`列表的状态
*   管理图表列表的状态
*   状态显示来管理`SidePlane`的可见性
*   管理当前`DataTable`索引的状态
*   管理所选图表类型的状态
*   管理当前选择的`DataFrame`操作的状态

这里创建的状态没有得到很好的优化。可以管理创建的状态的数量；例如，管理`Side Plane`可见性的相同状态也可用于管理所选图表的类型。

由于我们将使用不止一个或两个状态，并且一些状态与另一个状态交互，我们可以使用`useReducer`(一个 React 钩子)来管理状态交互，但是我们希望在不增加额外知识的情况下使这变得简单。

在这一部分，我们讨论了应用程序的设计和结构。我们还设计了应用程序工作流程，并讨论了要为应用程序创建的不同状态。下一节，我们将讨论 app 布局和`DataTable`组件。我们将看到如何创建数据表组件以及如何管理状态。我们还将研究用 Danfo.js 在浏览器中上传文件。

# 应用布局和数据表组件

在本节中，我们将看到如何根据上一节中讨论的设计和工作流程来布局应用程序。此外，我们将实现`DataTable`组件，负责显示`DataFrame`表。我们还将实现`DataTables`组件，负责显示不同的`DataTable`组件。

我们已经看到了应用程序的草图，也看到了应用程序的基本工作流程。我们将开始实施步骤，首先构建应用程序的基本布局，然后实施数据表组件。

有了`tailwindcss`，布局 app 相当容易。让我们创建一个名为`App.js`的文件，并输入以下代码:

```
function App() {
  return (
    <div className="max-w-full mx-auto border-2 mt-10">
      <div className="flex flex-col">
        <div className="border-2 mb-10 flex flex-row">
          Nav
        </div>
        <div className="flex flex-row justify-between border-2">
          <div className="border-2 w-full">
            <div>
              Main Body
            </div>

          </div>
          <div className="border-2 w-1/3">
            Side Plane
          </div>
        </div>
      </div>

    </div>
  );
}
```

前面的代码片段创建了带有`flex`框的应用程序布局。该布局显示了 app 的基本组件，分别是`Nav`、`Main Body`和`Side Plane`。

注意

教程中使用的`css`实例就不解释了。我们的主要重点是建立应用程序的功能。

如果一切运行良好，我们应该得到如下输出:

![Figure 8.8 – App layout
](img/B17076_8_08.jpg)

图 8.8–应用程序布局

我们已经设计好了应用程序。让我们继续实现`DataTable`组件来显示所有`DataFrame`操作的结果。

## 实现数据表组件

一个`DataTable`组件是负责数据表的显示。对于每个数据帧操作，我们生成一个显示操作结果的新数据表，如下图所示:

![Figure 8.9 – Data table
](img/B17076_8_09.jpg)

图 8.9-数据表

对于表格的显示，我们将使用一个名为`react-table-v6`的 React 包，因为我们希望`DataTable`组件可以在页面上拖动，所以有一个名为`react-draggable`的包，这使得实现这个特性更加容易。

注意

`DataTable`的代码可以从这里拉出来:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/datatable . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/DataTable.js)。

我们需要使用`yarn`将这些包添加到我们的代码库中:

```
yarn add react-table-v6 react-draggable
```

一旦安装了这些包，让我们按照以下步骤在`src/component/DataTable.js`文件中创建一个`DataTable`组件:

1.  我们导入必要的包:

    ```
    import React from "react"; import ReactTable from 'react-table-v6' import Draggable from 'react-draggable'; import 'react-table-v6/react-table.css'
    ```

2.  We create the `DataTable` component:

    ```
    export default function DataTable({ columns, values, setCompIndex, index }) {
      // DataTable component code here
    }
    ```

    `DataTable`组件接收以下`props`值:

    *   `columns`:数据表列名。
    *   `values`:数据表各列数值。
    *   `setCompIndex`:这是一个状态函数，用于管理当前选中的数据表。
    *   `index`:这是当前表格的索引。
3.  For the `react-table` component, we need to reshape the column and the values to fit the desired input for the `react-table` component.

    让我们重塑要传递到`react-table`中的列值:

    ```
    const dataColumns = columns.map((val, index) => {
        return { Header: val, 
          accessor: val,
          Cell: (props) => (
            <div className={val || ''}>
              <span>{props.value}</span>
            </div>
          ),
          width:
            index === 0 && (1280 * 0.8333 - 30) / columns.length < 130
              ? 130
              : undefined,
        }
      });
    ```

    使用前面的代码，列名(即表的`Header`)被转换为以下形状:

    ```
    [{
      Header: "A",
      accessor: "A"
    },{
      Header: "B",
      accessor: "B"
    },{
      Header: "C",
      accessor: "C"
    }]
    ```

    `Header`键是表格中要显示的列的名称，`accessor`是数据中的键。

4.  我们需要将数据表的值转换成`react-table`需要的格式。下面的代码用于转换数据表的值:

    ```
    const data = values.map(val =>{     let rows_data = {}     val.forEach((val2, index) => {       let col = columns[index];       rows_data[col] = val2;     })     return rows_data;   })
    ```

如前面的代码所示，我们将把数据表值转换成以下数据形式:

```
[{
  A: 2,
  B: 3,
  C: 5
},{
  A: 1,
  B: 20,
  C: 50
},{
  A: 23,
  B: 43,
  C: 55
}]
```

最初，`values`是一个数组的数组，该数组被转换成前面的数据格式，然后被赋给`data`变量。

在前面的列格式中声明的访问器指向字典中每个键的值。有时，我们可能有以下格式的嵌套数据:

```
[{
  dummy: {
    A: 1.0,
    B: 3.0
  },
  dummy2: {
    J: "big",
    k: "small"
  }
}, . . . . ]
```

对于这种类型的数据格式，我们可以将`data`列声明为以下格式:

```
[{
  Header: "A",
  accessor: "dummy.A"
},
{
  Header: "B",
  accessor: "dummy.B"
},
{
  Header: "J",
  accessor: "dummy2.J"
},
{
  Header: "K",
  accessor: "dummy2.K"
}]
```

对于这个项目，我们不会使用这种嵌套的数据格式，所以没有必要深入研究，但是如果你有兴趣，你可以查看一下文档。

包括`Header`在内的列名和表数据现在都是正确的格式，可以传递到`react`表中了。`DataTable`组件现已更新，包含以下代码:

```
function DataTable({ columns, values, setCompIndex, index }) {
 . . . . . . . . . . . . . . . . . . . .
const handleSidePlane = ()=>{
    setCompIndex(index)
  }
  return (
    <Draggable >
        <div className="w-1/2" onClick={()=> handleSidePlane()}>
        <ReactTable
          data={data}
          columns={dataColumns}
          getTheadThProps={() => {
            return { style: { wordWrap: 'break-word', whiteSpace: 'initial' } }
          }}
          showPageJump={true}
          showPagination={true}
          defaultPageSize={10}
          showPageSizeOptions={true}
          minRows={10}
        />
    </div>
    </Draggable>
  )  
}
```

`ReactTable`组件被包裹在`Draggable`组件中，使`DataTable`组件可拖动。在`ReactTable`组件中，我们设置了一些分页字段，比如设置默认页面为`10`。

回想一下在设计我们提到的应用程序的工作流程时，如何在点击时跟踪一个`Data Table`的 ID。`handleSide Plane`函数用于调用`setCompIndex`。`setCompIndex`用于更新`compIndex`状态，存储所选`Data Table`的索引。

注意

这里有`DataTables`的代码:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/datatables . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/DataTables.js)。

每个操作都会生成几个数据表，因此我们需要管理这个`Data Table`的显示。我们将创建一个组件来管理所有生成的`Data Tables`的显示；因此，我们将在组件目录中创建一个文件，并将其命名为`Data Tables`，包含下面的代码:

```
import React from 'react'
import DataTable from './DataTable'
export default function DataTables({datacomp, setCompIndex,}) {
  return (
    <div>
      {datacomp.map((val,index) => {
        return( 
                <>
                <DataTable 
                  key={index} 
                  columns={val.columns} 
                  values={val.values} 
                  setCompIndex={setCompIndex}
                  index={index}                />
                </>
                )
      })}
    </div>
  )
}
```

该组件循环通过`datacomp`状态，并将每个道具传递给`DataTable`组件。

在下一小节中，我们将继续并初始化不同的状态，还将展示如何上传 CSV 并获取我们的数据。

## 文件上传和状态管理

从应用程序的设计中，我们看到对于任何要发生的操作，我们需要先上传一个文件。通过上传文件，我们创建了将被`DataTable`和`chart`组件使用的`DataFrame`。

注意

在本章中，`App.js`中的代码是根据新组件的实现逐步更新的。不过`App.js`的最终代码在这里有:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/app . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/App.js)。

我们将通过以下步骤更新`App.js`中的代码，以包含`Data`组件状态、文件上传和状态更新:

1.  我们导入了`React`和一个名为`useState` :

    ```
    import React, { useState } from 'react';
    ```

    的 React 钩子
2.  我们导入`read_csv`方法，该方法将用于读取上传的 CSV 文件:

    ```
    import { read_csv } from 'danfojs/src/io/reader' // step 2
    ```

3.  我们为生成的每个`DataTable`组件创建一个状态来存储数据列表:

    ```
    const [dataComp, setDataComp] = useState([])
    ```

4.  We then create a function to manage file upload and read the uploaded file into a `DataFrame`:

    ```
    const changeHandler = function (event) {
        const content = event.target.files[0]
        const url = URL.createObjectURL(content)

        read_csv(url).then(df => { 
          const columns = df.columns
          const values = df.values
          setDataComp(prev => {
            let new_data = prev.slice()
            let key = new_data.length + 1
            let dict = {
              columns: columns,
              values: values,
              df: df,
              keys: "df" + key
            }
            new_data.push(dict)
            return new_data
          })

        }).catch((error) => {
          console.log(error)
        })
      }
    ```

    在前面的代码中，我们用`URL.createObjectURL`从上传的文件中生成一个 blob URL。这样做是因为`Danfo.js`中的`read_csv`代码仅取自 CSV 文件的本地路径、CSV 文件的 HTTP URL 和 CSV 文件的 blob URL。

    生成的 URL 是，然后传递给`read_csv`函数。由于`read_csv`是一个异步函数，我们需要等待承诺被解析，然后通过`then`方法从承诺中收集返回值。解析承诺的返回值是一个`DataFrame`。

    使用`read_csv`，CSV 数据被转换为`DataFrame`，然后`DataComponent`状态被更新。使用`setDataComp`状态函数，我们创建了一个包含以下键的对象:

    a) `columns`:存储 CSV 文件的标题(列名)

    b) `values`:存储 CSV 数据点，即`DataFrame`值

    c) `df`:存储生成的`DataFrame`

    d) `keys`:为每个数据成分生成一个密钥`data`

    需要做出一个决定，是将数据帧本身保存在每个组件的状态数据中。因为我们已经存储了列名和`DataFrame`值，所以看起来是多余的。

    但是我们最终存储它的原因是，每次我们需要执行`DataFrame`操作时，总是从列和值创建一个`DataFrame`在计算上会很昂贵。

    此外，`columns`和`values`被存储起来，以便在我们想要从`react-table`组件生成一个表时可以方便地访问。但是，它仍然感觉是多余的，作为一个个人练习(在这一节末尾列出的待办事项列表中)，你可以继续清理它。

5.  We print out the output of the `dataComp` state in the browser console once the state is updated:

    ```
    if (dataComp.length) { //step 8
        console.log("dataComp column", dataComp[0].columns)
        console.log("dataComp values", dataComp[0].values)
        console.log("dataComp dataFame", dataComp[0].df)
      }
    ```

    下面的截图显示了应用程序更新后的用户界面:

![Figure 8.10 – Updated UI for file upload
](img/B17076_8_10.jpg)

图 8.10-文件上传的更新用户界面

上传文件后，我们应该会在浏览器控制台中看到以下输出:

![Figure 8.11 – dataComp state output
](img/B17076_8_11.jpg)

图 8.11–数据组件状态输出

我们已经为每个`DataTable`组件设置了文件上传和状态管理。让我们将创建的`DataTables`组件集成到应用程序中。

### 将数据表组件集成到 App.js 中

`App.js`将通过以下步骤进行更新:

1.  我们导入`DataTables`组件并创建一个`compIndex`状态，这使我们能够存储我们想要在时刻处理的`DataTable`组件的索引:

    ```
    . . . . . . . . . . . .  import DataTables from './components/DataTables'; function App() {    . . . . . . . . . .    const [compIndex, setCompIndex] = useState()   . . . . . . . . . . }
    ```

2.  We then add the `DataTables` component to the `App` component:

    ```
    <div>
        {(dataComp.length > 0) &&
            <DataTables
                datacomp={dataComp}
                setCompIndex={setCompIndex}
            />
         }
    </div>
    ```

    为了启用`DataTable`组件可见性，我们检查`dataComp`状态是否为空。上传文件前，如果`dataComp`状态为空，`DataTable`组件将不可见。一旦文件被更新，`DataTable`组件变得可见，因为`dataComp`状态不再为空。

    上传文件后，上面的代码应该会给出以下输出:

![Figure 8.12 – Display of the DataTable component on file upload
](img/B17076_8_12.jpg)

图 8.12–文件上传时数据表组件的显示

在本节中，我们讨论了文件上传和`DataTable`创建和管理，并了解了如何管理状态。在下一节中，我们将实现不同的`DataFrame`操作组件，还将为`DataFrame`操作实现`Side Plane`。

# 创建不同的数据帧操作组件

在本节中，我们将创建不同的`DataFrame`操作组件，并为`DataFrame`操作组件实现`Side Plane`。Danfo.js 包含了很多`DataFrame`操作。如果我们要为每一个设计一个组件，这将是非常紧张和多余的。

为了防止为每个`DataFrame`方法创建一个组件，我们根据它们的(关键字)参数，即根据传递给它们的变量，对每个`DataFrame`操作进行分组。例如，有些`DataFrame`方法只接受操作轴，因此我们可以将这些类型的方法组合在一起。

下面是要创建的`DataFrame`操作组件和分组在它们下面的`DataFrame`方法的列表:

*   `DataFrame`参数仅为操作轴的方法，可以是`1`或`0`。对`DataFrame`进行算术运算的方法有`min`、`max`、`sum`、`std`、`var`、`sum`、`cumsum`、`cummax`、`cummin`。
*   `DataFrame`组件，如`DataFrame`与一个序列、一个值或一个`DataFrame`之间的逻辑运算。用于执行这些操作的方法有`concat`、`lt`、`gte`、`lte`、`gt`和`neq`。
*   `DataFrame`查询。
*   `DataFrame`统计。

我们将开始查看这些组件的实现，从最不复杂的开始，顺序是:`Describe`、`query`、`Df2df`和`Arithmetic`。

## 实现描述组件

在本节中，我们将实现`Describe`组件，并集成`Side Plane`组件。

在`src/Components/`目录中，让我们创建另一个名为`Side Planes`的文件夹。该文件夹将包含`DataFrame`操作的所有组件。

在`Side Planes/`文件夹中，让创建一个名为`Describe.js`的`".js"` 文件，并按照以下步骤更新它:

1.  我们创建`Describe`功能组件，接受`dataComp`状态和`setDataComp`状态函数，用生成的`DataFrame` :

    ```
    export default function Describe({ dataComp, setDataComp}) { }
    ```

    更新`dataComp`状态
2.  We create a button named `Describe`:

    ```
    return (
        <div>
          <button onClick={()=> describe()} className="bg-blue-700 text-white rounded-sm p-2">Describe</button>
        </div>
    )
    ```

    `Describe`组件有一个按钮接口，因为它不接受任何参数。按钮有一个`onClick`事件，每当点击按钮时，该事件触发`Describe`功能。

3.  We then implement the `describe()` function, which is triggered anytime the `describe` button is clicked:

    ```
    const describe = ()=> {
        const df = dataComp.df.describe()
        let column = df.columns.slice()
        column.splice(0,0, "index")
        const values = df.values 
        const indexes = df.index

        const new_values = values.map((val, index)=> {
          let new_val = val.slice()
          new_val.splice(0,0, indexes[index]) 
           return new_val
        })
     . . . . . . . . 
    }
    ```

    我们从`dataComp`状态获取包含`DataFrame`的`df`键，然后调用`describe`方法。

    从由`describe`操作生成的`DataFrame`中，我们获得列，并向列名列表添加一个索引。索引被添加到列表的开头；这样做是因为需要从`describe` 方法生成的索引来捕获数据中的每一行。

    接下来，我们获取`DataFrame`值，对其进行循环，并将索引值添加到获取的`DataFrame`值中。

4.  我们用新生成的列、值和`DataFrame` :

    ```
    setDataComp(prev => { // step 7     let new_data = prev.slice()     let dict = {       columns: column,       values: new_values,       df: df     }     new_data.push(dict)     return new_data })
    ```

    更新`dataComp`状态

为了查看该组件的运行情况，我们需要实现`DataFrame`操作选择字段，如图*图 8.5* 中的`App`设计草图所示的。该`DataFrame`操作选择域使我们能够选择在`Side Plane`中显示哪个`DataFrame`操作组件。

为此，我们需要在`Navbar`组件中为`DataFrame`操作添加字段，以及用于文件上传的输入字段。此外，我们需要为`Side Plane`中显示的每个`DataFrame`操作组件实现条件渲染。

### 为描述组件设置侧面板

在`Side Planes/`文件夹中，我们创建一个名为`Side Plane.js`的文件，并输入以下代码:

```
import React from 'react'
import Describe from './Describe'
export default function SidePlanes({dataComp, 
  dataComps,
  setDataComp,
  df_index,
  dfOpsType}) {

    if(dfOpsType === "Arithemtic") {
      return <div> Arithmetic </div>
    }
    else if(dfOpsType === "Describe") {
      return <Describe 
          dataComp={dataComp}
          setDataComp={setDataComp}
      />
    }
    else if(dfOpsType === "Df2df") {
      return <div> Df2df </div>
    } 
    else if(dfOpsType === "Query") {
      return <div> Query </div>
    }
  return (
    <div>
      No Plane
    </div>
  )
}
```

在前面的代码中，我们创建了一个`Side Plane`组件。该组件包含基于所选数据操作类型的条件呈现。选择的`DataFrame`操作由`dfOpsType`状态管理。

`Side Plane`进入`dataComp`状态，它可以是存储在`dataComps`状态的任何数据。一些`DataFrame`操作将需要选定的`dataComp`状态以及整个状态，也就是`dataComps`状态，用于其操作。

在`Side Plane`组件中，我们将检查`dfOpsType`以找出传递的操作类型和要在侧平面中呈现的接口。

在我们将`Side Plane`集成到`App.js`之前，让我们在`Side Planes/`文件夹中创建一个`index.js`文件。这样，我们就可以定义要导入的组件。由于我们使用的是来自`Side Plane`组件的条件渲染，我们只需要在`index.js`实例中导出`Side Plane`组件，如以下代码所示:

```
import SidePlane from './SidePlane'
export { SidePlane }
```

前面的代码使我们能够在`App.js`中导入`Side Plane`。

### 将 SidePlane 集成到 App.js

`Side Plane`被创造出来。让我们将集成到`App.js`中，并将用于`DataFrame`操作的 HTML `select`字段添加到`App.js,`中，如以下代码所示:

1.  我们导入`SidePlane`组件:

    ```
    import { SidePlane } from './components/SidePlanes' 
    ```

2.  We update the `App` component functionality with the following code:

    ```
    function App() {
      . . . . . . . . 
      const [dfOpsType, setDfOpsType] = useState() // step 2
      const [showSidePlane, setSidePlane] = useState(false) //step 3
      . . . . . . . . . 
      const dataFrameOps = ["Arithemtic", "Describe", "Df2df", "Query"] // step 4
      const handleDfops = (e) => { //step 6
        const value = e.target.value
        setDfOpsType(value)
        setSidePlane("datatable")
      }
     . . . . . . . . . . . . . . 
    }
    ```

    在前面的代码中，我们创建了`dfOpsType`状态来存储当前选择的`DataFrame`操作的类型。

    `showSidePlane`也被创建来管理`SidePlane`可见性。此外，还创建了一个`DataFrame`操作数组。然后我们创建一个函数来处理每当点击`DataFrame`操作时更新`dfOpsType`和`showSidePlane`状态。

3.  We then add the `SidePlane` component:

    ```
    <div className="border-2 w-1/3">
         {showSidePlane
              &&
              (
               showSidePlane === "datatable" ?
                  <div className="border-2 w-1/3">
                    <SidePlane
                      dataComp={dataComp[compIndex]}
                      dataComps={dataComp}
                      df_index={compIndex}
                      setDataComp={setDataComp}
                      dfOpsType={dfOpsType}
                     />
                  </div> :
                  <div className="border-2 w-1/3">
                        Chart Plane
                  </div>
             )
        }
    </div>
    ```

    在前面的代码中，我们通过首先检查`SidePlane`状态不为*假*来显示`SidePlane`，然后我们检查要显示的`SidePlane`的类型。因为我们只实现了`DataFrame`操作列表中的组件，所以让我们上传一个文件，然后执行一个`DataFrame`操作。下面的截图显示了对`DataTable`执行`Describe`操作的结果:

![Figure 8.13 – Describe operation on DataTable
](img/B17076_8_13.jpg)

图 8.13–描述对数据表的操作

在前面的截图中，左上角的数据表是上传文件时生成的，右下角的`DataFrame`是`Describe`操作的结果。

在本节中，我们看到了如何实现`Describe`组件以及如何管理`Side Plane`可见性。在下一节中，我们将为`DataFrame`中的`Query`方法实现`Query`组件。

## 实现查询组件

在本节中，我们将为`DataFrame`查询方法创建一个组件。该组件将帮助根据`Data Table`按列值过滤`DataFrame`。

注意

这里有一个`Query`组件的代码:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/query . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Query.js)。

让我们在`components/Side Planes/`文件夹中创建一个名为`Query.js`的文件，并按照以下步骤更新它:

1.  We create the `Query` component:

    ```
    import React, { useRef } from 'react'

    export default function Query({ dataComp, setDataComp}) {
      // step 1
      const columnRef = useRef()
      const logicRef = useRef()
      const valuesRef = useRef()
     . . . . . . . . . . . . 
    }
    ```

    我们创建了一个`useRef`钩子变量，它使我们能够获得以下输入字段的输入的当前值:列字段(接受用于查询的列的名称)、逻辑字段(接受用于查询的逻辑值)和值字段(接受用于查询所选列的值)。

2.  We then update the `Query` component with the following code:

    ```
      const columns = dataComp.columns
      const logics = [">", "<", "<=", ">=", "==", "!="]
    ```

    在前面的代码中，我们获得了当前`Data Table`的`DataFrame`中可用的列名。该列名将用于填充选择字段，用户可以选择要查询的列。

    我们还创建了一个符号列表来描述我们想要执行的逻辑操作的类型。该符号也将用于填充选择字段，用户可以选择用于查询的逻辑操作。

3.  创建一个`query`函数。每当点击**查询**按钮时，该功能将被触发执行查询操作:

    ```
    const query = ()=>{     const qColumn = columnRef.current.value     const qLogic = logicRef.current.value     const qValue = valuesRef.current.value        const  df = dataComp.df.query({column: qColumn, is: qLogic, to: qValue})     setDataComp(prev => {       let new_data = prev.slice()       let dict = {         columns: df.columns,         values: df.values,         df: df       }       new_data.push(dict)       return new_data     })   }
    ```

每当触发`query` 功能时，我们获得每个输入字段(选择字段)的值。例如，为了获得列字段的值，我们使用了`columnRef.current.value`。同样的事情也适用于获取另一个字段中的值。

我们还调用属于当前`dataComp`状态的`DataFrame`的查询方法。从每个输入字段获得的值被传递到查询方法中，以执行操作。

使用`setDataComp`状态功能更新`dataComps`状态。通过更新`dataComps`状态，创建一个新的状态，包含`query`方法的结果。

### 实现查询组件接口

我们已经看到了`Query`组件的后端，所以现在让我们为它构建一个接口。让我们用以下步骤更新`Query.js`中的代码:

1.  For the query UI, we create a form containing three different input fields. First, we create the input field for the column field:

    ```
    <div>
      <span className="mr-2">Column</span>
        <select ref={columnRef} className="border">
          {
             columns.map((column, index)=> {
              return <option value={column}>{column}</option>
             })
          }
        </select>
    </div>
    ```

    对于列字段，我们遍历列数组，为`DataFrame`中的列列表创建 HTML 选择字段选项。我们还包括`columnRef`来跟踪所选择的列名。

2.  We then create the logic input field:

    ```
    <div>
      <span className="mr-2">is</span>
      <select ref={logicRef} className="border">
         {
           logics.map((logic, index)=> {
             return <option value={logic}>{logic}</option>
           })
         }
      </select>
    </div>
    ```

    我们遍历`logic`数组并用逻辑运算符填充 HTML 选择字段。另外，`logicRef`被添加到 HTML 选择字段中，以获得所选择的逻辑运算符。

3.  然后，我们为查询值

    ```
    <div>   <span className="mr-2">to</span>     <input ref={valuesRef} placeholder="value" className="border"/> </div>
    ```

    创建`input`字段
4.  We create a `button` class name to make a call to the `query` function:

    ```
    <button onClick={()=>query()} className="btn btn-default dq-btn-add">Query</button>
    ```

    为了可视化主应用程序中的`query`组件，让我们更新`SidePlane.js`中的`SidePlane`组件:

    ```
    Previous code:
     . . . . . . . .
    else if(dfOpsType === "Query") {
          return <div> Query </div>
        }
    Updated code:
    else if(dfOpsType === "Query") {
          return <Query 
                dataComp={dataComp}
                setDataComp={setDataComp}
          />
        }
    ```

前面的代码更新了`Side Plane`以包含`Query`组件。如果我们对上传的文件执行查询操作，应该会得到以下结果:

![Figure 8.14 – Query operation run on column C, checking whether its value is greater than 20
](img/B17076_8_14.jpg)

图 8.14–在列 C 上运行查询操作，检查其值是否大于 20

在本节中，我们创建了一个`query`组件。在下一节中，我们将研究如何为涉及`DataFrame`到`DataFrame`操作、序列和标量值的操作创建一个组件。

## 实现 Df2df 组件

在本节中，我们将实现一个组件，用于在一个`DataFrame`和另一个`DataFrame`、`Series`和`Scalar`值之间执行运算。

注意

这里有`Df2df`组件的代码:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/df2df . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Df2df.js)。

Danfo.js 中有不同的组件来执行`DataFrame`和`Series`以及`DataFrame`和`Scalar`值之间的操作。为了避免为每个方法创建一个组件，我们可以将它们组合在一起形成一个组件。

我们计划组合在一起的`DataFrame`方法列表如下:

*   小于(`df.lt`)
*   大于(`df.gt`)
*   不等于(`df.ne`)
*   等于(`df.eq`)
*   大于或等于(`df.ge`)
*   加法(`df.add`)
*   减法(`df.sub`)
*   乘法(`df.mul`)
*   司(`df.div`)
*   力量(`df.pow`)

在前面的方法列表中，一个共同的属性是它们都接受相同类型的参数，即值(可以是`DataFrame`、`Series`或`scalar`值)和要执行操作的轴。

如果我们看一下`DataFrame` `concat`方法，它也接受与前面列表中的方法相似的相同模式的参数。唯一的区别是对于`concat`方法来说，`df_list`参数是一个`DataFrames`的数组。

让我们在`Side Planes/`文件夹中创建一个名为`Df2df.js`的文件。在该文件中，我们将通过以下步骤实现`Df2df`组件:

1.  First, we import `concat` from Danfo.js, and then create the `Df2df` component:

    ```
    import React, { useRef } from 'react'
    import { concat } from 'danfojs/src/core/concat'

    export default function Df2df({dataComp, dataComps,df_index, setDataComp}) {
      const dfRef = useRef()
      const inpRef = useRef()
      const axisRef = useRef()
      const opsRef = useRef()

      const allOps = [
        "lt", "ge", "ne",
        "eq", "gt", "add",
        "sub", "mul", "div",
        "pow", "concat"
      ]
     . . . . . . . . .  . . . . 
    }
    ```

    我们为每个输入字段创建了一个引用变量。对于`Df2df`操作，我们有四个输入域(`DataFrame`选择域、`scalar`值输入域、`axis`域和`operation`类型域)。

    `operation`类型字段包含`Df2df`组件中所有可用操作的列表。这将是一个选择字段，因此用户可以选择要处理的任何操作。

    我们还创建了一个由`Df2df` 组件提供的所有操作的`allOps`列表。

2.  We also need to create a function to perform the `Df2df` operation whenever the `submit` button is clicked:

    ```
    const df2df = () => {
        // step 4
        let dfIndex = dfRef.current.value
        let inp = parseInt(inpRef.current.value)
        let axis = parseInt(axisRef.current.value)
        let ops = opsRef.current.value
     . . . . . . . . . . . . . .
    }
    ```

    我们从属于每个输入字段的所有参考变量中获得了值。

3.  We update the `df2df` function with the following code:

    ```
      if( ops != "concat") {
          let value = dfIndex === "None" ? inp : dataComps[dfIndex].df
          let df = dataComp.df

          let rslt = eval('df.${ops}(value, axis=${axis})') // step 6

          setDataComp(prev => {
            let new_data = prev.slice()
            let key = new_data.length +1
            let dict = {
              columns: rslt.columns,
              values: rslt.values,
              df: rslt,
              keys: "df" + key
            }
            new_data.push(dict)
            return new_data
          })
        }
    ```

    我们检查选择的操作不是`concat`操作。这样做是因为`concat`操作接受一个`DataFrames`列表，而不仅仅是一个`DataFrame`或`Series`。

    我们利用`eval`函数来防止编写多个`if`条件来检查调用哪个`DataFrame`操作。

4.  我们为`concat`操作实现条件。我们还调用了`DataFrame` :

    ```
    . . . . . . . . . else { // step 7       let df2 = dataComps[dfIndex].df       let df1 = dataComp.df       let rslt = concat({ df_list: [df1, df2], axis: axis })         let column = rslt.columns.slice()       column.splice(0,0,"index")       let rsltValues = rslt.values.map((val, index) => {         let newVal = val.slice()         newVal.splice(0,0, rslt.index[index])         return newVal       })      . . . . . . . . . . .  }
    ```

    中的`concat`方法

前面的步骤显示了`Df2df`组件的后端实现。

### 实现 Df2df 组件接口

让我们通过以下步骤更新UI 的代码:

1.  For the UI, we need to create a form containing four input fields. First, we create an input field to select the type of `DataFrame` operation we want:

    ```
    <div>
      <span className="mr-2"> Operations</span>
       <select ref={opsRef}>
        {
          allOps.map((val,index) => {
           return <option value={val} key={index}>{val}</option>
           })
         }
       </select>
    </div>
    ```

    我们遍历`allops`数组来创建一个`input`字段，以选择不同类型的`DataFrame`操作。

2.  We then create an `input` field to select the `DataFrame` we want to perform the operation selected on:

    ```
    <div>
      <span className="mr-2"> DataFrames</span>
       <select ref={dfRef}>
          <option key={-1}>None</option>
            {
              dataComps.map((val,index) => {
                if( df_index != index) {
                  return <option value={index} key={index}>{'df${index}'}</option>
                } 
             })
            }
       </select>
    </div>
    ```

    我们还循环遍历`dataComps`状态，以获得除了我们正在执行操作的`dataComp`状态之外的所有`dataComp`状态。

3.  然后我们创建一个`input`字段来输入我们的值；在这种情况下，我们正在执行`DataFrame`和`Scalar`值之间的运算:

    ```
    <div>   <span>input a value</span>   <input ref={inpRef} className="border" /> </div>
    ```

4.  我们创建一个`input`字段来选择操作轴:

    ```
    <div>   <span>axis</span>   <select ref={axisRef} className="border">     {       [0,1].map((val, index) => {         return <option value={val} key={index}>{val}</option>        })     }  </select> </div>
    ```

5.  We then create a button that triggers the `df2df` function to perform a Df2df operation based on the input fields:

    ```
    <button onClick={()=>df2df()} className="bg-blue-500 p-2 text-white rounded-sm">generate Dataframe</button>
    ```

    在前面的步骤中，我们为组件创建了 UI。

    让我们更新`SidePlane`组件以包含 Df2df 组件:

    ```
    import Df2df from './Df2df'
    export default function SidePlanes({dataComp, 
      dataComps,
      setDataComp,
      df_index,
      dfOpsType}) {
        . . . . . . . . 
        else if(dfOpsType === "Df2df") {
          return <Df2df 
              dataComp={dataComp}
              dataComps={dataComps}
              df_index={df_index}
              setDataComp={setDataComp}
          />
        } 
       . . . . . . . . .

       }
    ```

    前面的代码将`Df2df`组件添加到`SidePlane`组件中，并且在`Df2df`组件中传递所需的道具。以下屏幕截图显示了两个内容相同的 CSV 文件的上传:

![Figure 8.15 – Uploading CSV files with the same content
](img/B17076_8_15.jpg)

图 8.15–上传具有相同内容的 CSV 文件

下面显示了对选中的`Data Table`执行`Df2df`操作(具体为`concat`操作)的输出:

![Figure 8.16 – Performing a concat operation on the Data Table
](img/B17076_8_16.jpg)

图 8.16–对数据表执行 concat 操作

在本节中，我们创建了用于在两个`DataFrames`之间以及一个`DataFrame`和一个`Series` / `Scalar`值之间执行运算的`Df2df`组件。

在下一节中，我们将实现最后一个`DataFrame`组件，这是用于`DataFrame`算术运算的`arithmetic`组件。

## 实现算术组件

我们将实现`arithmetic`组件来执行`Danfo.js`中提供的一些算术运算。

注意

这里有`Arithmetic`组件的代码:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/side planes/arith em TIC . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/SidePlanes/Arithemtic.js)。

让我们在`Side Planes/`文件夹中创建一个名为`Arithmetic.js`的文件。以下步骤将用于创建`Arithmetic`组件:

1.  We create an `Arithmetic` component:

    ```
    import React, { useRef } from 'react'
    export default function Arithmetic({ dataComp, setDataComp}) {

      const seriesOps = ["median", "min", "max", "std", "var", "count", "sum"]
      const dfOps = ["cumsum", "cummax", "cumprod", "cummin"]
      const all = ["median", "min", "max", "std", "var", "count", "sum",
                   "cumsum", "cummax", "cumprod", "cummin"]

      const axisRef = useRef()
      const opsRef = useRef()
     . . . . . . . . . . . .
    }
    ```

    我们创建不同的数组来存储不同的操作，比如`seriesOps`用于串行操作，而`dfOps`用于数据帧操作。我们还创建了一个`all`数组，将所有这些操作(`Series`和`DataFrame`)存储在一起。

2.  We create a function called `arithmetic`. This function is used to perform the arithmetic operations:

    ```
    const arithemtic = () => {

        let sOps = opsRef.current.value
        let axis = axisRef.current.value
        if( seriesOps.includes(sOps)) {
          let df_comp = dataComp.df
          let df = eval('df_comp.${sOps}(axis=${axis})')

          let columns = Array.isArray(df.columns) ? df.columns.slice() : [df.columns]
          columns.splice(0,0, "index")
          let values = df.values.map((val,index) => {

            return [df.index[index], val]
          })
    . . . . . . . . . . . 
    }
    ```

    我们从输入字段`opsRef.current.value`和`axisRef.current.value`中获取值。我们还检查选择的操作是否属于`seriesOps`。如果是，我们执行选择的操作。

3.  We perform a `DataFrame` operation if the operation does not belong to `seriesOps`:

    ```
    else {

          let df_comp2 = dataComp.df
          let df = eval('df_comp2.${sOps}({axis:${axis}})')

          setDataComp(prev => {
            let new_data = prev.slice()
            let dict = {
              columns: df.columns,
              values: df.values,
              df: df
            }
            new_data.push(dict)
            return new_data
          })
        }
    ```

    上述步骤用于创建`Arithmetic`组件。`Arithmetic`的 UI 是与创建的其他`DataFrame`操作组件相同的。

    让我们将`arithmetic`组件添加到`SidePlane`组件中:

    ```
    import Arithmetic from './Arithmetic'
    export default function SidePlanes({dataComp, 
      dataComps,
      setDataComp,
      df_index,
      dfOpsType}) {
        . . . . . . . . 
        if(dfOpsType === "Arithmetic") {
          return <Arithmetic 
                dataComp={dataComp}
                setDataComp={setDataComp}
          />
        }
       . . . . . . . . .

       }
    ```

    前面的代码导入`Arithmetic`组件并检查`dfOpsType`组件是否为`Arithmetic`。

    以下截图显示了对`Data Table`执行算术运算的示例:

![Figure 8.17 – Arithmetic operation
](img/B17076_8_17.jpg)

图 8.17–算术运算

在本节中，我们讨论并实现了作为 React 组件的不同的`DataFrame`操作。我们能够将一些方法组织成一个单独的组件，以避免为每个操作创建组件。

在下一节中，我们将为不同的可视化实现一个`chart`组件。

# 实现图表组件

在本节中，我们将创建`chart`组件来显示常见和简单的图表，如条形图、折线图和饼图。然后我们将实现图表`Side Plane`来启用图表组件变量的设置。

注意

实现的`Chart`和`ChartPlane`组件的代码可从这里获得:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/chart plane . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/ChartPlane.js)。

在`src/components/`目录中，让我们创建一个名为`Chart.js`的文件，通过以下步骤实现`Chart`组件:

1.  We import our desired plotting component from `react-chartjs-2`, and then create the `Chart` component:

    ```
    import { Bar as BarChart } from 'react-chartjs-2';
    import { Line as LineChart } from "react-chartjs-2";
    import { Pie as PieChart} from "react-chartjs-2";
    import Draggable from 'react-draggable';

    export default function Chart({labels, dataset,type}) {
      let data = {
        labels: labels,
        datasets: [{
          backgroundColor: [
          . . . . . . . .  
          ],
          borderColor: [
          . . . . . . . .  
          ],
          borderWidth:1,
          data: dataset,
        }]
      };
    ```

    在前面的代码中，`Chart`组件接受以下道具:`labels`、`dataset`和`type`。`labels`表示列名，`dataset`表示`dataComp`值，`type`表示我们要绘制的图表类型。

    在`Chart`组件中，我们创建一个名为`data`的变量，这是一个按照`react-chartjs-2`绘制我们想要的图表所需的方式格式化的对象。

2.  We create a set of conditional rendering here, as we want to render a specific type of chart, based on the `prop` type passed into the `Chart` component:

    ```
    if(type==="BarChart"){
        return(
          <Draggable>
            <div className="max-w-md">
             <BarChart data={data} options={options} width="100" height="100" />
          </div>
          </Draggable> 
        )
      }
    . . . . . . .
    ```

    我们检查要呈现的图表类型。如果是条形图，我们从`react-chartjs-2`调用`BarChart`组件，并传入必要的道具。`BarChart`组件被包装在`Draggable`组件中，以使`chart`组件被呈现为可拖动。上述代码适用于渲染所有其他`Chart`组件，如`react-chartjs-2`中的`LineChart`和`PieChart`。

要深入研究`react-chartjs-2`，你可以查看这里的文档:[https://github.com/reactchartjs/react-chartjs-2](https://github.com/reactchartjs/react-chartjs-2)。

## 实现图表平面组件

我们已经创建了`chart`组件，现在让我们创建图表`Side Plane`。在`components/`文件夹中，让我们创建一个名为`ChartPlane.js`的文件，步骤如下:

1.  We create a `ChartPlane` component:

    ```
    export default function ChartPlane({setChartComp, dataComp, chartType}) {
      const df = dataComp.df
      const compCols = dataComp.columns
      let x;
      let y;
      if( compCols[0] === "index") {
        x = compCols
        y = dataComp.values[0].map((val, index)=> {
            if(typeof val != "string") {
              return compCols[index]
            }
        })
      } else {
        x = df.columns
        const dtypes = df.dtypes
        y = dtypes.map((val, i)=>{
            if(val != "string") {
              return x[i]
            }
        })
      }
    ```

    在前面的代码中，我们创建了一个接受以下属性的`ChartPlane`组件:

    a) `SetChartComp`:更新`chartComp`状态的函数

    b) `dataComp`:生成图表的当前`DataTable`组件

    c) `chartType`:我们想要生成的图表类型

    首先，在组件中，我们获得可能的 *x* 轴变量列表，并将它们存储在`x`变量中。这些*x*-轴变量可以是带有`String`的列名，也可以是数字`dtypes`。

    因为我们是相对于 *x* 轴绘制 *y* 轴，所以我们的 *y* 轴(变量`y`)必须是一个整数。因此，我们检查`DataFrame`的列不是字符串，如果不是，我们将该列添加到 *y* 轴变量列表中。

    注意

    这是灵活的。有时可以翻转图表，使 y 轴实际上是标签，x 轴包含数据。

2.  We create the UI for the `ChartPlane` component. Depending on how we've designed the UI for other components, the `x` and `y` variables are used to create an input field with which the user can select the *x*-axis label and the *y*-axis label:

    ```
    <select ref={xRef} className="border">
      {
         x.map((val, index)=> {
          return <option value={val} key={index} >{val}</option>
         })
       }
    </select>
    <select ref={yRef} className="border">
      {
        y.map((val, index) => {
          return <option value={val} key={index}>{val}</option>
        })
      }
     </select>
    ```

    这个 UI 还包含一个按钮，该按钮触发一个名为`handleChart`的函数，该函数更新`chart`组件:

    ```
    <button onClick={()=>handleChart()} className="bg-blue-500 p-2 text-white rounded-sm">generate Chart</button>
    ```

3.  We create a function called `handleChart`, which obtains the value of the *x*-axis and *y*-axis input fields and uses them to create the respective charts as requested:

    ```
    const handleChart = () => {
      const xVal = xRef.current.value
      const yVal = yRef.current.value
      const labels = xVal === "index" ? df.index : df[xVal].values
      const data = yVal === "index" ? df.index : df[yVal].values
        setChartComp((prev) => {
          const newChart = prev.slice()
          const key = newChart.length + 1
          const dict = {
            labels: labels,
            data: data,
            key: "chart" + key,
            type: chartType
          }
          newChart.push(dict)
          return newChart
        })
      }
    ```

    `xVal`和`yVal`是 *x* 轴和 *y* 轴的输入域值。创建`labels`和`data`变量，以包含`xVal`和`yVal`中相应列的值。标签和数据随后用于更新`chartComp`状态。

## 实现 ChartViz 组件

前面的步骤用于创建图表`Side Plane`，但是现在，我们看不到更新的`chartComp`组件。要查看图表，让我们创建一个组件来管理所有要显示的图表组件。

注意

这里有`ChartViz`要实现的代码:[https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/blob/main/chapter 08/src/components/charts viz . js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter08/src/components/ChartsViz.js)。

让我们在`components/`文件夹中创建一个名为`ChartViz.js`的文件。将以下代码添加到文件中:

```
import React from 'react'
import Chart from './Chart'

export default function ChartsViz({chartComp,setChartComp}) {
  return (
    <div>
      {
        chartComp.map((chart)=> {
          return(
            <>
            <Chart 
              labels={chart.labels}
              dataset={chart.data}
              type={chart.type}
          />
          </>
          )
        })
      }
    </div>
  )
}
```

在前面的代码中，我们导入我们的`chart` 组件，然后创建一个包含以下`chartComp`和`setChartComp`道具的`ChartViz`组件。我们遍历`chartComp`状态，并将每个状态值作为道具传递给`chart`组件。

## 将 ChartViz 和 ChartPlane 集成到 App.js 中

现在我们完成了组件的所有必要部分。让我们根据以下步骤更新我们的`App.js`组件来激活`chart`组件:

1.  我们将`ChartViz`和`ChartPlane`导入到`App.js` :

    ```
    import ChartsViz from './components/ChartsViz' import ChartPlane from './components/ChartPlane'
    ```

2.  We need to create some state to manage the type of chart we want, and the `chart` component:

    ```
    const [chartType, setChartType] = useState()
    const [chartComp, setChartComp] = useState([])
    const charts = ["BarChart", "LineChart", "PieChart"]
    ```

    在前面的代码中，我们还创建了一个数组变量来存储我们希望在我们的`Navbar`中显示的图表列表。

3.  We create a function to update the `chartType` component and the `Side Plane` component whenever a chart is created:

    ```
    const handleChart = (e) => { // step 4
        const value = e.target.innerHTML
        setChartType(value)
        setSidePlane("chart")
      }
    ```

    在`handleChart`函数中，我们获得目标值，即用户选择的图表类型。该值用于更新`chartType`组件，并且我们通过用`chart`字符串更新`showSidePlane`状态来通知`Side Plane`显示图表`Side Plane`。

4.  We loop the `charts` variable in the `nav` field and display them as buttons:

    ```
     . . . . . .
    { 
      charts.map((chart, i) => {
        return <button disabled={dataComp.length > 0 ? false : true}
        className={classes}
        onClick={handleChart}
       >
          {chart}
       </button>
     })
    }
    . . . . . . 
    ```

    在前面的代码中，我们循环遍历`charts`数组，并为数组中的每个值创建一个按钮。我们通过检查`dataComp`状态不为空，即是否没有文件上传，禁用了该按钮。

5.  We call the `ChartViz` component and pass in the necessary props:

    ```
    {(chartComp.length > 0) &&
        <ChartsViz
         chartComp={chartComp}
         setChartComp={setChartComp}
        />
    }
    ```

    我们检查`chartComp`状态是否不为空。如果不是，我们调用`ChartViz`组件，然后显示创建的图表。

6.  然后我们添加`ChartPlane`组件:

    ```
    <div className="border-2 w-1/3">     <ChartPlane        dataComp={dataComp[compIndex]}        setChartComp={setChartComp}        chartType={chartType}     /> </div>
    ```

如果`showSide Plane`图是数值图，则`Side` `Plane`中显示`ChartPlane`组件。

下面的截图显示了图表更新，在可用的`Data Table`上绘制条形图、折线图和饼图:

![Figure 8.18 – Chart component displayed
](img/B17076_8_18.jpg)

图 8.18-显示的图表组件

在本节中，我们实现了`ChartComponent`和`ChartPlane`。我们利用`React-chart-js`来简化每个图表组件的开发。

# 总结

在这一章中，我们看到了如何创建一个无代码环境，在这里你可以上传你的数据，然后立即开始处理和分析数据。我们还看到了如何将 Danfo.js 中的每个`DataFrame`方法转换成 React 组件。这提供了将所有 Danfo.js 方法转换成 React 组件的能力，因此为 Danfo.js 创建了 React 组件库。

此外，我们还看到了如何为应用程序设计流程，以及如何在 React 中管理状态。即使创建的一些状态是多余的，这也是您贡献和更新应用程序以使其健壮的机会。如果您可以更新应用程序，使删除、更新和保存正在进行的每个操作成为可能，这将使应用程序变得健壮，甚至可以投入生产。

下一章，我们将介绍机器学习。本章将以尽可能简单的形式涵盖机器学习背后的基本思想。