<html><head/><body>


	
		<title>B17076_12_ePub_RK</title>
		
	
	
		<div><h1 id="_idParaDest-207"><em class="italic"> <a id="_idTextAnchor210"/>第 12 章</em>:构建 Twitter 分析仪表板</h1>
			<p>本章的主要目的是展示如何在后端和前端使用 Danfo.js 构建一个完整的网络分析平台。</p>
			<p>为了演示这一点，我们将构建一个小型的单页面 web 应用程序，您可以在其中对 Twitter 用户进行搜索，获得在特定日期提到他们的所有推文，并执行一些简单的分析，如情绪分析，从数据中提取洞察力。</p>
			<p>在本章中，我们将探讨构建 web 应用程序的以下主题:</p>
			<ul>
				<li>设置项目环境</li>
				<li>构建后端</li>
				<li>构建前端</li>
			</ul>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor211"/>技术要求</h1>
			<p>本章需要以下内容:</p>
			<ul>
				<li>React.js 的知识</li>
				<li>本章代码，可在此处获得:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js/tree/main/chapter 12</a></li>
			</ul>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor212"/>设置项目环境</h1>
			<p>对于这个项目，我们将<a id="_idIndexMarker1053"/>建立一个具有后端和前端的单一网页。我们将使用 Next.js 框架来构建应用程序。Next.js 让你快速轻松地构建后端和前端成为可能。我们还将利用<code>tailwindcss,</code>,就像我们在以前的一些项目中所做的那样，比如无代码环境项目。</p>
			<p>要使用包含默认<code>tailwindcss</code>配置的 Next.js 来设置我们的项目环境，我们需要做的就是运行以下命令:</p>
			<pre>$ npx create-next-app -e with-tailwindcss twitterdashboard</pre>
			<p><code>npx</code>命令运行<code>create-next-app</code>，这将创建 Next.js 样板代码，包括<code>twitterdashboard</code>目录中的<code>tailwindcss</code>配置。请注意，<code>twitterdashboard</code>目录(也称为<em class="italic">项目名称</em>)可以被赋予您选择的任何名称。如果一切都成功安装了<a id="_idIndexMarker1054"/>,您应该会得到如下截图所示的输出:</p>
			<div><div><img src="img/B17076_12_01.jpg" alt="Figure 12.1 – Code environment setup &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.1–代码环境设置</p>
			<p>现在我们已经完成了安装，如果一切正常，您的项目中应该有以下文件:</p>
			<div><div><img src="img/B17076_12_02.jpg" alt="Figure 12.2 – Directory structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.2–目录结构</p>
			<p>最后，为了测试<a id="_idIndexMarker1055"/>项目是否已经安装好并准备就绪，让我们运行下面的命令:</p>
			<pre>$ npm run dev</pre>
			<p>该命令应该会自动启动应用程序并打开浏览器，显示以下界面:</p>
			<div><div><img src="img/B17076_12_03.jpg" alt="Figure 12.3 – Next.js UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.3–next . js 用户界面</p>
			<p>对于这个项目，我们将<a id="_idIndexMarker1056"/>修改<em class="italic">图 12.3 </em>中所示的界面，以适合我们的口味。</p>
			<p>现在代码环境已经设置好了，让我们继续创建我们的应用程序。</p>
			<h1 id="_idParaDest-210">构建后端</h1>
			<p>在本节中，我们将了解如何为我们的应用程序创建以下 API:</p>
			<ul>
				<li><code>/api/tweet</code>:这个 API 负责获取一个 Twitter 用户并获得他们的数据。</li>
				<li><code>/api/nlp</code>:该 API 负责对获取的用户数据进行情感分析。</li>
			</ul>
			<p>这些 API 将由前端组件使用，并将用于创建不同的可视化和<a id="_idIndexMarker1058"/>分析。让我们从创建获取 Twitter 用户数据的 API 开始。</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor214"/>构建 Twitter API</h2>
			<p>在这一节中，我们将<a id="_idIndexMarker1059"/>构建一个 API，使得获取提到 Twitter 用户的推文变得容易。从每条推文中，我们将获得它们的元数据，例如文本、发送者的姓名、赞和转发的数量、用于推文的设备以及推文创建的时间。</p>
			<p>为了构建获取 Twitter 用户数据的 Twitter API，并根据我们的喜好构建它以便在前端使用，我们需要安装一个工具，使它更容易与主要的 Twitter 开发人员 API 进行交互。在下面的命令中，我们将安装<code>twit.js</code>以便于访问和处理 Twitter API:</p>
			<pre>$ npm i twit</pre>
			<p>一旦<code>twit</code>被安装，我们需要配置它。要使用<code>twit</code>，我们需要各种 Twitter 开发者密钥，如下所示:</p>
			<pre>consumer_key='....',
consumer_secret='....',
access_token='.....',
access_token_secret='.....'</pre>
			<p>如果你没有这些密钥，你需要创建一个 Twitter 开发者账户，然后申请通过<a href="https://developer.twitter.com/">https://developer.twitter.com/</a>访问 API。如果被授予使用 Twitter API 的权限，你可以访问<a href="https://developer.twitter.com/en/apps">https://developer.twitter.com/en/apps</a>来创建一个应用程序并设置你的证书密钥。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">获取 Twitter API 可能需要几天时间，这取决于您如何描述您的用例。要获得设置 Twitter API 和获取必要密钥的直观帮助的正确分步指南，请遵循以下步骤:<a href="https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials">https://real python . com/Twitter-bot-python-tweepy/# creating-Twitter-API-authentic ation-credentials</a>。</p>
			<p>获得项目所需的 Twitter 开发人员密钥后，我们将在代码中使用它们。为了防止向公众公开密钥，我们创建一个名为<code>.env.local</code>的文件，在这个文件中，我们添加 API 密钥，如下面的代码块所示:</p>
			<pre>CONSUMER_KEY='Put in your CONSUMER_KEY',
CONSUMER_SECRET='Your CONSUMER_SECRET',
ACCESS_TOKEN ='Your ACCESS_TOKEN',
ACCESS_TOKEN_SECRET='Your ACCESS_TOKEN_SECRET'</pre>
			<p>在 Next.js 中，所有的 API 都是在一个<code>/pages/api</code>文件夹中创建的<a id="_idIndexMarker1060"/>。Next.js 使用<code>pages/</code>文件夹中的文件结构来创建 URL 路由。例如，如果在<code>pages/</code>文件夹中有一个名为<code>login.js</code>的文件，那么<code>login.js</code>中的内容将在<code>http://localhost:3000/login</code>中呈现。</p>
			<p>前面的段落展示了如何基于文件名和结构在 Next.js 中为网页创建路由。这同样适用于在 Next.js 中创建 API。</p>
			<p>假设我们在<code>pages/api</code>中创建了一个用于在<code>signup.js</code>中注册的 API。这个 API 将在<code>http://localhost:3000/api/signup</code>中自动可用，如果我们要在应用本身中使用这个 API，我们可以像这样调用它:<code>/api/signup</code>。</p>
			<p>对于我们的<code>/api/tweet</code> API，让我们在<code>pages/api/</code>中创建一个名为<code>tweet.js</code>的文件，并按照以下步骤更新该文件:</p>
			<ol>
				<li>First, we import <code>twit.js</code>, and then create a function to clean each of the tweets:<pre>const Twit = require('twit')
function clean_tweet(tweet) {
  tweet = tweet.normalize("NFD") //normalize text
  tweet = tweet.replace(/(RT\s(@\w+))/g, '') //remove Rt tag followed by an @ tag
  tweet = tweet.replace(/(@[A-Za-z0-9]+)(\S+)/g, '') // remove user name e.g @name
  tweet = tweet.replace(/((http|https):(\S+))/g, '') //remove url
  tweet = tweet.replace(/[!#?:*%$]/g, '') //remove # tags
  tweet = tweet.replace(/[^\s\w+]/g, '') //remove punctuations
  tweet = tweet.replace(/[\n]/g, '') //remove newline
  tweet = tweet.toLowerCase().trim() //trim text
  return tweet
}</pre><p><code>clean_tweet</code>函数接收 tweet 文本中的<a id="_idIndexMarker1061"/>，规范化文本，删除标签字符、用户名、URL 链接和换行符，然后裁剪文本。</p></li>
				<li>We then create a function called <code>twitterApi</code>, which will be used to create our API:<pre>export default function twitterAPI(req, res) {
  // api code here
}</pre><p><code>twitterApi</code>函数接受两个参数，<code>req</code>和<code>res</code>，它们是服务器请求和响应参数。</p></li>
				<li>We will now update <code>twitterApi</code> with the necessary code:<pre>if (req.method === "POST") {
    const { username } = req.body
 
    const T = new Twit({
      consumer_key: process.env.CONSUMER_KEY,
      consumer_secret: process.env.CONSUMER_SECRET,
      access_token: process.env.ACCESS_TOKEN,
      access_token_secret: process.env.ACCESS_TOKEN_SECRET,
      timeout_ms: 60 * 1000,  // optional HTTP request timeout to apply to all requests.
      strictSSL: true,     // optional - requires SSL certificates to be valid.
    })
}</pre><p>首先，我们检查<code>req.method</code>请求方法是否是一个<code>POST</code>方法，然后我们从通过搜索框发送的<a id="_idIndexMarker1062"/>请求体中获取用户名。</p><p><code>Twit</code>类被实例化，我们的 Twitter API 键被传入。由于我们的 Twitter 开发者 API 密匙作为环境密匙存储在<code>.env.local</code>中，我们可以使用<code>process.env</code>轻松访问每个密匙。</p></li>
				<li>我们已经用 API 键配置了<code>twit.js</code>。现在让我们搜索所有提到某个用户的推文:<pre>T.get('search/tweets', { q: `@${username}`, tweet_mode: 'extended' }, function (err, data, response) {   let dfData = {     text: data.statuses.map(tweet =&gt; clean_tweet(tweet.full_text)),     length: data.statuses.map(tweet =&gt; clean_tweet(tweet.full_text).split(" ").length),     date: data.statuses.map(tweet =&gt; tweet.created_at),     source: data.statuses.map(tweet =&gt; tweet.source.replace(/&lt;(?:.|\n)*?&gt;/gm, '')),     likes: data.statuses.map(tweet =&gt; tweet.favorite_count),     retweet: data.statuses.map(tweet =&gt; tweet.retweet_count),     users: data.statuses.map(tweet =&gt; tweet.user.screen_name)   }   res.status(200).json(dfData) })</pre></li>
			</ol>
			<p>我们使用<code>T.get</code>方法中的<code>search/tweets</code> API 来搜索所有的 tweets。然后我们传入包含我们想要搜索的用户的用户名的<code>param</code>对象。</p>
			<p>一个<code>dfData</code>对象被创建来<a id="_idIndexMarker1063"/>基于我们想要的 API 输出响应来构造数据。<code>dfData</code>包含以下键，它们是我们想要从 tweet 中提取的元数据:</p>
			<ul>
				<li><code>text</code>:推文中的文字</li>
				<li><code>length</code>:推文的长度</li>
				<li><code>date</code>:推文发布的日期</li>
				<li><code>source</code>:用于创建推文的设备</li>
				<li><code>likes</code>:该推文的点赞数</li>
				<li><code>retweet</code>:这条推文的转发次数</li>
				<li><code>users</code>:创建推文的用户</li>
			</ul>
			<p>前面列表中的元数据是从前面代码的<code>T.get()</code>方法中的<code>search/tweets</code>返回的 JSON 数据中提取的。从这个 JSON 数据中提取的所有元数据都包含在一个名为<code>statuses</code>的对象数组中，下面显示了 JSON 数据的结构:</p>
			<pre>{
  statuses:[{
    ......
  },
    ......
  ]
}</pre>
			<p>Twitter API 已经创建好<a id="_idIndexMarker1064"/>并可以使用了。让我们继续创建情绪分析 API。</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor215"/>构建文本情感 API</h2>
			<p>从<code>/api/tweet</code> API 中，我们将获得结构化的 JSON 数据，然后执行<a id="_idIndexMarker1065"/>情感分析。</p>
			<p>对数据的情感分析将通过<code>/api/nlp</code>路线获取。因此，在这一节中，我们将看到如何为我们的 Twitter 数据创建一个情感分析 API。</p>
			<p>让我们在<code>/pages/api/</code>文件夹中创建一个名为<code>nlp.js</code>的文件，并按照以下步骤更新它:</p>
			<ol>
				<li value="1">我们将利用<code>nlp-node.js</code>软件包进行情感分析。我们还将利用<code>danfojs-node</code>进行数据预处理，所以让我们安装这两个包:<pre><strong class="bold">$ npm i node-nlp danfojs-node</strong></pre></li>
				<li>我们从<code>nlp-node</code>导入<code>SentimentAnalyzer</code>，从<code>danfojs-node</code> : <pre>const { SentimentAnalyzer } = require('node-nlp') const { DataFrame } = require("danfojs-node")</pre>导入<code>DataFrame</code></li>
				<li>接下来，我们将创建一个默认的<code>SentimentApi</code>导出函数，它将包含我们的 API 代码:<pre>export default async function SentimentApi(req, res) {    }</pre></li>
				<li>然后我们将检查请求方法是否是一个<code>POST</code>请求，然后对从请求体:<pre>if (req.method === "POST") {     const sentiment = new SentimentAnalyzer({ language: 'en' })     const { dfData, username } = req.body   //check if searched user is in the data     const df = new DataFrame(dfData)     let removeUserRow = df.query({       column: "users",       is: "!=",       to: username     })     //filter rows with tweet length &lt;=1     let filterByLength = removeUserRow.query({       column: "length",       is: "&gt;",       to: 1     }) . . . . . }</pre>获得的数据执行一些数据<a id="_idIndexMarker1066"/>预处理</li>
			</ol>
			<p>在前面的代码中，我们首先实例化了<code>SentimentAnalyzer</code>，然后将其语言配置设置为英语(<code>en</code>)。然后，我们从请求体获得了<code>dfData</code>和<code>username</code>。</p>
			<p>为了从数据中分析和创造洞察力，我们只想考虑用户与其他人的互动<a id="_idIndexMarker1067"/>而不是他们自己；也就是说，我们不想考虑用户自己回复的推文。因此，我们从<code>dfData</code>生成的数据帧中过滤出用户的回复。</p>
			<p>有时，一条推文会包含一个标签或者引用一个带有<code>@</code>符号的用户。然而，我们在之前的清理过程中移除了标签和<code>@</code>标志，这将导致一些推文最终不包含任何文本。因此，我们将创建一个新的包含非空文本的<code>filterBylength</code>数据框架:</p>
			<ol>
				<li value="1">We will move ahead to creating an object that will contain the overall sentiment count for the user's data and is sent to the frontend whenever we make a call to the API:<pre>let data = {
  positive: 0,
  negative: 0,
  neutral: 0
}
let sent = filterByLength["text"].values
for (let i in sent) {
  const getSent = await sentiment.getSentiment(sent[i])
  if (getSent.vote === "negative") {
    data.negative += 1
  } else if (getSent.vote === "positive") {
    data.positive += 1
  } else {
    data.neutral += 1
  }
}
res.status(200).json(data)</pre><p>在前面的代码中，我们创建了对象数据来存储整体情感分析。由于情感分析将只在来自<code>filterByLength</code>数据帧的文本数据上执行，我们提取文本列值。</p></li>
				<li>We then loop through the text column <a id="_idIndexMarker1068"/>values extracted and pass them into <code>sentiment.getSentiment</code>. For each piece of text passed into <code>sentiment.getSentiment</code>, the following types of objects are returned:<pre>{
  score: 2.593,
  numWords: 36,
  numHits: 8,
  average: 0.07202777777777777,
  type: 'senticon',
  locale: 'en',
  vote: 'positive'
}</pre><p>对于我们的用例，我们只需要<code>vote</code>的键值。因此，我们检查文本的<code>vote</code>值是<code>negative</code>、<code>positive</code>还是<code>neutral</code>，然后我们增加数据对象中每个键的计数。</p><p>因此，每当调用<code>/api/nlp</code>时，我们应该收到以下响应，例如:</p><pre>{
  positive: 20,
  negative: 12,
  neutral: 40
}</pre></li>
			</ol>
			<p>在本节中，我们看到了<a id="_idIndexMarker1069"/>如何在 Next.js 中创建 API，更重要的是，我们看到了在后端使用 Danfo.js 是多么方便。在下一节中，我们将实现应用程序的前端部分。</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor216"/>建筑前端</h1>
			<p>对于我们的前端设计，我们将<a id="_idIndexMarker1070"/>使用 Next.js 自带的默认 UI，如图<em class="italic">图 12.3 </em>所示。我们将为我们的前端实现以下一组<a id="_idIndexMarker1071"/>组件:</p>
			<ul>
				<li>组件:创建一个搜索框来搜索 Twitter 用户。</li>
				<li><code>ValueCount</code>组件:获取唯一值的计数，并使用条形图或饼图绘制出来。</li>
				<li><code>Plot</code>组件:该组件用于以条形图的形式绘制我们的情感分析。</li>
				<li><code>Table</code>组件:用于将获取的用户数据以表格的形式显示出来。</li>
			</ul>
			<p>在接下来的部分中，我们将实现前面的组件列表。让我们从实现<code>Search</code>组件开始。</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor217"/>创建搜索组件</h2>
			<p><code>Search</code>组件是<a id="_idIndexMarker1072"/>设置 app 运行的主要组件。它提供了输入域，可以在其中输入 Twitter 用户名，然后进行搜索。<code>search</code>组件使我们能够调用创建的两个 API:<code>/api/tweet</code>和<code>/api/nlp</code>。</p>
			<p>在我们的<code>twitterdashboard</code>项目目录中，让我们创建一个名为<code>components</code>的目录，在这个目录中，我们将创建一个名为<code>Search.js</code>的 JavaScript 文件。</p>
			<p>在<code>Search.js</code>中，我们输入以下代码:</p>
			<pre>import React from 'react'
export default function Search({ inputRef, handleKeyEvent, handleSubmit }) {
  return (
    &lt;div className='border-2 flex justify-between p-2 rounded-md  md:p-4'&gt;
      &lt;input id='searchInput' 
        type='text' 
        placeholder='Search twitter user' 
        className='focus:outline-none'
        ref={inputRef} 
        onKeyPress={handleKeyEvent}
      /&gt;
      &lt;button className='focus:outline-none' 
            onClick={() =&gt; { handleSubmit() }}&gt;
            &lt;img src="/search.svg" /&gt;
     &lt;/button&gt;
    &lt;/div&gt;
  )
}</pre>
			<p>在前面的代码中，我们用下面的一组属性创建了一个<code>Search</code>函数:</p>
			<ul>
				<li><code>inputRef</code>:这个道具是从<code>useRef</code>反应钩获得的。它将用于跟踪搜索输入字段的当前值。</li>
				<li><code>handleKeyEvent</code>:这是一个<a id="_idIndexMarker1073"/>事件函数，只要按下<em class="italic"> Enter </em>键，它就会被传递到搜索输入字段来启用搜索。</li>
				<li><code>handleSubmit</code>:此功能将在您点击搜索按钮时激活。<code>handleSubmit</code>函数负责调用我们的 API。</li>
			</ul>
			<p>让我们转到<code>/pages/index.js</code>，通过导入<code>Search</code>组件来更新文件，并根据以下步骤创建前面的所需道具列表:</p>
			<ol>
				<li value="1">首先，我们将导入 React、React 钩子和<code>Search</code>组件:<pre>import React, { useRef, useState } from 'react' import Search from '../components/Search'</pre></li>
				<li>然后，我们将创建一些状态集合:<pre>let [data, setData] = useState() // store tweet data from /api/tweet let [user, setUser] = useState() // store twitter usersname  let [dataNlp, setDataNlp] = useState() // store data from /api/nlp let inputRef = useRef() // monitor the current value of search input field</pre></li>
				<li>We will then create the <code>handleSubmit</code> function to make a call to our API and update the state data:<pre>const handleSubmit = async () =&gt; {
    const res = await fetch(
      '/api/tweet',
      {
        body: JSON.stringify({
        username: inputRef.current.value
        }),
        headers: {
        'Content-Type': 'application/json'
        },
        method: 'POST'
        }
    )
    const result = await res.json()
. . . . . . .
}</pre><p>首先，在<code>handleSubmit</code>中，我们调用<code>/api/tweet</code> API 来获取用户的数据。在<code>fetch</code>函数中，我们<a id="_idIndexMarker1074"/>获取<code>inputRef.current.value</code>搜索字段的当前值，并将其转换为 JSON 对象，该对象被传递到请求体中。然后使用一个变量结果从 API 获取 JSON 数据。</p></li>
				<li>We further update the <code>handleSubmit</code> function to fetch data from <code>/api/nlp</code>:<pre>const resSentiment = await fetch(
      '/api/nlp',
      {
        body: JSON.stringify({
        username: inputRef.current.value,
        dfData: result
        }),
        headers: {
        'Content-Type': 'application/json'
        },
        method: 'POST'
    },
    )
const sentData = await resSentiment.json()</pre><p>前面的代码与<em class="italic">步骤 3 </em>中的代码相同。唯一的区别是我们调用了<code>/api/nlp</code> API，然后将来自<em class="italic">步骤 3 </em>的结果数据和从搜索输入字段获得的用户名传递到请求体中。</p></li>
				<li>然后我们更新<code>handleSubmit</code>中的<a id="_idIndexMarker1075"/>以下状态:<pre>setDataNlp(sentData) setUser(inputRef.current.value) setData(result)</pre></li>
				<li>Next, we will create the <code>handleKeyEvent</code> function to enable search by pressing the <em class="italic">Enter</em> key:<pre>const handleKeyEvent = async (event) =&gt; {
    if (event.key === 'Enter') {
      await handleSubmit()
    }
  }</pre><p>在前面的代码中，我们检查按键是否是一个<em class="italic"> Enter </em>键，如果是，我们调用<code>handleSubmit</code>函数。</p></li>
				<li>最后，我们调用我们的<code>Search</code>组件:<pre>&lt;Search inputRef={inputRef} handleKeyEvent={handleKeyEvent} handleSubmit={handleSubmit} /&gt;</pre></li>
			</ol>
			<p>记住，我们说过我们将使用 Next.js 的默认 UI。因此，在<code>index.js</code>中，让我们将<code>Welcome to Next.js</code>转换为<code>Welcome to Twitter Dashboard</code>。</p>
			<p>更新<code>index.js</code>后，您可以在<code>http://localhost:3000/</code>查看浏览器的更新。您将看到以下变化:</p>
			<div><div><img src="img/B17076_12_04.jpg" alt="Figure 12.4 – index.js updated with the search component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.4–使用搜索组件更新的 index.js</p>
			<p><code>Search</code>组件<a id="_idIndexMarker1076"/>被实现并注入到主 app 中，所有需要的状态数据都可以通过<code>Search</code>组件轻松更新。让我们继续实现<code>ValueCounts</code>组件。</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor218"/>创建 ValueCounts 组件</h2>
			<p>我们将为从<code>/api/tweet</code>获得的数据创建一个<a id="_idIndexMarker1077"/>简单分析。这种分析包括检查列中唯一值存在的次数。我们将获得<code>source</code>列和<code>users</code>列的值计数。</p>
			<p>来自<code>source</code>列的值计数告诉我们其他 Twitter 用户用来与我们搜索的用户交互的设备。来自<code>users</code>列的值计数告诉我们与我们搜索的用户交互最多的用户。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">这里使用的代码是从<a href="B17076_08_ePub_RK.xhtml#_idTextAnchor149"> <em class="italic">第八章</em> </a>、<em class="italic">创建无代码数据分析/处理系统</em>中<em class="italic">实现图表组件</em>部分复制的。这一节的代码可以在这里获得:<a href="https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js">https://github . com/packt publishing/Building-Data-Driven-Applications-with-danfo . js-/blob/main/chapter 12/components/value counts . js</a>。大部分代码这里就不详细解释了。</p>
			<p>让我们转到<code>components/</code>目录，创建一个名为<code>ValueCounts.js</code>的文件，然后按照以下步骤更新它:</p>
			<ol>
				<li value="1">首先，我们导入<a id="_idIndexMarker1078"/>必需的模块:<pre>import React from "react" import { DataFrame } from 'danfojs/src/core/frame' import { Pie as PieChart } from "react-chartjs-2"; import { Bar as BarChart } from 'react-chartjs-2';</pre></li>
				<li>Then, we create a function called <code>ValueCounts</code>:<pre>export default function ValueCounts({ data, column, username, type }) {
  
}</pre><p>该函数接受以下属性:</p><p>a) <code>data</code>:这是来自<code>/api/tweet</code>的数据。</p><p>b) <code>column</code>:我们要从中获取值计数的列的名称。</p><p>c) <code>username</code>:从搜索栏输入的用户名。</p><p>d) <code>type</code>:我们要绘制的图表类型。</p></li>
				<li>Next, we<a id="_idIndexMarker1079"/> update the <code>ValueCounts</code> function:<pre>const df = new DataFrame(data)
const removeUserData = df.query({
  column: "users",
  is: "!=",
  to: username
})
const countsSeries = removeUserData[column].value_counts()
const labels = countsSeries.index
const values = countsSeries.values</pre><p>在前面的代码中，我们首先从数据中创建一个 DataFrame，然后过滤掉包含被搜索用户的行，因为我们不希望 tweets 中出现用户与自己交互的情况。然后，我们从传入的列中提取<code>value_counts</code>值。从创建的<code>countSeries</code>变量，我们生成我们的标签和值，我们将使用它们来绘制我们的图表。</p></li>
				<li>We then create a chart data variable called <code>dataChart</code>, which will be in the format accepted by the <code>chart</code> component:<pre>const dataChart = {
    labels: labels,
    datasets: [{
      . . . . 
      data: values,
    }]
  };</pre><p><code>dataChart</code>对象包含在<em class="italic">步骤 3 </em>中创建的标签和值。</p></li>
				<li>We create a conditional<a id="_idIndexMarker1080"/> rendering to check the type of chart to plot:<pre>if (type === "BarChart") {
   return (
     &lt;div className="max-w-md"&gt;
     &lt;BarChart data={dataChart} options={options} width="100" height="100" /&gt;
     &lt;/div&gt;
)
} else {
  return (&lt;div className="max-w-md"&gt;
        &lt;PieChart data={dataChart} options={options} width="100" height="100" /&gt;
    &lt;/div&gt;)
}</pre><p><code>ValueCounts</code>组件被设置。</p></li>
			</ol>
			<p>我们现在可以使用以下步骤将<code>ValueCounts</code>组件导入到<code>index.js</code>中:</p>
			<ol>
				<li value="1">We import <code>ValueCounts</code>:<pre>import dynamic from 'next/dynamic'
const DynamicValueCounts = dynamic(
  () =&gt; import('../components/ValueCounts'),
  { ssr: false }
)</pre><p>我们导入<code>ValueCounts</code>的方式不同于导入<code>Search</code>组件的方式。这是因为在<code>ValueCounts</code>中，我们在 TensorFlow.js 中使用了一些核心的浏览器专用工具，这在 Danfo.js 中是必需的，因此，我们需要阻止 Next.js 从服务器渲染组件，以防止出现错误。</p><p>为了防止 Next.js 渲染来自服务器的组件，我们使用了<code>next/dynamic</code>，然后我们将要导入的组件包装在<code>dynamic</code>函数中，作为<a id="_idIndexMarker1081"/>，并将<code>ssr</code>键设置为<code>false</code>。</p><p class="callout-heading">注意</p><p class="callout">要了解更多关于<code>next/dynamic</code>的信息，请查看<a href="https://nextjs.org/docs/advanced-features/dynamic-import">https://nextjs.org/docs/advanced-features/dynamic-import</a>。</p></li>
				<li>We make a call to the <code>ValueCounts</code> component, which is now named <code>DynamicValueCounts</code>:<pre>{typeof data != "undefined" &amp;&amp; &lt;DynamicValueCounts data={data} column={"source"} type={"PieChart"} /&gt;}</pre><p>我们检查状态数据是否未定义，以及用户数据是否已从<code>/api/tweet</code>中提取。如果是这样，我们为<code>source</code>列呈现<code>ValueCounts</code>组件。</p></li>
				<li>Let's also add <code>ValueCounts</code> for the <code>users</code> column:<pre>{typeof data != "undefined" &amp;&amp; &lt;DynamicValueCounts data={data} column={"users"} username={user} type={"BarChart"} /&gt;}</pre><p>我们为用户的<code>ValueCounts</code>图表指定<code>BarChart</code>，为<code>ValueCounts</code>源指定<code>PieChart</code>。</p></li>
			</ol>
			<p>下图显示了每当搜索用户时，源和用户交互的<code>ValueCounts</code>显示:</p>
			<div><div><img src="img/B17076_12_05.jpg" alt="Figure 12.5 – ValueCounts chart result for the source and user columns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.5–源和用户列的值计数图表结果</p>
			<p>数值计算完成，并且<a id="_idIndexMarker1082"/>工作正常。让我们继续为从<code>/api/nlp</code>获得的情感分析数据创建一个图表。</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor219"/>创建用于情感分析的情节组件</h2>
			<p>当通过使用搜索字段搜索用户时<a id="_idIndexMarker1083"/>，更新<code>sentiData</code>状态以包含来自<code>/api/nlp</code>的情感数据。在本节中，我们将为数据创建一个<code>Plot</code>组件。</p>
			<p>让我们在<code>components/</code>目录中创建一个<code>Plot.js</code>文件，并按照以下步骤更新它:</p>
			<ol>
				<li value="1">首先，我们导入所需的模块:<pre>import React from "react" import { Bar as BarChart } from 'react-chartjs-2';</pre></li>
				<li>We then create a <code>Plot</code> function to plot a chart for sentiment data:<pre>export default function Plot({ data }) {
  const dataChart = {
    labels: Object.keys(data),
    datasets: [{
    . . . . . . . .
    data: Object.values(data),
    }]
  };
  return (
    &lt;div className="max-w-md"&gt;
      &lt;BarChart data={dataChart} options={options} width="100" height="100" /&gt;
    &lt;/div&gt;
  )
}</pre><p>该函数接受一个<code>data</code>道具。然后我们创建一个包含<code>chart</code>组件格式的<code>dataChart</code>对象。我们通过获取<code>data</code>属性中的键来指定图表标签，并通过获取<code>data</code>属性的值来指定<code>dataChart</code>中的关键数据的值。<code>dataChart</code>对象被传入<code>BarChart</code>组件。现在已经为情绪分析图表创建了<code>Plot</code>组件。</p></li>
				<li>下一步是<a id="_idIndexMarker1084"/>在<code>index.js</code>中导入<code>Plot</code>组件，并调用它:<pre>import Plot from '../components/Plot' . . . . . .    {typeof dataNlp != "undefined" &amp;&amp; &lt;Plot data={dataNlp} /&gt;}</pre></li>
			</ol>
			<p>有了<code>index.js</code>中的更新，每当我们搜索一个用户时，我们都会看到下面的情感分析图表:</p>
			<div><div><img src="img/B17076_12_06.jpg" alt="Figure 12.6 – Sentiment analysis chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.6–情绪分析图表</p>
			<p>情感分析已完成<a id="_idIndexMarker1085"/>并完全整合到<code>index.js</code>中。让我们继续创建<code>Table</code>组件来显示我们的用户数据。</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor220"/>创建表格组件</h2>
			<p>我们将<a id="_idIndexMarker1086"/>实现一个<code>Table</code>组件来显示获得的数据。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">表的实现与<a href="B17076_08_ePub_RK.xhtml#_idTextAnchor149"> <em class="italic">第 8 章</em> </a>、<em class="italic">创建无代码数据分析/处理系统</em>中创建的数据表实现相同。为了更好地解释代码，请查看第 8 章 、<em class="italic">创建无代码数据分析/处理系统</em>。</p>
			<p>让我们在<code>components/</code>目录中创建一个<code>Table.js</code>文件，并按照以下步骤更新该文件:</p>
			<ol>
				<li value="1">我们导入必要的模块:<pre>import React from "react"; import ReactTable from 'react-table-v6' import { DataFrame } from 'danfojs/src/core/frame' import 'react-table-v6/react-table.css'</pre></li>
				<li>We create a function called <code>Table</code>:<pre>export default function DataTable({ dfData, username }) {
  
}</pre><p>该函数接受<code>dfData</code>(来自<code>/api/nlp</code>的情感数据)和<code>username</code>(来自搜索字段)作为道具。</p></li>
				<li>We update the function with the following code:<pre>const df = new DataFrame(dfData)
const removeUserData = df.query({
  column: "users",
  is: "!=",
  to: username
})
const columns = removeUserData.columns
const values = removeUserData.values</pre><p>我们从<code>dfData</code>创建一个数据帧，过滤出包含用户推文的行，然后提取数据帧的列名和值。</p></li>
				<li>然后我们以<code>ReactTable</code> : <pre>const dataColumns = columns.map((val, index) =&gt; {     return {       Header: val,       accessor: val,       Cell: (props) =&gt; (         &lt;div className={val || ''}&gt;         &lt;span&gt;{props.value}&lt;/span&gt;         &lt;/div&gt;       ),       . . . . . .     }   });</pre>接受的格式格式化这个<a id="_idIndexMarker1087"/>列</li>
				<li>We also format the values to be accepted by <code>ReactTable</code>:<pre>const data = values.map(val =&gt; {
    let rows_data = {}
    val.forEach((val2, index) =&gt; {
      let col = columns[index];
      rows_data[col] = val2;
    })
    return rows_data;
  })</pre><p>再次，在<a href="B17076_08_ePub_RK.xhtml#_idTextAnchor149"> <em class="italic">第 8 章</em> </a>、<em class="italic">创建无代码数据分析/处理系统</em>中详细解释了<em class="italic">步骤 4 </em>、<em class="italic"> 5 </em>和<em class="italic"> 6 </em>中的代码。</p></li>
				<li>We then make a call to <a id="_idIndexMarker1088"/>the <code>ReactTable</code> component and pass in <code>dataColumns</code> and <code>data</code>:<pre>&lt;ReactTable
  data={data}
  columns={dataColumns}
  getTheadThProps={() =&gt; {
    return { style: { wordWrap: 'break-word', whiteSpace: 'initial' } }
  }}
  showPageJump={true}
  showPagination={true}
  defaultPageSize={10}
  showPageSizeOptions={true}
  minRows={10}
/&gt;</pre><p><code>table</code>组件完成；下一步是在 Next.js 中导入组件，然后调用该组件。</p><p>注意，由于我们使用的是 Danfo.js 的 web 版本，我们需要用<code>next/dynamic</code>加载这个组件，以防止应用程序崩溃:</p><pre>const Table = dynamic(
  () =&gt; import('../components/Table'),
  { ssr: false }
)
. . . . . . .
{typeof data != "undefined" &amp;&amp; &lt;Table dfData={data} username={user} /&gt;}</pre></li>
			</ol>
			<p>在前面的代码中，我们<a id="_idIndexMarker1089"/>动态导入了<code>Table</code>组件，并在其中实例化了<code>Table</code>组件，并传入了<code>dfData</code>和<code>username</code>属性值。</p>
			<p>如果您切换到您的浏览器并转到项目的<code>localhost</code>端口，您应该会看到完整更新的应用程序，如以下截图所示:</p>
			<div><div><img src="img/B17076_12_07.jpg" alt="Figure 12.7 – Extracted user data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.7-提取的用户数据</p>
			<p>应用程序<a id="_idIndexMarker1090"/>的最终结果应该如下所示:</p>
			<div><div><img src="img/B17076_12_08.jpg" alt="Figure 12.8 – Twitter user dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 12.8–Twitter 用户仪表板</p>
			<p>在本节中，我们为前端实现构建了不同的<a id="_idIndexMarker1091"/>组件。我们看到了如何在 Next.js 中使用 Danfo.js，也了解了如何使用<code>next/dynamic</code>加载组件。</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor221"/>总结</h1>
			<p>在本章中，我们看到了如何利用 Next.js 构建一个快速的全栈应用程序。我们看到了如何在后端利用 Danfo.js 节点，我们还使用了 JavaScript 包，如 twit.js 和<code>nlp-node</code>来获取 Twitter 数据并执行情感分析。</p>
			<p>我们还看到了如何轻松地用 Next.js 注入 Danfo.js，以及如何通过用<code>next/dynamic</code>加载组件来防止错误。</p>
			<p>这一章的目标是让你看到如何轻松地使用 Danfo.js 来构建一个完整的栈(后端和前端)数据驱动的应用程序，我相信这在这一章中已经很好地实现了。</p>
			<p>我相信我们在这本书里已经涵盖了很多，从 Danfo.js 的介绍到用 Danfo.js 构建无代码环境，再到构建推荐系统和 Twitter 分析仪表板。从 Danfo.js 与各种 JavaScript 框架的各种用例中，我们能够构建一个分析平台和机器学习驱动的 web 应用。</p>
			<p>我们已经到了这本书的结尾，我相信我们现在已经具备了在我们的下一个 web 应用程序中包括数据分析和机器学习的技能，也为 Danfo.js 做出了贡献。</p>
		</div>
	

</body></html>