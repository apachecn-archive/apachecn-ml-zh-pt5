<html><head/><body>



<title>Chapter 7. Clustering Data</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07"/>第七章。聚类数据</h1></div></div></div><p>我们现在将把注意力转移到<strong>无监督学习</strong>。在这一章中，我们将研究几种<strong>聚类</strong>算法，或<strong>聚类器</strong> <a id="id611" class="indexterm"/>，以及我们如何在 Clojure 中实现它们。我们还将演示几个 Clojure 库，它们提供了集群算法的实现。在这一章的结尾，我们将探索 will<strong>dimensionality</strong><strong>reduction</strong>以及如何使用它来提供所提供的样本数据的可理解的可视化。</p><p>聚类或<strong>聚类分析</strong>基本上是一种将<a id="id612" class="indexterm"/>数据或样本分组在一起的方法。作为无监督学习的一种形式，聚类模型是使用未标记的数据来训练的，这意味着训练数据中的样本将不包含输入值的类或类别。相反，训练数据不描述给定输入集的输出变量值。聚类分析模型必须确定几个输入值之间的相似性，并自己推断这些输入值的类别。因此，可以使用这种模型将样本值划分成多个聚类。</p><p>聚类在现实世界的问题中有几个实际应用。聚类通常用于图像分析、图像分割、软件进化系统和社会网络分析。在计算机科学领域之外，聚类算法用于生物分类、基因分析和犯罪分析。</p><p>到目前为止，已经公布了几种聚类算法。对于如何定义聚类以及如何将输入值合并到新的聚类中，每种算法都有独特的概念。不幸的是，对于任何聚类问题都没有给定的解决方案，每个算法都必须在反复试验的基础上进行评估，以确定哪个模型最适合所提供的训练数据。当然，这是无监督学习的一个方面，在这个意义上，没有明确的方法可以说给定的解决方案最适合任何给定的数据。</p><p>这是因为输入数据是未标记的，并且不能容易地从输出变量或输入值类别未知的数据中推断出简单的基于是/否的奖励系统来训练。</p><p>在这一章中，我们将描述一些可以应用于未标记数据的聚类技术。</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>使用 K 均值聚类</h1></div></div></div><p><strong> K 均值聚类</strong>算法<a id="id613" class="indexterm"/>是一种基于矢量量化的聚类技术(有关更多信息，请参考“算法 AS 136: A K 均值聚类算法”)。该算法将多个样本向量划分成<em> K </em>个簇，并因此得名。在这一节中，我们将研究 K-means 算法的本质和实现。</p><p><strong>量化</strong>，在信号处理中，是将一大组数值映射成一组较小数值的过程。例如，模拟信号可以量化为 8 位，信号可以用 256 级量化来表示<a id="id614" class="indexterm"/>。假设位代表 0 到 5 伏范围内的值，8 位量化允许每位 5/256 伏的分辨率。在群集环境中，输入或输出<a id="id615" class="indexterm"/>的量化可基于以下原因进行:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">将聚类限制到有限的聚类集。</li><li class="listitem" style="list-style-type: disc">以容纳样本数据中的一系列值，这些值在执行聚类时需要具有一定程度的容差。这种灵活性对于将未知或意外的样本值分组至关重要。</li></ul></div><p>该算法的要点可以简明地描述如下。首先随机初始化<em> K </em>平均值，或<em>质心</em>。然后计算每个样本值离每个质心的距离。根据哪个质心与给定样本的距离<a id="id616" class="indexterm"/>最小，样本值被分组到给定质心的簇中。在多个特征或输入值的多维空间中，样本输入向量的距离由输入向量和给定质心之间的欧几里德距离来测量。该算法的这个阶段被称为<strong>分配步骤</strong>。</p><p><em> K </em> -means 算法的下一阶段是<strong>更新步骤</strong> <a id="id618" class="indexterm"/>。基于前一步骤生成的分区输入值来调整质心的值。然后重复这两个步骤，直到两次连续迭代中的质心值之间的差异变得可以忽略。因此，算法的最终结果是给定训练数据中每组输入值的聚类或类。</p><p>由<em> K </em> -means 算法执行的迭代<a id="id619" class="indexterm"/>可以使用下面的图来说明:</p><div><img src="img/4351OS_07_01.jpg" alt="Using K-means clustering"/></div><p>每个图描绘了对于给定的一组输入值，由算法的每次迭代产生的质心和分区样本值。给定迭代中的分类在每个图中以不同的颜色显示。最终图表示由<em> K </em>均值算法产生的最终分割输入值集。</p><p><em> K </em>均值聚类算法的优化目标<a id="id620" class="indexterm"/>可以形式化定义如下:</p><div><img src="img/4351OS_07_02.jpg" alt="Using K-means clustering"/></div><p>在前一等式中定义的优化问题中，术语<img src="img/4351OS_07_03.jpg" alt="Using K-means clustering"/>代表<em>K</em>-输入值围绕其聚集的平均值。<em> K </em> -means 算法最小化聚类的大小，并确定这些聚类的大小可以最小化的平均值。</p><p>该算法需要<img src="img/4351OS_07_04.jpg" alt="Using K-means clustering"/>样本值和<img src="img/4351OS_07_05.jpg" alt="Using K-means clustering"/>初始平均值作为输入。在分配步骤中，输入值被分配给提供给算法的初始平均值周围的聚类。在<a id="id621" class="indexterm"/>后续更新步骤中，从输入值计算新的平均值。在大多数实现中，新平均值是作为属于给定聚类的所有输入值的平均值来计算的。</p><p>大多数实现将<img src="img/4351OS_07_05.jpg" alt="Using K-means clustering"/>初始平均值初始化为一些随机选择的输入值。这种技术被称为随机初始化的<strong> Forgy 方法</strong> <a id="id622" class="indexterm"/>。</p><p>当聚类数<em> K </em>或输入数据<em> d </em>中的维数未绑定时，<em> K </em>均值算法是 NP 难的。当这两个值都固定时，<em> K </em> -means 算法的时间复杂度为<img src="img/4351OS_07_06.jpg" alt="Using K-means clustering"/>。该算法有几种变体，它们在新平均值的计算方式上有所不同。</p><p>我们现在将演示如何在不使用外部库的情况下，在纯 Clojure 中实现<em> K </em> -means 算法。<a id="id623" class="indexterm"/>我们首先定义算法的各个部分，然后将它们组合起来，提供一个基本的<em> K </em>均值算法的可视化。</p><p>我们可以说两个数字之间的距离是它们的值之间的绝对差，这可以作为一个<code class="literal">distance</code>函数来实现，如下面的代码所示:</p><div><pre class="programlisting">(defn distance [a b]
  (if (&lt; a b) (- b a) (- a b)))</pre></div><p>如果给我们一些平均值，我们可以通过使用<code class="literal">distance</code>和<code class="literal">sort-by</code>函数的组合来计算给定数字的最接近平均值，如下面的代码所示:</p><div><pre class="programlisting">(defn closest [point means distance]
  (first (sort-by #(distance % point) means)))</pre></div><p>为了演示前面代码中定义的<code class="literal">closest</code>函数，我们首先需要定义一些数据，即一系列数字和几个平均值，如下面的代码所示:</p><div><pre class="programlisting">(def data '(2 3 5 6 10 11 100 101 102))
(def guessed-means '(0 10))</pre></div><p>我们现在可以将<code class="literal">data</code>和<code class="literal">guessed-means</code>变量与<code class="literal">closest</code>函数和任意数字一起使用，如以下 REPL 输出所示:</p><div><pre class="programlisting">user&gt; (closest 2 guessed-means distance)
0
user&gt; (closest 9 guessed-means distance)
10
user&gt; (closest 100 guessed-means distance)
10</pre></div><p>给定均值<code class="literal">0</code>和<code class="literal">10</code>，函数<code class="literal">closest</code>返回<code class="literal">0</code>作为最接近<code class="literal">2</code>的均值，返回<code class="literal">10</code>作为<code class="literal">9</code>和<code class="literal">100</code>的均值。因此，一组数据点可以按照最接近它们的平均值进行分组。我们可以使用<code class="literal">closest</code>和<code class="literal">group-by</code>函数实现一个函数来实现这个分组操作，如下所示:</p><div><pre class="programlisting">(defn point-groups [means data distance]
  (group-by #(closest % means distance) data))</pre></div><p>前面代码中定义的<code class="literal">point-groups</code>函数<a id="id624" class="indexterm"/>需要三个参数，即初始平均值、要分组的点的集合，以及最后一个返回一个点到给定平均值的距离的函数。请注意，<code class="literal">group-by</code>函数将作为第一个参数传递的函数应用到一个集合，然后该集合作为第二个参数传递。</p><p>我们可以在由<code class="literal">data</code>变量表示的数字列表上应用<code class="literal">point-groups</code>函数，根据给定值与由<code class="literal">guessed-means</code>表示的猜测平均值的距离对其进行分组，如以下代码所示:</p><div><pre class="programlisting">user&gt; (point-groups guessed-means data distance)
{0 [2 3 5], 10 [6 10 11 100 101 102]}</pre></div><p>如前面的代码所示，<code class="literal">point-groups</code>函数将序列<code class="literal">data</code>分成两组。为了从这些组输入值中计算出新的一组平均值，我们必须计算它们的平均值，这可以使用<code class="literal">reduce</code>和<code class="literal">count</code>函数来实现，如下面的代码所示:</p><div><pre class="programlisting">(defn average [&amp; list]
  (/ (reduce + list)
     (count list)))</pre></div><p>我们实现了一个函数，将前面代码中定义的<code class="literal">average</code>函数应用于之前的平均值和<a id="id625" class="indexterm"/>函数返回的组映射。我们将借助以下代码来实现这一点:</p><div><pre class="programlisting">(defn new-means [average point-groups old-means]
  (for [m old-means]
    (if (contains? point-groups m)
      (apply average (get point-groups m)) 
      m)))</pre></div><p>在前面代码中定义的<code class="literal">new-means</code>函数中，对于前面平均值中的每个值，我们将<code class="literal">average</code>函数应用于按平均值分组的点。当然，<code class="literal">average</code>函数必须应用于给定平均值的点，前提是该平均值有任何按其分组的点。使用<code class="literal">new-means</code>功能中的<code class="literal">contains?</code>功能进行检查。我们可以在 REPL 的样本数据上检查由<code class="literal">new-means</code>函数返回的值，如下面的输出所示:</p><div><pre class="programlisting">user&gt; (new-means average
        (point-groups guessed-means data distance)
                 guessed-means)
(10/3 55)</pre></div><p>如前面的输出所示，新的平均值是根据初始平均值<code class="literal">(0 10)</code>计算出来的<code class="literal">(10/3 55)</code>。为了实现<em> K </em> -means 算法，我们必须对其返回的新平均值迭代应用<code class="literal">new-means</code>函数。这个迭代可以使用<code class="literal">iterate</code>函数来执行，它需要一个接受传递给它的单个参数的函数。</p><p>我们可以定义一个函数与<code class="literal">iterate</code>函数一起使用，方法是将<code class="literal">new-means</code>函数转换为传递给它的旧平均值，如以下代码所示:</p><div><pre class="programlisting">(defn iterate-means [data distance average]
  (fn [means]
    (new-means average
               (point-groups means data distance)
               means)))</pre></div><p>前面代码中定义的<code class="literal">iterate-means</code>函数<a id="id626" class="indexterm"/>返回一个函数，该函数根据一组给定的初始平均值计算新的平均值，如以下输出所示:</p><div><pre class="programlisting">user&gt; ((iterate-means data distance average) '(0 10))
(10/3 55)
user&gt; ((iterate-means data distance average) '(10/3 55))
(37/6 101)</pre></div><p>如前面的输出所示，在应用由<code class="literal">iterate-means</code>函数返回的函数几次后，观察到平均值发生了变化。这个返回的函数可以传递给<code class="literal">iterate</code>函数，我们可以使用<code class="literal">take</code>函数检查迭代的平均值，如下面的代码所示:</p><div><pre class="programlisting">user&gt; (take 4 (iterate (iterate-means data distance average)
                       '(0 10)))
((0 10) (10/3 55) (37/6 101) (37/6 101))</pre></div><p>据观察，平均<a id="id627" class="indexterm"/>值仅在前三次迭代中变化，并收敛于我们定义的样本数据的值<code class="literal">(37/6 10)</code>。<em> K </em> -means 算法的终止条件是平均值的收敛，因此我们必须迭代<code class="literal">iterate-means</code>函数返回的值，直到返回的平均值与之前返回的平均值没有不同。由于<code class="literal">iterate</code>函数延迟返回一个无限序列，我们必须实现一个函数，通过序列中元素的收敛来限制这个序列。这种行为可以通过使用<code class="literal">lazy-seq</code>和<code class="literal">seq</code>函数的延迟实现来实现，如以下代码所示:</p><div><pre class="programlisting">(defn take-while-unstable
  ([sq] (lazy-seq (if-let [sq (seq sq)]
                    (cons (first sq)
                          (take-while-unstable 
                           (rest sq) (first sq))))))
  ([sq last] (lazy-seq (if-let [sq (seq sq)]
                         (if (= (first sq) last)
                           nil
                           (take-while-unstable sq))))))</pre></div><p>在前面的代码中定义的<code class="literal">take-while-unstable</code>函数<a id="id628" class="indexterm"/>将一个惰性序列拆分为头项和尾项，然后将序列的第一个元素与序列尾部的第一个元素进行比较，以返回一个空列表，如果两个元素相等，则返回<code class="literal">nil</code>。然而，如果它们不相等，则在序列的尾部再次调用<code class="literal">take-while-unstable</code>功能。注意<code class="literal">if-let</code>宏的使用，它只是一个<code class="literal">let</code>表单，以一个<code class="literal">if</code>表达式为主体来检查序列<code class="literal">sq</code>是否为空。我们可以检查 REPL 中<code class="literal">take-while-unstable</code>函数返回的值，如下图所示:</p><div><pre class="programlisting">user&gt; (take-while-unstable
       '(1 2 3 4 5 6 7 7 7 7))
(1 2 3 4 5 6 7)
user&gt; (take-while-unstable 
       (iterate (iterate-means data distance average)
                '(0 10)))
((0 10) (10/3 55) (37/6 101))</pre></div><p>使用我们计算的最终平均值<a id="id629" class="indexterm"/>，我们可以在由<code class="literal">point-groups</code>函数返回的地图上使用<code class="literal">vals</code>函数来确定输入值的聚类，如以下代码所示:</p><div><pre class="programlisting">(defn k-cluster [data distance means]
  (vals (point-groups means data distance)))</pre></div><p>注意，<code class="literal">vals</code>函数以序列形式返回给定映射中的所有值。</p><p>前面代码中定义的<code class="literal">k-cluster</code>函数产生由<em> K </em> -means 算法返回的输入值的最终聚类。我们可以对最终平均值<code class="literal">(37/6 101)</code>应用<code class="literal">k-cluster</code>函数，以返回输入值的最终聚类，如以下输出所示:</p><div><pre class="programlisting">user&gt; (k-cluster data distance '(37/6 101))
([2 3 5 6 10 11] [100 101 102])</pre></div><p>为了可视化输入值聚类中的变化，我们可以对通过组合<code class="literal">iterate</code>和<code class="literal">iterate-means</code>函数返回的值序列应用<code class="literal">k-cluster</code>函数。我们必须通过收敛所有聚类中的值来限制该序列，这可以使用<code class="literal">take-while-unstable</code>函数<a id="id630" class="indexterm"/>来完成，如以下代码所示:</p><div><pre class="programlisting">user&gt; (take-while-unstable
       (map #(k-cluster data distance %)
            (iterate (iterate-means data distance average)
             '(0 10))))
(([2 3 5] [6 10 11 100 101 102])
 ([2 3 5 6 10 11] [100 101 102]))</pre></div><p>我们可以将前面的表达式重构为一个函数，通过将<code class="literal">iterate-means</code>函数绑定到样本数据，该函数只需要猜测平均值的初始集合。用于计算给定输入值与平均值的距离以及一组输入值的平均平均值的函数如以下代码所示:</p><div><pre class="programlisting">(defn k-groups [data distance average]
  (fn [guesses]
    (take-while-unstable
     (map #(k-cluster data distance %)
          (iterate (iterate-means data distance average)
                   guesses)))))</pre></div><p>我们可以将前面代码中定义的<code class="literal">k-groups</code>函数与我们的示例数据以及<code class="literal">distance</code>和<code class="literal">average</code>函数绑定，它们对数值进行操作，如下面的代码所示:</p><div><pre class="programlisting">(def grouper
  (k-groups data distance average))</pre></div><p>现在，我们可以对任意一组平均值应用<code class="literal">grouper</code>函数<a id="id631" class="indexterm"/>来可视化<a id="id632" class="indexterm"/>在<em> K </em> -means 算法的各次迭代中聚类的变化，如以下代码所示:</p><div><pre class="programlisting">user&gt; (grouper '(0 10))
(([2 3 5] [6 10 11 100 101 102])
 ([2 3 5 6 10 11] [100 101 102]))
user&gt; (grouper '(1 2 3))
(([2] [3 5 6 10 11 100 101 102])
 ([2 3 5 6 10 11] [100 101 102])
 ([2 3] [5 6 10 11] [100 101 102])
 ([2 3 5] [6 10 11] [100 101 102])
 ([2 3 5 6] [10 11] [100 101 102]))
user&gt; (grouper '(0 1 2 3 4))
(([2] [3] [5 6 10 11 100 101 102])
 ([2] [3 5 6 10 11] [100 101 102])
 ([2 3] [5 6 10 11] [100 101 102])
 ([2 3 5] [6 10 11] [100 101 102])
 ([2] [3 5 6] [10 11] [100 101 102])
 ([2 3] [5 6] [10 11] [100 101 102]))</pre></div><p>正如我们前面提到的，如果平均值的数量大于输入值的数量，我们最终得到的聚类数量等于输入值的数量，其中每个聚类包含一个输入值。这可以在 REPL 中使用<code class="literal">grouper</code>函数进行验证，如以下代码所示:</p><div><pre class="programlisting">user&gt; (grouper (range 200))
(([2] [3] [100] [5] [101] [6] [102] [10] [11]))</pre></div><p>我们可以通过改变<code class="literal">distance</code>和<code class="literal">average</code>距离(它们是<code class="literal">k-groups</code>函数的参数)来扩展前面的实现，以应用于向量值而不仅仅是数值。我们可以为向量值实现这两个函数，如下所示:</p><div><pre class="programlisting">(defn vec-distance [a b]
  (reduce + (map #(* % %) (map - a b))))

(defn vec-average [&amp; list]
  (map #(/ % (count list)) (apply map + list)))</pre></div><p>前面代码中定义的<code class="literal">vec-distance</code>函数<a id="id633" class="indexterm"/>将两个向量值之间的平方欧几里德距离实现为两个向量中相应元素之间的平方差之和。我们还可以计算一些向量值的平均值，方法是将它们加在一起，然后将每个结果元素除以加在一起的向量的数量<a id="id634" class="indexterm"/>，如前面代码中定义的<code class="literal">vec-average</code>函数所示。我们可以检查 REPL 中这些函数的返回值，如下图所示:</p><div><pre class="programlisting">user&gt; (vec-distance [1 2 3] [5 6 7])
48
user&gt; (vec-average  [1 2 3] [5 6 7])
(3 4 5)</pre></div><p>现在，我们可以定义以下一些向量值，用作聚类算法的样本数据:</p><div><pre class="programlisting">(def vector-data
  '([1 2 3] [3 2 1] [100 200 300] [300 200 100] [50 50 50]))</pre></div><p>我们现在可以使用带有<code class="literal">vector-data</code>、<code class="literal">vec-distance</code>和<code class="literal">vec-average</code>变量的<code class="literal">k-groups</code>函数来打印各种经过迭代的聚类，以产生最终的聚类集，如下面的代码所示:</p><div><pre class="programlisting">user&gt; ((k-groups vector-data vec-distance vec-average)
       '([1 1 1] [2 2 2] [3 3 3]))
(([[1 2 3] [3 2 1]] [[100 200 300] [300 200 100] [50 50 50]])

 ([[1 2 3] [3 2 1] [50 50 50]]
  [[100 200 300] [300 200 100]])

 ([[1 2 3] [3 2 1]]
  [[100 200 300] [300 200 100]]
  [[50 50 50]]))</pre></div><p>我们可以添加到这个实现中的另一个改进是通过<code class="literal">new-means</code>函数更新相同的平均值。如果我们向<code class="literal">new-means</code>函数传递相同平均值的列表，两个平均值都将被更新。然而，在经典的<em> K </em> -means 算法中，仅更新两个相同平均值中的一个平均值。可以在 REPL 中验证这种行为，方法是将一系列相同的方法(如<code class="literal">'(0 0)</code>传递给<code class="literal">new-means</code>函数，如以下代码所示:</p><div><pre class="programlisting">user&gt; (new-means average 
                 (point-groups '(0 0) '(0 1 2 3 4) distance) 
                 '(0 0))
(2 2)</pre></div><p>我们可以通过检查一组平均值中给定平均值的出现次数来避免这个问题，如果发现一个平均值出现多次，则只更新该平均值。我们可以使用<code class="literal">frequencies</code>函数<a id="id635" class="indexterm"/>来实现这一点，该函数返回一个 map，其中键作为传递给<code class="literal">frequencies</code>函数的原始集合中的元素，值作为这些元素出现的频率。因此，我们可以重新定义<code class="literal">new-means</code>函数，如以下代码所示:</p><div><pre class="programlisting">(defn update-seq [sq f]
  (let [freqs (frequencies sq)]
    (apply concat
     (for [[k v] freqs]
       (if (= v 1) 
         (list (f k))
         (cons (f k) (repeat (dec v) k)))))))
(defn new-means [average point-groups old-means]
  (update-seq
   old-means
   (fn [o]
     (if (contains? point-groups o)
       (apply average (get point-groups o)) o))))</pre></div><p>前面代码中定义的<a id="id636" class="indexterm"/>函数<code class="literal">update-seq</code>将函数<code class="literal">f</code>应用于序列<code class="literal">sq</code>中的元素。如果元素在序列中重复，函数<code class="literal">f</code>仅适用于单个元素。我们现在可以观察到，当我们对相同平均值序列<code class="literal">'(0 0)</code>应用重新定义的<code class="literal">new-means</code>函数<a id="id637" class="indexterm"/>时，只有一个平均值发生变化，如以下输出所示:</p><div><pre class="programlisting">user&gt; (new-means average
                 (point-groups '(0 0) '(0 1 2 3 4) distance)
                 '(0 0))
(2 0)</pre></div><p>前面对<code class="literal">new-means</code>函数重新定义的结果是，当<code class="literal">k-groups</code>函数应用于不同且相同的初始平均值时，例如<code class="literal">'(0 1)</code>和<code class="literal">'(0 0)</code>，它现在会产生相同的聚类，如以下代码所示:</p><div><pre class="programlisting">user&gt; ((k-groups '(0 1 2 3 4) distance average)
       '(0 1))
(([0] [1 2 3 4]) ([0 1] [2 3 4]))
user&gt; ((k-groups '(0 1 2 3 4) distance average)
       '(0 0))
(([0 1 2 3 4]) ([0] [1 2 3 4]) ([0 1] [2 3 4]))</pre></div><p>对于相同的初始平均值，<code class="literal">new-means</code>函数的这一新行为也扩展到了向量值，如以下输出所示:</p><div><pre class="programlisting">user&gt; ((k-groups vector-data vec-distance vec-average)
       '([1 1 1] [1 1 1] [1 1 1]))
(([[1 2 3] [3 2 1] [100 200 300] [300 200 100] [50 50 50]])
 ([[1 2 3] [3 2 1]] [[100 200 300] [300 200 100] [50 50 50]])
 ([[1 2 3] [3 2 1] [50 50 50]] [[100 200 300] [300 200 100]])
 ([[1 2 3] [3 2 1]] [[100 200 300] [300 200 100]] [[50 50 50]]))</pre></div><p>总之，上例中定义的<a id="id638" class="indexterm"/>的<code class="literal">k-cluster</code>和<code class="literal">k-groups</code>函数描述了如何在惯用的 Clojure 中实现<em> K </em>均值聚类。</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec14"/>使用 clj-ml 对数据进行聚类</h2></div></div></div><p><code class="literal">clj-ml</code>库<a id="id639" class="indexterm"/>提供了几个从 Java Weka 库派生的集群算法<a id="id640" class="indexterm"/>的实现。我们现在将演示如何使用<code class="literal">clj-ml</code>库来构建一个<em> K </em> -means clusterer。</p><div><div><h3 class="title"><a id="note40"/>注意</h3><p>通过向<code class="literal">project.clj</code>文件添加以下依赖关系，可将<code class="literal">clj-ml</code>和咒语库添加到 Leiningen 项目中:</p><div><pre class="programlisting">
<strong>[cc.artifice/clj-ml "0.4.0"]</strong>
<strong>[incanter "1.5.4"]</strong>
</pre></div><p>对于下面的示例，命名空间声明应该类似于下面的声明:</p><div><pre class="programlisting">
<strong>(ns my-namespace</strong>
<strong>  (:use [incanter core datasets]</strong>
<strong>        [clj-ml data clusterers]))</strong>
</pre></div></div></div><p>对于本章中使用<code class="literal">clj-ml library</code>的示例，我们将使用来自咒语库的<strong>虹膜</strong>数据集作为我们的训练数据。该数据集本质上是 150 朵花的样本和为这些样本测量的四个特征变量。在虹膜数据集中测量的花的特征是花的花瓣和萼片的宽度和长度。样本值分布在三个物种或类别中，即海滨锦鸡儿、刚毛锦鸡儿和云芝。数据以<img src="img/4351OS_07_07.jpg" alt="Clustering data using clj-ml"/>大小的矩阵形式提供，其中给定花卉的种类表示为该矩阵的最后一列。</p><p>我们可以从 Iris 数据集中选择特征作为向量，使用来自 Incanter 库的<code class="literal">get-dataset</code>、<code class="literal">sel</code>和<code class="literal">to-vector</code>函数，如下面的代码所示。然后我们可以使用<code class="literal">clj-ml</code>库中的<code class="literal">make-dataset</code>函数将这个向量转换成一个<code class="literal">clj-ml</code>数据集。这是通过将特征值的关键字名称作为模板传递给<code class="literal">make-dataset</code>函数来实现的，如以下代码所示:</p><div><pre class="programlisting">(def features [:Sepal.Length
               :Sepal.Width
               :Petal.Length
               :Petal.Width])

(def iris-data (to-vect (sel (get-dataset :iris)
                             :cols features)))

(def iris-dataset
  (make-dataset "iris" features iris-data))</pre></div><p>我们可以在 REPL 中打印前面代码中定义的<a id="id641" class="indexterm"/>变量<code class="literal">iris-dataset</code>，以给出一些关于<a id="id642" class="indexterm"/>的信息，如下面的代码和输出所示:</p><div><pre class="programlisting">user&gt; iris-dataset
#&lt;ClojureInstances @relation iris

@attribute Sepal.Length numeric
@attribute Sepal.Width numeric
@attribute Petal.Length numeric
@attribute Petal.Width numeric

@data
5.1,3.5,1.4,0.2
4.9,3,1.4,0.2
4.7,3.2,1.3,0.2
...
4.7,3.2,1.3,0.2
6.2,3.4,5.4,2.3
5.9,3,5.1,1.8&gt;</pre></div><p>我们可以使用来自<code class="literal">clj-ml.clusterers</code>名称空间的<code class="literal">make-clusterer</code>函数创建一个集群器。我们可以指定要创建的集群类型作为<code class="literal">make-cluster</code>函数的第一个参数。第二个可选参数是用于创建指定集群器的选项映射。我们可以使用<code class="literal">clj-ml</code>库中的<code class="literal">cluster-build</code>函数训练一个给定的集群器。在下面的代码中，我们使用带有<code class="literal">:k-means</code>关键字的<code class="literal">make-clusterer</code>函数创建了一个新的<em> K </em> -means clusterer，并定义了一个简单的 helper 函数来帮助使用任何给定的数据集训练该 clusterer:</p><div><pre class="programlisting">(def k-means-clusterer
  (make-clusterer :k-means
                  {:number-clusters 3}))

(defn train-clusterer [clusterer dataset]
  (clusterer-build clusterer dataset)
  clusterer)</pre></div><p><code class="literal">train-clusterer</code>函数可以应用于<code class="literal">k-means-clusterer</code>变量<a id="id643" class="indexterm"/>和<a id="id644" class="indexterm"/>变量所代表的样本数据所定义的 clusterer 实例，如下面的代码和输出所示:</p><div><pre class="programlisting">user&gt; (train-clusterer k-means-clusterer iris-dataset)
#&lt;SimpleKMeans
kMeans
======

Number of iterations: 6
Within cluster sum of squared errors: 6.982216473785234
Missing values globally replaced with mean/mode

Cluster centroids:
                            Cluster#
Attribute       Full Data          0          1          2
                    (150)       (61)       (50)       (39)
==========================================================
Sepal.Length       5.8433     5.8885      5.006     6.8462
Sepal.Width        3.0573     2.7377      3.428     3.0821
Petal.Length        3.758     4.3967      1.462     5.7026
Petal.Width        1.1993      1.418      0.246     2.0795</pre></div><p>如前面的<a id="id645" class="indexterm"/>输出所示，训练好的聚类器包含第一个聚类中的<code class="literal">61</code>值(聚类<code class="literal">0</code>)、第二个聚类中的<code class="literal">50</code>值(聚类<code class="literal">1</code>)和第三个聚类中的<code class="literal">39</code>值(聚类<code class="literal">2</code>)。前面的输出还为我们提供了一些有关训练数据中单个特征的平均值的信息。我们现在可以使用训练好的聚类器和<code class="literal">clusterer-cluster</code>函数<a id="id646" class="indexterm"/>来预测输入数据的类别，如以下代码所示:</p><div><pre class="programlisting">user&gt; (clusterer-cluster k-means-clusterer iris-dataset)
#&lt;ClojureInstances @relation 'clustered iris'

@attribute Sepal.Length numeric
@attribute Sepal.Width numeric
@attribute Petal.Length numeric
@attribute Petal.Width numeric
@attribute class {0,1,2}

@data
5.1,3.5,1.4,0.2,1
4.9,3,1.4,0.2,1
4.7,3.2,1.3,0.2,1
...
6.5,3,5.2,2,2
6.2,3.4,5.4,2.3,2
5.9,3,5.1,1.8,0&gt;</pre></div><p><code class="literal">clusterer-cluster</code>函数<a id="id647" class="indexterm"/>使用经过训练的聚类器返回一个新的数据集，该数据集包含一个附加的第五个属性，该属性表示给定样本值的类别。如前面的代码所示，这个新属性具有值<code class="literal">0</code>、<code class="literal">1</code>和<code class="literal">2</code>，样本值也包含这个新特性的有效值<a id="id648" class="indexterm"/>。总之，<code class="literal">clj-ml</code>库为使用聚类算法提供了一个很好的框架。在前面的例子中，我们使用<code class="literal">clj-ml</code>库创建了一个<em> K </em> -means clusterer。</p></div></div></div>





<title>Using hierarchical clustering</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>使用层次聚类</h1></div></div></div><p><strong>层次聚类</strong> <a id="id650" class="indexterm"/>是聚类分析的另一种方法，其中来自训练数据的输入值被分组到一个层次中。创建层次结构的过程可以采用自上而下的方法，其中所有的观察首先是单个聚类的一部分，然后被划分成更小的聚类。或者，我们可以使用自下而上的方法对输入值进行分组，其中每个分类最初是来自训练数据的样本值，然后将这些分类组合在一起。前一种自顶向下的方法称为<strong>分裂聚类</strong> <a id="id651" class="indexterm"/>，后一种自底向上的方法称为<strong>聚集聚类</strong> <a id="id652" class="indexterm"/>。</p><p>因此，在凝聚聚类中，我们将聚类组合成更大的聚类，而在分裂聚类中，我们将聚类分成更小的聚类。在性能方面，凝聚聚类算法的现代实现具有时间复杂度<img src="img/4351OS_07_08.jpg" alt="Using hierarchical clustering"/>，而分裂聚类的实现具有高得多的复杂度<img src="img/4351OS_07_09.jpg" alt="Using hierarchical clustering"/>。</p><p>假设我们的训练数据中有六个输入值。在下图中，假设这些输入值根据某个二维度量进行定位，以测量给定输入值的总体值:</p><div><img src="img/4351OS_07_10.jpg" alt="Using hierarchical clustering"/></div><p>我们可以对这些输入值应用聚合聚类来生成以下聚类层次结构:</p><div><img src="img/4351OS_07_11.jpg" alt="Using hierarchical clustering"/></div><p>观察到值<em> b </em>和<em> c </em>在空间分布中彼此最接近，因此被分组成一个群。类似地，节点<em> d </em>和<em> e </em>也被分组到另一个集群中。对输入值进行分层聚类的最终结果是样本值的单个二叉树或<strong>树形图</strong> <a id="id653" class="indexterm"/>。实际上，像<em> bc </em>和<em> def </em>这样的集群作为值或其他集群的二进制子树被添加到层次结构中。尽管这一过程在二维空间中似乎非常简单，但当应用于要素的几个维度时，确定输入值之间的距离和等级的问题的解决方案就不那么简单了。</p><p>在凝聚和<a id="id654" class="indexterm"/>分裂聚类技术中，必须计算来自样本数据的输入值之间的相似性。这可以通过测量两组输入值之间的距离，使用计算出的距离将它们分组到聚类中，然后确定两个输入值聚类之间的联系或相似性来实现。</p><p>分层聚类算法中距离度量的选择将决定该算法产生的聚类的形状。两个输入向量<img src="img/4351OS_07_12.jpg" alt="Using hierarchical clustering"/>和<img src="img/4351OS_07_13.jpg" alt="Using hierarchical clustering"/>之间的距离的两个常用度量是欧几里德距离<img src="img/4351OS_07_14.jpg" alt="Using hierarchical clustering"/>和欧几里德距离的平方<img src="img/4351OS_07_15.jpg" alt="Using hierarchical clustering"/>，它们可以正式表示如下:</p><div><img src="img/4351OS_07_16.jpg" alt="Using hierarchical clustering"/></div><p>输入值之间距离的另一个常用度量是最大距离<img src="img/4351OS_07_17.jpg" alt="Using hierarchical clustering"/>，它<a id="id655" class="indexterm"/>计算两个给定向量中相应元素的最大绝对差。该函数可以表示如下:</p><div><img src="img/4351OS_07_18.jpg" alt="Using hierarchical clustering"/></div><p>层次聚类算法的第二个方面是链接标准<a id="id656" class="indexterm"/>，它是两个输入值聚类之间相似性或不相似性的有效度量。确定两个输入值之间连锁关系的两种常用方法是<strong>完全连锁聚类</strong> <a id="id657" class="indexterm"/>和<strong>单一连锁聚类</strong> <a id="id658" class="indexterm"/>。这两种方法都是凝聚聚类的形式。</p><p>在凝聚聚类中，<a id="id659" class="indexterm"/>具有最短距离度量的两个输入值或聚类被组合成一个新的聚类。当然，“最短距离”的定义在任何聚集聚类技术中都是独一无二的。在完全关联聚类中，使用彼此相距最远的输入值来确定分组。因此，这种方法也被称为<strong>最远邻居聚类</strong> <a id="id660" class="indexterm"/>。两个值之间的距离<img src="img/4351OS_07_19.jpg" alt="Using hierarchical clustering"/>的度量可以正式表示如下:</p><div><img src="img/4351OS_07_20.jpg" alt="Using hierarchical clustering"/></div><p>在前面的等式中，函数<img src="img/4351OS_07_21.jpg" alt="Using hierarchical clustering"/>是两个输入向量之间距离的选定度量。完整的关联聚类实质上将具有距离度量最大值的值或聚类组合在一起<img src="img/4351OS_07_22.jpg" alt="Using hierarchical clustering"/>。重复这种将群集组合在一起的操作，直到产生单个群集。</p><p>在单一关联聚类中，彼此最接近的值被分组在一起。因此，单连锁聚类也被称为<strong>最近邻聚类</strong>。这可以用下面的表达式来正式表述:</p><div><img src="img/4351OS_07_23.jpg" alt="Using hierarchical clustering"/></div><p>另一种流行的层次聚类技术是<a id="id661" class="indexterm"/> <strong>蛛网算法</strong> <a id="id662" class="indexterm"/>。该算法是<strong>概念聚类</strong> <a id="id663" class="indexterm"/>的一种形式，其中为使用的聚类方法产生的每个聚类创建一个概念。对于术语“概念”，我们指的是对聚集在一起的数据的简明的正式描述。有趣的是，概念聚类与决策树学习密切相关，我们已经在<a class="link" href="ch03.html" title="Chapter 3. Categorizing Data">第 3 章</a>、<em>分类数据</em>中讨论过。蛛网算法将所有聚类分组到一个<strong>分类树</strong>中，其中每个节点都包含作为其子节点的值或聚类的正式摘要。然后，此信息可用于确定和预测具有某些缺失要素的输入值的类别。从这个意义上说，当测试数据中的一些样本缺少或未知特征时，可以使用这种技术。</p><p>我们现在演示一个简单的分层集群实现<a id="id664" class="indexterm"/>。在这个实现中，我们采用了一种稍微不同的方法，将部分所需功能嵌入到 Clojure 语言提供的标准向量数据结构中。</p><div><div><h3 class="title"><a id="note42"/>注意</h3><p>对于接下来的例子，我们需要可以通过向<code class="literal">project.clj</code>文件添加以下依赖项来添加到 Leiningen 项目的<code class="literal">clojure.math.numeric-tower</code>库:</p><div><pre class="programlisting">[org.clojure/math.numeric-tower "0.0.4"]</pre></div><p>该示例的命名空间声明应类似于以下声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use [clojure.math.numeric-tower :only [sqrt]]))</pre></div></div></div><p>对于这个实现，我们将使用两点之间的欧几里德距离作为距离度量。我们可以通过输入向量中元素的平方和来计算这个距离，可以使用如下的<code class="literal">reduce</code>和<code class="literal">map</code>函数的组合来计算:</p><div><pre class="programlisting">(defn sum-of-squares [coll]
  (reduce + (map * coll coll)))</pre></div><p>前面代码中定义的<code class="literal">sum-of-squares</code>函数<a id="id665" class="indexterm"/>将用于确定距离度量。我们将定义两个协议，抽象我们对特定数据类型执行的操作。从工程角度来看，这两个协议可以合并成一个协议，因为这两个协议将组合使用。</p><p>然而，为了清楚起见，我们在本例中使用了以下两种协议:</p><div><pre class="programlisting">(defprotocol Each
  (each [v op w]))

(defprotocol Distance
  (distance [v w]))</pre></div><p>在<code class="literal">Each</code>协议中定义的<code class="literal">each</code>函数对两个集合<code class="literal">v</code>和<code class="literal">w</code>中的相应元素应用给定的操作<code class="literal">op</code>。<code class="literal">each</code>函数与标准的<code class="literal">map</code>函数非常相似，但是<code class="literal">each</code>允许<code class="literal">v</code>的数据类型决定如何应用函数<code class="literal">op</code>。在<code class="literal">Distance</code>协议中定义的<code class="literal">distance</code>函数计算任意两个集合<code class="literal">v</code>和<code class="literal">w</code>之间的距离。注意，我们使用通用术语“集合”,因为我们处理的是抽象协议，而不是这些协议功能的具体实现。对于这个例子，我们将把前面的协议作为 vector 数据类型的一部分来实现。当然，这些协议也可以扩展到其他数据类型，比如集合和映射。</p><p>在本例中，我们将实现单一链接聚类作为链接标准。首先，我们必须定义一个函数来从一组向量值中确定两个最近的向量。为此，我们可以在 vector 上应用<code class="literal">min-key</code>函数，该函数返回集合中关联值最少的键。有趣的是，这在 Clojure 中是可能的，因为我们可以将一个向量视为一个映射，将向量中各种元素的索引值作为它的键。我们将借助以下代码来实现这一点:</p><div><pre class="programlisting">(defn closest-vectors [vs]
  (let [index-range (range (count vs))]
    (apply min-key
           (fn [[x y]] (distance (vs x) (vs y)))
           (for [i index-range
                 j (filter #(not= i %) index-range)]
             [i j]))))</pre></div><p>前面代码中定义的<code class="literal">closest-vectors</code>函数<a id="id667" class="indexterm"/>使用<code class="literal">for</code>形式确定矢量<code class="literal">vs</code>索引的所有可能组合。注意，向量<code class="literal">vs</code>是向量的向量。然后将<code class="literal">distance</code>函数应用于可能的索引组合<a id="id668" class="indexterm"/>的值，然后使用<code class="literal">min-key</code>函数比较这些距离。该函数最终返回彼此距离最小的两个内部向量值的索引值，从而实现单链聚类。</p><p>我们还需要计算两个必须聚集在一起的向量的平均值。我们可以使用之前在<code class="literal">Each</code>协议中定义的<code class="literal">each</code>函数和<code class="literal">reduce</code>函数来实现，如下所示:</p><div><pre class="programlisting">(defn centroid [&amp; xs]
  (each
   (reduce #(each %1 + %2) xs)
   *
   (double (/ 1 (count xs)))))</pre></div><p>前面代码中定义的<code class="literal">centroid</code>函数<a id="id669" class="indexterm"/>将计算一系列向量值的平均值。注意使用<code class="literal">double</code>函数来确保<code class="literal">centroid</code>函数返回的值是一个双精度数。</p><p>我们现在将<code class="literal">Each</code>和<code class="literal">Distance</code>协议实现为 vector 数据类型的一部分，它完全符合<code class="literal">clojure.lang.PersistentVector</code>的要求。使用<code class="literal">extend-type</code>功能<a id="id670" class="indexterm"/>完成，如下所示:</p><div><pre class="programlisting">(extend-type clojure.lang.PersistentVector
  Each
  (each [v op w]
    (vec
     (cond
      (number? w) (map op v (repeat w))
      (vector? w) (if (&gt;= (count v) (count w))
                    (map op v (lazy-cat w (repeat 0)))
                    (map op (lazy-cat v (repeat 0)) w)))))
  Distance 
  ;; implemented as Euclidean distance
  (distance [v w] (-&gt; (each v - w)
                      sum-of-squares
                      sqrt)))</pre></div><p><code class="literal">each</code>函数的实现方式是将<code class="literal">op</code>运算应用于<code class="literal">v</code>向量中的每个元素和第二个参数<code class="literal">w</code>。<code class="literal">w</code>参数可以是向量或数字。如果<code class="literal">w</code>是一个数字，我们只需将函数<code class="literal">op</code>映射到<code class="literal">v</code>和数字<code class="literal">w</code>的重复值。如果<code class="literal">w</code>是一个向量，我们使用<code class="literal">lazy-cat</code>函数用<code class="literal">0</code>值填充较小的向量，并将<code class="literal">op</code>映射到两个向量上。此外，我们将整个表达式包装在一个<code class="literal">vec</code>函数中，以确保返回值始终是一个向量。</p><p>使用我们之前定义的<code class="literal">sum-of-squares</code>函数和来自<code class="literal">clojure.math.numeric-tower</code>名称空间的<code class="literal">sqrt</code>函数，将<code class="literal">distance</code>函数实现为两个向量值<code class="literal">v</code>和<code class="literal">w</code>之间的欧几里德距离。</p><p>我们已经拥有了实现对向量值执行层次聚类的函数所需的所有部分。我们可以主要使用我们之前定义的质心和<code class="literal">closest-vectors</code>函数来实现层次聚类，如下所示:</p><div><pre class="programlisting">(defn h-cluster
  "Performs hierarchical clustering on a
  sequence of maps of the form { :vec [1 2 3] } ."
  [nodes]
  (loop [nodes nodes]
    (if (&lt; (count nodes) 2)
      nodes
      (let [vectors    (vec (map :vec nodes))
            [l r]      (closest-vectors vectors)
            node-range (range (count nodes))
            new-nodes  (vec
                        (for [i node-range
                              :when (and (not= i l)
                                         (not= i r))]
                          (nodes i)))]
        (recur (conj new-nodes
                     {:left (nodes l) :right (nodes r)
                      :vec (centroid
                            (:vec (nodes l))
                            (:vec (nodes r)))}))))))</pre></div><p>我们可以将一个映射向量传递给前面代码中定义的<code class="literal">h-cluster</code>函数。这个向量中的每个地图都包含一个向量作为关键字<code class="literal">:vec</code>的值。<code class="literal">h-cluster</code>函数组合这些地图中来自<code class="literal">:vec</code>关键词的所有矢量值，并使用<code class="literal">closest-vectors</code>函数<a id="id672" class="indexterm"/>确定两个最近的矢量。由于<code class="literal">closest-vectors</code>函数返回的值是两个索引值的向量，所以我们确定所有向量的索引都不同于<code class="literal">closest-vectors</code>函数返回的两个索引值。这是通过使用特殊形式的<code class="literal">for</code>宏来完成的，该宏允许用<code class="literal">:when</code>键参数指定条件子句。然后使用<code class="literal">centroid</code>函数计算两个最近向量的平均值。使用平均值创建新的图<a id="id673" class="indexterm"/>，然后将其添加到原始向量中，以替换两个最接近的向量值。使用<code class="literal">loop</code>形式，重复该过程，直到向量包含单个簇。我们可以检查 REPL 中<code class="literal">h-cluster</code>函数的行为，如以下代码所示:</p><div><pre class="programlisting">user&gt; (h-cluster [{:vec [1 2 3]} {:vec [3 4 5]} {:vec [7 9 9]}])
[{:left {:vec [7 9 9]},
  :right {:left {:vec [1 2 3]},
          :right {:vec [3 4 5]},
          :vec [2.0 3.0 4.0]},
  :vec [4.5 6.0 6.5] }]</pre></div><p>当应用于三个向量值<code class="literal">[1 2 3]</code>、<code class="literal">[3 4 5]</code>和<code class="literal">[7 9 9]</code>时，如前面的代码所示，<code class="literal">h-cluster</code>函数将向量<code class="literal">[1 2 3]</code>和<code class="literal">[3 4 5]</code>分组为一个簇。该集群具有从矢量<code class="literal">[1 2 3]</code>和<code class="literal">[3 4 5]</code>计算出的平均值<code class="literal">[2.0 3.0 4.0]</code>。然后，在下一次迭代<a id="id674" class="indexterm"/>中，该新聚类与向量<code class="literal">[7 9 9]</code>分组，从而产生具有平均值<code class="literal">[4.5 6.0 6.5]</code>的单个聚类。总之，<code class="literal">h-cluster</code>函数可用于将向量值分层聚类成一个层次。</p><p><code class="literal">clj-ml</code>库提供了蛛网层次聚类算法的实现。我们可以使用带有<code class="literal">:cobweb</code>参数的<code class="literal">make-clusterer</code>函数实例化这样一个集群器。</p><div><pre class="programlisting">(def h-clusterer (make-clusterer :cobweb))</pre></div><p>由前面代码中所示的<code class="literal">h-clusterer</code>变量<a id="id675" class="indexterm"/>定义的聚类器可以使用我们之前定义的<code class="literal">train-clusterer</code>函数和<code class="literal">iris-dataset</code>数据集进行训练，如下所示:<code class="literal">train-clusterer</code>函数和<code class="literal">iris-dataset</code>可以如下面代码所示实现:</p><div><pre class="programlisting">user&gt; (train-clusterer h-clusterer iris-dataset)
#&lt;Cobweb Number of merges: 0
Number of splits: 0
Number of clusters: 3

node 0 [150]
|   leaf 1 [96]
node 0 [150]
|   leaf 2 [54]</pre></div><p>如前面的 REPL 输出所示，蛛网聚类算法将输入数据划分为两个聚类。一个聚类有 96 个样本，另一个聚类有 54 个样本，与我们之前使用的<em> K </em> -means clusterer 相比，这是一个非常不同的结果。总之，<code class="literal">clj-ml</code>库提供了一个易于使用的蛛网聚类算法实现。</p></div>





<title>Using Expectation-Maximization</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>使用期望值最大化</h1></div></div></div><p><strong>期望最大化</strong> ( <strong> EM </strong>)算法<a id="id676" class="indexterm"/>是一种概率方法，用于确定适合所提供的训练数据的聚类模型。该算法确定公式化聚类模型参数的<strong>最大似然估计</strong> ( <strong> MLE </strong> ) <a id="id677" class="indexterm"/>(有关更多信息，请参考<em>最大似然理论和观察指数族变量函数时生成的分布应用</em>)。</p><p>假设我们想确定抛硬币是正面还是反面的概率。如果我们抛硬币<img src="img/4351OS_07_24.jpg" alt="Using Expectation-Maximization"/>次，我们最终得到<img src="img/4351OS_07_25.jpg" alt="Using Expectation-Maximization"/>次正面和<img src="img/4351OS_07_26.jpg" alt="Using Expectation-Maximization"/>次反面。我们可以使用下面的等式来估计人头出现的实际概率<img src="img/4351OS_07_27.jpg" alt="Using Expectation-Maximization"/>，即人头出现的次数与投掷硬币的总次数之比:</p><div><img src="img/4351OS_07_28.jpg" alt="Using Expectation-Maximization"/></div><p>上式中定义的概率<img src="img/4351OS_07_29.jpg" alt="Using Expectation-Maximization"/>是概率<img src="img/4351OS_07_30.jpg" alt="Using Expectation-Maximization"/>的最大似然估计。在机器学习的背景下，MLE 可以被最大化以确定给定类或类别的出现概率。然而，这种估计的概率可能不会在可用的训练数据上以明确定义的方式统计分布，这使得很难有效地确定 MLE。通过引入一组隐藏值来解释训练数据中未观察到的值，可以简化问题。隐藏值不是直接从数据中测量的，而是由影响数据的因素决定的。给定一组观察值<img src="img/4351OS_07_12.jpg" alt="Using Expectation-Maximization"/>和一组隐藏值<img src="img/4351OS_07_32.jpg" alt="Using Expectation-Maximization"/>的参数<img src="img/4351OS_07_31.jpg" alt="Using Expectation-Maximization"/>的似然函数被定义为给定一组参数<img src="img/4351OS_07_31.jpg" alt="Using Expectation-Maximization"/>的<img src="img/4351OS_07_12.jpg" alt="Using Expectation-Maximization"/>和<img src="img/4351OS_07_32.jpg" alt="Using Expectation-Maximization"/>出现的概率。可能性在数学上写成<img src="img/4351OS_07_33.jpg" alt="Using Expectation-Maximization"/>，可以表示如下:</p><div><img src="img/4351OS_07_34.jpg" alt="Using Expectation-Maximization"/></div><p>EM 算法包括两步——期望步骤<a id="id679" class="indexterm"/>和最大化步骤。在期望步骤中，我们计算<strong>对数似然</strong>函数的期望值<a id="id680" class="indexterm"/>。该步骤确定了一个度量<img src="img/4351OS_07_35.jpg" alt="Using Expectation-Maximization"/>，该度量必须在下一步骤中被最大化，即算法的最大化步骤<a id="id681" class="indexterm"/>。这两个步骤可以概括如下:</p><div><img src="img/4351OS_07_36.jpg" alt="Using Expectation-Maximization"/></div><p>在前面的等式中，迭代计算使函数<em> Q </em>的值最大化的<img src="img/4351OS_07_31.jpg" alt="Using Expectation-Maximization"/>的值，直到它收敛到特定值。术语<img src="img/4351OS_07_37.jpg" alt="Using Expectation-Maximization"/>代表算法的<img src="img/4351OS_07_38.jpg" alt="Using Expectation-Maximization"/>迭代中的估计参数。另外，<img src="img/4351OS_07_39.jpg" alt="Using Expectation-Maximization"/>项是对数似然函数的期望值。</p><p><code class="literal">clj-ml</code>库也提供了一个 EM 集群器。我们可以使用<code class="literal">make-clusterer</code>函数<a id="id682" class="indexterm"/>并以<code class="literal">:expectation-maximization</code>关键字作为参数来创建一个 EM clusterer，如下面的代码所示:</p><div><pre class="programlisting">(def em-clusterer (make-clusterer :expectation-maximization
                                  {:number-clusters 3}))</pre></div><p>注意，我们还必须指定要生成的集群数量，作为<code class="literal">make-clusterer</code>函数的一个选项。</p><p>我们可以使用之前定义的<code class="literal">train-clusterer</code>函数<a id="id684" class="indexterm"/>和<code class="literal">iris-dataset</code>数据集，训练前面代码中由<code class="literal">em-clusterer </code>变量定义的聚类器<a id="id683" class="indexterm"/>，如下所示:</p><div><pre class="programlisting">user&gt; (train-clusterer em-clusterer iris-dataset)
#&lt;EM
EM
==

Number of clusters: 3


               Cluster
Attribute            0       1       2
                (0.41)  (0.25)  (0.33)
=======================================
Sepal.Length
  mean           5.9275  6.8085   5.006
  std. dev.      0.4817  0.5339  0.3489

Sepal.Width
  mean           2.7503  3.0709   3.428
  std. dev.      0.2956  0.2867  0.3753

Petal.Length
  mean           4.4057  5.7233   1.462
  std. dev.      0.5254  0.4991  0.1719

Petal.Width
  mean           1.4131  2.1055   0.246
  std. dev.      0.2627  0.2456  0.1043</pre></div><p>如前面的输出所示，EM clusterer 将给定的数据集划分为三个聚类，其中聚类<a id="id685" class="indexterm"/>大约占训练数据中样本的 41%、25%和 35%。</p></div>





<title>Using SOMs</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>使用 SOMs</h1></div></div></div><p>正如我们之前在<a class="link" href="ch04.html" title="Chapter 4. Building Neural Networks">第四章</a>、<em>构建神经网络</em>中提到的<a id="id686" class="indexterm"/>，SOMs 可以用于建模无监督的机器学习问题，如聚类(有关更多信息，请参考<em>自组织映射作为 K 均值聚类的替代</em>)。简单回顾一下，SOM 是一种将高维输入值映射到低维输出空间的人工神经网络。这种映射保留了输入值之间的模式和拓扑关系。对于空间上彼此接近的输入值，SOM 的输出空间中的神经元将具有更高的激活值。因此，SOMs 是对具有大量维度的输入数据进行聚类的良好解决方案。</p><p>咒语库<a id="id688" class="indexterm"/>提供了一个简洁的 SOM 实现，我们可以用它来对来自 Iris 数据集的输入变量进行聚类。在接下来的例子中，我们将演示如何使用这个 SOM 实现进行集群。</p><div><div><h3 class="title"><a id="note44"/>注</h3><p>通过向<code class="literal">project.clj</code>文件添加以下依赖项，可以将咒语库添加到 Leiningen 项目中:</p><div><pre class="programlisting">[incanter "1.5.4"]</pre></div><p>对于接下来的示例，命名空间声明应该类似于以下声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use [incanter core som stats charts datasets]))</pre></div></div></div><p>我们首先使用 Incanter 库中的<code class="literal">get-dataset</code>、<code class="literal">sel</code>和<code class="literal">to-matrix</code>函数定义样本数据进行聚类，如下所示:</p><div><pre class="programlisting">(def iris-features (to-matrix (sel (get-dataset :iris)
                                   :cols [:Sepal.Length
                                          :Sepal.Width
                                          :Petal.Length
                                          :Petal.Width])))</pre></div><p>前面代码中定义的<code class="literal">iris-features</code>变量<a id="id689" class="indexterm"/>实际上是一个<img src="img/4351OS_07_40.jpg" alt="Using SOMs"/>大小的矩阵，代表我们从 Iris 数据集中选择的四个输入变量的值。现在，我们可以使用来自<code class="literal">incanter.som</code>名称空间的<code class="literal">som-batch-train</code>函数<a id="id690" class="indexterm"/>来使用这些选择的特性创建和训练 SOM，如下所示:</p><div><pre class="programlisting">(def som (som-batch-train
          iris-features :cycles 10))</pre></div><p>定义的<code class="literal">som</code>变量实际上是一个有几个键值对的映射。此映射中的<code class="literal">:dims</code>键包含一个向量，该向量表示经过训练的 SOM 中神经元网格的维度，如以下代码和输出所示:</p><div><pre class="programlisting">user&gt; (:dims som)
[10.0 2.0]</pre></div><p>因此，我们可以说经过训练的 SOM 的神经网格是一个<img src="img/4351OS_07_41.jpg" alt="Using SOMs"/>矩阵。由<code class="literal">som</code>变量表示的映射的<code class="literal">:sets</code>键为我们提供了 SOM 神经元网格中输入值的各种索引的位置分组，如以下输出所示:</p><div><pre class="programlisting">user&gt; (:sets som)
{[4 1] (144 143 141 ... 102 100),
 [8 1] (149 148 147 ... 50),
 [9 0] (49 48 47 46 ... 0)}</pre></div><p>如前面的 REPL 输出所示，输入数据被划分为三个聚类。我们可以使用来自<code class="literal">incanter.stats</code>名称空间的<code class="literal">mean</code>函数计算每个特征的平均值<a id="id691" class="indexterm"/>，如下所示:</p><div><pre class="programlisting">(def feature-mean
  (map #(map mean (trans
                   (sel iris-features :rows ((:sets som) %))))
       (keys (:sets som))))</pre></div><p>我们可以使用咒语库中的<code class="literal">xy-plot</code>、<code class="literal">add-lines</code>和<code class="literal">view</code>函数实现一个函数来绘制这些平均值，如下所示:</p><div><pre class="programlisting">(defn plot-means []
  (let [x (range (ncol iris-features))
        cluster-name #(str "Cluster " %)]
    (-&gt; (xy-plot x (nth feature-mean 0)
                 :x-label "Feature"
                 :y-label "Mean value of feature"
                 :legend true
                 :series-label (cluster-name 0))
        (add-lines x (nth feature-mean 1)
                   :series-label (cluster-name 1))
        (add-lines x (nth feature-mean 2)
                   :series-label (cluster-name 2))
        view)))</pre></div><p>调用前面代码中定义的<code class="literal">plot-means</code>函数<a id="id692" class="indexterm"/>会产生以下线性图:</p><div><img src="img/4351OS_07_42.jpg" alt="Using SOMs"/></div><p>前面的图让我们了解了由 SOM 确定的三个聚类中各种特征的平均值。该图显示两个群集(<em>群集 0 </em>和<em>群集 1 </em>)具有相似的特征。然而，第三个聚类对于这些特征集具有显著不同的平均值，因此在图中显示为不同的形状。当然，这个图并没有<a id="id693" class="indexterm"/>给我们多少关于这些平均值周围的输入值的分布或方差的信息。为了可视化这些特征，我们需要以某种方式将输入数据的维数转换为二维或三维，这很容易可视化。我们将在本章的下一节详细讨论减少训练数据中特征数量的概念。</p><p>我们还可以使用<code class="literal">frequencies</code>和<code class="literal">sel</code>函数打印输入值的分类和实际类别，如下所示:</p><div><pre class="programlisting">(defn print-clusters []
  (doseq [[pos rws] (:sets som)]
    (println pos \:
             (frequencies
              (sel (get-dataset :iris) 
                   :cols :Species :rows rws)))))</pre></div><p>我们可以调用前面代码中定义的函数<code class="literal">print-clusters</code>来产生以下 REPL 输出:</p><div><pre class="programlisting">user&gt; (print-clusters)
[4 1] : {virginica 23}
[8 1] : {virginica 27, versicolor 50}
[9 0] : {setosa 50}
nil</pre></div><p>如前面的输出所示，<code class="literal">virginica</code>和<code class="literal">setosa</code>物种似乎被适当地分为两个集群。然而，包含<code class="literal">versicolor</code>物种的输入值的聚类也包含<code class="literal">virginica</code>物种的 27 个样本。这个问题可以通过使用更多的样本数据来训练 SOM 或者通过建模更多的特征来<a id="id694" class="indexterm"/>解决。</p><p>总之，Incanter 库为我们提供了 SOM 的简洁实现，我们可以使用 Iris 数据集对其进行训练，如前面的示例所示。</p></div>





<title>Reducing dimensions in the data</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>减少数据中的维度</h1></div></div></div><p>为了容易地可视化一些输入值具有多个维度的未标记数据的分布，我们必须将特征维度的数量减少到两个或三个。一旦我们将输入数据的维数减少到二维或三维，我们就可以轻松地绘制数据，以提供更易于理解的可视化。这个减少输入数据维数的过程被称为<strong>降维</strong> <a id="id695" class="indexterm"/>。由于此过程减少了用于表示样本数据的总维数，因此它对于数据压缩也很有用。</p><p><strong>主成分分析</strong> ( <strong> PCA </strong> ) <a id="id696" class="indexterm"/>是将<a id="id697" class="indexterm"/>样本数据中的输入变量转化为线性不相关变量的一种降维形式(更多信息请参考<em>主成分分析</em>)。这些变换后的特征被称为样本数据的<strong>主成分</strong>。</p><p>PCA 使用一个协方差矩阵<a id="id698" class="indexterm"/>和一个称为<strong>奇异值分解</strong> ( <strong> SVD </strong>)的矩阵运算来<a id="id699" class="indexterm"/>计算一组给定输入值的主分量。表示为<img src="img/4351OS_07_43.jpg" alt="Reducing dimensions in the data"/>的协方差矩阵可以从具有<img src="img/4351OS_07_44.jpg" alt="Reducing dimensions in the data"/>样本的一组输入向量<img src="img/4351OS_07_12.jpg" alt="Reducing dimensions in the data"/>中确定，如下所示:</p><div><img src="img/4351OS_07_45.jpg" alt="Reducing dimensions in the data"/></div><p>协方差矩阵<a id="id700" class="indexterm"/>通常根据均值归一化后的输入值计算得出，这只是为了确保每个特征的均值为零。此外，可以在确定协方差矩阵之前对特征进行缩放。接下来，协方差矩阵<a id="id701" class="indexterm"/>的 SVD 确定如下:</p><div><img src="img/4351OS_07_46.jpg" alt="Reducing dimensions in the data"/></div><p>SVD <a id="id702" class="indexterm"/>可以被认为<a id="id703" class="indexterm"/>是将一个大小为<img src="img/4351OS_07_48.jpg" alt="Reducing dimensions in the data"/>的矩阵<img src="img/4351OS_07_47.jpg" alt="Reducing dimensions in the data"/>分解成三个矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>、<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>和<img src="img/4351OS_07_51.jpg" alt="Reducing dimensions in the data"/>。矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>的大小为<img src="img/4351OS_07_52.jpg" alt="Reducing dimensions in the data"/>，矩阵<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>的大小为<img src="img/4351OS_07_48.jpg" alt="Reducing dimensions in the data"/>，矩阵<img src="img/4351OS_07_51.jpg" alt="Reducing dimensions in the data"/>的大小为<img src="img/4351OS_07_53.jpg" alt="Reducing dimensions in the data"/>。矩阵<img src="img/4351OS_07_47.jpg" alt="Reducing dimensions in the data"/>实际上代表样本数据中具有<img src="img/4351OS_07_55.jpg" alt="Reducing dimensions in the data"/>维度的<img src="img/4351OS_07_54.jpg" alt="Reducing dimensions in the data"/>输入向量。矩阵<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>是对角矩阵<a id="id704" class="indexterm"/>，称为矩阵<img src="img/4351OS_07_47.jpg" alt="Reducing dimensions in the data"/>的<strong>奇异值</strong> <a id="id705" class="indexterm"/>，矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>和<img src="img/4351OS_07_51.jpg" alt="Reducing dimensions in the data"/>分别称为<img src="img/4351OS_07_47.jpg" alt="Reducing dimensions in the data"/>的<strong>左右奇异向量</strong>。在 PCA 的上下文中，矩阵<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>被称为样本数据的<strong>缩减分量</strong> <a id="id706" class="indexterm"/>，矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>被称为样本数据的<strong>旋转分量</strong> <a id="id707" class="indexterm"/>。</p><p>将<img src="img/4351OS_07_54.jpg" alt="Reducing dimensions in the data"/>输入向量中的<img src="img/4351OS_07_55.jpg" alt="Reducing dimensions in the data"/>维度减少到<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>维度的 PCA 算法<a id="id708" class="indexterm"/>可使用以下步骤进行总结:</p><div><ol class="orderedlist arabic"><li class="listitem">从输入向量<img src="img/4351OS_07_12.jpg" alt="Reducing dimensions in the data"/>计算协方差矩阵<img src="img/4351OS_07_43.jpg" alt="Reducing dimensions in the data"/>。</li><li class="listitem">通过对协方差矩阵<img src="img/4351OS_07_43.jpg" alt="Reducing dimensions in the data"/>应用 SVD 来计算矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>、<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>和<img src="img/4351OS_07_51.jpg" alt="Reducing dimensions in the data"/>。</li><li class="listitem">从<img src="img/4351OS_07_52.jpg" alt="Reducing dimensions in the data"/>矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>中选择前<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>列生成矩阵<img src="img/4351OS_07_57.jpg" alt="Reducing dimensions in the data"/>，称为矩阵<img src="img/4351OS_07_43.jpg" alt="Reducing dimensions in the data"/>的<strong>约化左奇异向量</strong>或<strong>约化旋转矩阵</strong> <a id="id710" class="indexterm"/>。该矩阵<a id="id711" class="indexterm"/>表示<a id="id712" class="indexterm"/>样本数据的<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>主成分，大小为<img src="img/4351OS_07_58.jpg" alt="Reducing dimensions in the data"/>。</li><li class="listitem">计算尺寸为<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>的向量，用<img src="img/4351OS_07_32.jpg" alt="Reducing dimensions in the data"/>表示，如下:<div> <img src="img/4351OS_07_59.jpg" alt="Reducing dimensions in the data"/> </div></li></ol></div><p>注意，PCA 算法的输入是来自均值归一化和特征缩放后的样本数据的一组输入向量<img src="img/4351OS_07_12.jpg" alt="Reducing dimensions in the data"/>。</p><p>由于前面步骤中计算的矩阵<img src="img/4351OS_07_57.jpg" alt="Reducing dimensions in the data"/>具有<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>列，矩阵<img src="img/4351OS_07_32.jpg" alt="Reducing dimensions in the data"/>将具有<img src="img/4351OS_07_60.jpg" alt="Reducing dimensions in the data"/>的大小，这表示<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>维度中的<img src="img/4351OS_07_54.jpg" alt="Reducing dimensions in the data"/>输入向量。我们应该注意到，维数<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>的值越小，数据的方差损失越大。因此，我们应该选择<img src="img/4351OS_07_56.jpg" alt="Reducing dimensions in the data"/>，这样只有一小部分方差会丢失。</p><p>原始输入向量<img src="img/4351OS_07_12.jpg" alt="Reducing dimensions in the data"/>可以从矩阵<img src="img/4351OS_07_32.jpg" alt="Reducing dimensions in the data"/>和简化的<a id="id714" class="indexterm"/>左奇异向量<img src="img/4351OS_07_57.jpg" alt="Reducing dimensions in the data"/>中重新创建，如下所示:</p><div><img src="img/4351OS_07_61.jpg" alt="Reducing dimensions in the data"/></div><p>咒语库包括一些执行 PCA 的函数。在接下来的例子中，我们将使用 PCA 来提供虹膜数据集的更好的可视化。</p><div><div><h3 class="title"><a id="note46"/>注</h3><p>下一个示例的命名空间声明应类似于以下声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use [incanter core stats charts datasets]))</pre></div></div></div><p>我们首先使用<code class="literal">get-dataset</code>、<code class="literal">to-matrix</code>和<code class="literal">sel</code>函数定义训练数据，如下面的代码所示:</p><div><pre class="programlisting">(def iris-matrix (to-matrix (get-dataset :iris)))
(def iris-features (sel iris-matrix :cols (range 4)))
(def iris-species (sel iris-matrix :cols 4))</pre></div><p>与前面的示例类似，我们将使用 Iris 数据集的前四列作为训练数据的输入变量的样本数据。</p><p>PCA 由来自<code class="literal">incanter.stats</code>名称空间的<code class="literal">principal-components</code>函数执行。该函数返回一个包含旋转矩阵<img src="img/4351OS_07_49.jpg" alt="Reducing dimensions in the data"/>和来自 PCA<a id="id715" class="indexterm"/>的缩减矩阵<img src="img/4351OS_07_50.jpg" alt="Reducing dimensions in the data"/>的映射，我们之前已经描述过。我们可以使用<code class="literal">sel</code>函数从输入数据的约简矩阵中选择列，如以下代码所示:</p><div><pre class="programlisting">(def pca (principal-components iris-features))

(def U (:rotation pca))
(def U-reduced (sel U :cols (range 2)))</pre></div><p>如前面的代码所示，<a id="id716" class="indexterm"/>可以使用<code class="literal">principal-components</code>函数<a id="id717" class="indexterm"/>返回的值上的<code class="literal">:rotation</code>关键字获取输入数据的 PCA 的旋转矩阵。我们现在可以使用简化的旋转矩阵和由<code class="literal">iris-features</code>变量表示的原始特征矩阵来计算简化的特征<em> Z </em>，如以下代码所示:</p><div><pre class="programlisting">(def reduced-features (mmult iris-features U-reduced))</pre></div><p>然后，通过选择<code class="literal">reduced-features</code>矩阵的前两列并使用<code class="literal">scatter-plot</code>函数绘制它们，可以可视化减少的特征，如以下代码所示:</p><div><pre class="programlisting">(defn plot-reduced-features []
  (view (scatter-plot (sel reduced-features :cols 0)
                      (sel reduced-features :cols 1)
                      :group-by iris-species
                      :x-label "PC1"
                      :y-label "PC2")))</pre></div><p>调用前面代码中定义的<code class="literal">plot-reduced-features</code>函数<a id="id718" class="indexterm"/>会生成以下图形:</p><div><img src="img/4351OS_07_62.jpg" alt="Reducing dimensions in the data"/></div><p>上图中展示的散点图为我们提供了输入数据分布的直观形象。<a id="id719" class="indexterm"/>对于给定的一组特征，前面图中的蓝色和绿色聚类显示具有<a id="id720" class="indexterm"/>相似的值。总之，Incanter 库支持 PCA，这使得一些样本数据很容易可视化。</p></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>总结</h1></div></div></div><p>在这一章中，我们探讨了几种可用于对一些未标记数据建模的聚类算法。以下是我们讨论过的一些其他要点:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我们探索了 K 均值算法和层次聚类技术，同时在纯 Clojure 中提供了这些方法的示例实现。我们还描述了如何通过<code class="literal">clj-ml</code>库利用这些技术。</li><li class="listitem" style="list-style-type: disc">我们讨论了 EM 算法，这是一种概率聚类技术，还描述了我们如何使用<code class="literal">clj-ml</code>库来构建 EM 聚类器。</li><li class="listitem" style="list-style-type: disc">我们还探索了如何使用 SOMs 来处理高维聚类问题。我们还演示了如何使用 Incanter 库来构建可用于集群的 SOM。</li><li class="listitem" style="list-style-type: disc">最后，我们研究了降维和主成分分析，以及如何使用主成分分析通过咒语库提供虹膜数据集的更好的可视化。</li></ul></div><p>在下一章中，我们将探索使用机器学习技术的异常检测和推荐系统的概念。</p></div>
</body></html>