<html><head/><body>



<title>Chapter 6. Building Support Vector Machines</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06"/>第六章。构建支持向量机</h1></div></div></div><p>本章我们将探讨<strong>支持向量机</strong> ( <strong> SVMs </strong>)。<a id="id548" class="indexterm"/>我们将研究 Clojure 中的几个 SVM 实现，这些实现可用于使用一些给定的训练数据来构建和训练 SVM。</p><p>支持向量机是监督学习模型，用于回归和分类。然而，在这一章中，我们将集中讨论支持向量机环境中的分类问题。支持向量机在文本挖掘、化学分类、图像和手写识别中有应用。当然，我们不应该忽视这样一个事实，即机器学习模型的整体性能主要取决于训练数据的数量和性质，并且还受到我们用来对可用数据建模的机器学习模型的影响。</p><p>在最简单的形式中，SVM 通过估计在向量空间中表示的这两类之间的最优向量平面或<strong>超平面</strong> <a id="id549" class="indexterm"/>来分离和预测两类数据。<strong>超平面</strong>可以简单地定义为比周围空间少一个维度的平面。对于三维空间，我们将得到一个二维超平面。</p><p>基本 SVM 是一种使用线性分类的非概率二元分类器。除了线性分类之外，支持向量机还可以用于对多个类别执行非线性分类。支持向量机的一个有趣的方面是，估计的向量平面将在输入值的类别之间具有相当大且明显的差距。由于这一点，支持向量机通常具有良好的泛化性能，并且还实现了一种自动复杂度控制以避免过拟合。因此，支持向量机也被称为<strong>大间隔分类器</strong> <a id="id550" class="indexterm"/>。在这一章中，我们还将研究与其他分类器相比，支持向量机如何在输入数据的类别之间获得如此大的差距。关于支持向量机的另一个有趣的事实是，它们可以很好地适应建模的特征数量，因此，支持向量机通常用于处理大量特征的机器学习问题。</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>了解大幅度分类</h1></div></div></div><p>正如我们之前提到的，<a id="id551" class="indexterm"/>支持向量机对大范围的输入数据进行分类。让我们来看看这是如何实现的。我们使用逻辑分类模型的定义，我们之前在第 3 章、<em>分类数据</em>中描述过，作为支持向量机推理的基础。</p><p>我们可以使用 logistic 或<em> sigmoid </em>函数来分离两类输入值，正如我们在<a class="link" href="ch03.html" title="Chapter 3. Categorizing Data">第 3 章</a>、<em>分类数据</em>中所描述的。该函数可正式定义为输入变量<em> X </em>的函数，如下所示:</p><div><img src="img/4351OS_06_01.jpg" alt="Understanding large margin classification"/></div><p>在上式中，输出变量<img src="img/4351OS_06_02.jpg" alt="Understanding large margin classification"/>不仅取决于变量<img src="img/4351OS_06_03.jpg" alt="Understanding large margin classification"/>，还取决于系数<img src="img/4351OS_06_04.jpg" alt="Understanding large margin classification"/>。变量<img src="img/4351OS_06_03.jpg" alt="Understanding large margin classification"/>类似于我们模型中输入值的向量，术语<img src="img/4351OS_06_04.jpg" alt="Understanding large margin classification"/>是模型的参数向量。对于二进制分类，<em> Y </em>的值必须在 0 到 1 的范围内。此外，一组输入值的类别由输出变量<img src="img/4351OS_06_02.jpg" alt="Understanding large margin classification"/>更接近 0 还是 1 来确定。对于<em> Y </em>的这些值，项<img src="img/4351OS_06_05.jpg" alt="Understanding large margin classification"/>要么远大于 0，要么远大于 0。这可以正式表示如下:</p><div><img src="img/4351OS_06_06.jpg" alt="Understanding large margin classification"/></div><p>对于具有输入值<img src="img/4351OS_06_08.jpg" alt="Understanding large margin classification"/>和输出值<img src="img/4351OS_06_09.jpg" alt="Understanding large margin classification"/>的<img src="img/4351OS_06_07.jpg" alt="Understanding large margin classification"/>样本，我们将成本函数<img src="img/4351OS_06_10.jpg" alt="Understanding large margin classification"/>定义如下:</p><div><img src="img/4351OS_06_12.jpg" alt="Understanding large margin classification"/></div><div><div><h3 class="title"><a id="note30"/>注意</h3><p>注意术语<img src="img/4351OS_06_11.jpg" alt="Understanding large margin classification"/>代表从估计模型计算的输出变量。</p></div></div><p>对于逻辑分类模型，<img src="img/4351OS_06_11.jpg" alt="Understanding large margin classification"/>是应用于一组输入值<img src="img/4351OS_06_08.jpg" alt="Understanding large margin classification"/>时的逻辑函数值。我们可以简化并<a id="id552" class="indexterm"/>扩展前面等式中定义的成本函数中的求和项<img src="img/4351OS_06_13.jpg" alt="Understanding large margin classification"/>，如下所示:</p><div><img src="img/4351OS_06_14.jpg" alt="Understanding large margin classification"/></div><p>很明显，前面表达式中显示的成本函数取决于表达式中的两个对数项。因此，我们可以将成本函数表示为这两个对数项的函数，由项<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>表示。现在，让我们假设这两项如下式所示:</p><div><img src="img/4351OS_06_17.jpg" alt="Understanding large margin classification"/></div><p>函数<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>都是使用逻辑函数组成的。必须训练模拟逻辑函数的分类器，使得这两个函数在参数向量<img src="img/4351OS_06_04.jpg" alt="Understanding large margin classification"/>的所有可能值上最小化。我们可以使用<strong>铰链损失</strong>函数来逼近使用逻辑函数的线性分类器的期望行为(更多信息，请参考“损失函数都一样吗？”).我们现在将通过与逻辑函数的比较来研究铰链损失函数。下图描述了<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>函数相对于术语<img src="img/4351OS_06_18.jpg" alt="Understanding large margin classification"/>必须如何变化，以及如何使用逻辑和铰链损失函数对其建模:</p><div><img src="img/image1.jpg" alt="Understanding large margin classification"/></div><p>在上图<a id="id553" class="indexterm"/>所示的图中，逻辑函数表示为一条平滑曲线。可以看到，该函数在给定点之前迅速减小，然后以较低的速率减小。在这个例子中，发现逻辑函数的速率发生变化的点是<em> x = 0 </em>。铰链损耗函数通过使用在点<em> x = 0 </em>处相交的两条线段来近似这个值。有趣的是，这两个函数都模拟了以与输入值<em> x </em>成反比的速率变化的行为。类似地，我们可以使用铰链损失函数近似估算<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>函数的影响，如下所示:</p><div><img src="img/image2.jpg" alt="Understanding large margin classification"/></div><p>注意，<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>函数与<img src="img/4351OS_06_18.jpg" alt="Understanding large margin classification"/>项成正比。因此，我们可以通过<a id="id554" class="indexterm"/>模拟铰链损失函数来实现逻辑函数的分类能力，并且使用铰链损失函数构建的分类器将与使用逻辑函数的分类器表现得一样好。</p><p>如上图所示，铰链损失函数仅在点<img src="img/4351OS_06_21.jpg" alt="Understanding large margin classification"/>改变其值。这适用于功能<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>。因此，我们可以根据<img src="img/4351OS_06_23.jpg" alt="Understanding large margin classification"/>的值是大于还是小于 0，使用铰链损失函数来分离两类数据。在这种情况下，这两个类别之间几乎没有界限。为了提高分类的裕度，我们可以修改铰链损失函数，使得其值仅在<img src="img/4351OS_06_24.jpg" alt="Understanding large margin classification"/>或<img src="img/4351OS_06_25.jpg" alt="Understanding large margin classification"/>时大于 0。</p><p>对于两类数据，修正的铰链损失函数可以绘制如下。以下<a id="id555" class="indexterm"/>图描述了<img src="img/4351OS_06_25.jpg" alt="Understanding large margin classification"/>的情况:</p><div><img src="img/image3.jpg" alt="Understanding large margin classification"/></div><p>类似地，情况<img src="img/4351OS_06_24.jpg" alt="Understanding large margin classification"/>的修正铰链损失函数可由以下图表说明:</p><div><img src="img/image4.jpg" alt="Understanding large margin classification"/></div><p>注意<em>铰链</em>在<img src="img/4351OS_06_24.jpg" alt="Understanding large margin classification"/>的情况下出现在<em> -1 </em>处。</p><p>如果我们用<a id="id556" class="indexterm"/>铰链损失函数代替<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>函数，我们就得到一个支持向量机的优化问题(更多信息，请参考“支持向量网络”)，可以正式写成如下:</p><div><img src="img/4351OS_06_28.jpg" alt="Understanding large margin classification"/></div><p>在前一等式中，项<img src="img/4351OS_06_29.jpg" alt="Understanding large margin classification"/>是正则化参数。同样，当<img src="img/4351OS_06_30.jpg" alt="Understanding large margin classification"/>时，SVM 的行为受<img src="img/4351OS_06_15.jpg" alt="Understanding large margin classification"/>功能的影响大于受<img src="img/4351OS_06_16.jpg" alt="Understanding large margin classification"/>功能的影响，反之亦然。在一些上下文中，模型的正则化参数<img src="img/4351OS_06_29.jpg" alt="Understanding large margin classification"/>作为常数<em> C </em>添加到优化问题中，其中<em> C </em>类似于<img src="img/4351OS_06_32.jpg" alt="Understanding large margin classification"/>。优化问题的这种表示可以正式表达如下:</p><div><img src="img/4351OS_06_33.jpg" alt="Understanding large margin classification"/></div><p>由于我们只处理<a id="id557" class="indexterm"/>两类数据，其中<img src="img/4351OS_06_09.jpg" alt="Understanding large margin classification"/>为 0 或 1，我们可以重写前面描述的优化问题，如下所示:</p><div><img src="img/4351OS_06_34.jpg" alt="Understanding large margin classification"/></div><p>让我们尝试在一些训练数据上可视化 SVM 的行为。假设我们的训练数据中有两个输入变量<img src="img/4351OS_06_35.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_36.jpg" alt="Understanding large margin classification"/>。输入值及其类别可由以下图表表示:</p><div><img src="img/image5.jpg" alt="Understanding large margin classification"/></div><p>在前面的图中，训练数据中的两个类表示为圆形和方形。线性分类器会尝试将这些样本值划分为两个不同的类，并会产生一个判定边界，该边界可以由前面的曲线图中的任何一条线来表示。当然，分类器应该努力使公式化模型的总体误差最小化，同时也找到一个很好地概括数据的模型。一个<a id="id558" class="indexterm"/> SVM 也将尝试把样本数据分成两类，就像任何其他分类模型一样。然而，SVM 设法确定分离的超平面，该超平面被观察到在两类输入数据之间具有最大可能的余量。</p><p>SVM 的这种行为可以用下面的图来说明:</p><div><img src="img/4351OS_06_38_a.jpg" alt="Understanding large margin classification"/></div><p>如前面的曲线图所示，SVM 将确定分隔两个<a id="id559" class="indexterm"/>数据类的最佳超平面，这两个类之间具有最大可能的余量。从我们之前描述的 SVM 的优化问题，我们可以证明由 SVM 估计的分离超平面的方程如下:</p><div><img src="img/4351OS_06_40.jpg" alt="Understanding large margin classification"/></div><div><div><h3 class="title"><a id="note31"/>注</h3><p>注意，在前面的等式中，常数<img src="img/4351OS_06_39.jpg" alt="Understanding large margin classification"/>就是超平面的 y 截距。</p></div></div><p>为了更好地理解 SVM 是如何实现如此大的分离幅度的，我们需要使用一些基本的矢量运算。首先，我们可以如下定义给定向量的长度:</p><div><img src="img/4351OS_06_41.jpg" alt="Understanding large margin classification"/></div><div><img src="img/4351OS_06_42.jpg" alt="Understanding large margin classification"/></div><p>另一种经常用来描述支持向量机的运算是两个向量的内积。两个给定向量的内积可以正式定义如下:</p><div><img src="img/4351OS_06_43.jpg" alt="Understanding large margin classification"/></div><div><div><h3 class="title"><a id="note32"/>注</h3><p>注意，只有当两个向量长度相同时，这两个向量的内积才存在。</p></div></div><p>如<a id="id560" class="indexterm"/>上式所示，两个矢量<img src="img/4351OS_06_45.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_46.jpg" alt="Understanding large margin classification"/>的内积<img src="img/4351OS_06_44.jpg" alt="Understanding large margin classification"/>等于<img src="img/4351OS_06_45.jpg" alt="Understanding large margin classification"/>的转置和矢量<img src="img/4351OS_06_46.jpg" alt="Understanding large margin classification"/>的点积。另一种表示两个向量内积的方法是将一个向量投影到另一个向量上，如下所示:</p><div><img src="img/4351OS_06_47.jpg" alt="Understanding large margin classification"/></div><p>请注意，<img src="img/4351OS_06_48.jpg" alt="Understanding large margin classification"/>项相当于矢量 V 和矢量 u 的转置的矢量积<img src="img/4351OS_06_49.jpg" alt="Understanding large margin classification"/>。由于表达式<img src="img/4351OS_06_50.jpg" alt="Understanding large margin classification"/>相当于矢量的积<img src="img/4351OS_06_51.jpg" alt="Understanding large margin classification"/>，我们可以重写优化问题，我们之前已经根据输入变量到输出变量的投影描述过该问题。这可以正式表示如下:</p><div><img src="img/4351OS_06_52.jpg" alt="Understanding large margin classification"/></div><p>因此，SVM 试图最小化参数向量<img src="img/4351OS_06_04.jpg" alt="Understanding large margin classification"/>中元素的平方和，同时确保分隔两个<a id="id561" class="indexterm"/>类数据的最佳超平面存在于两个平面和<img src="img/4351OS_06_53.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_54.jpg" alt="Understanding large margin classification"/>之间。这两个平面被称为 SVM 的<strong>支持向量</strong>。因为我们必须最小化参数向量<img src="img/4351OS_06_04.jpg" alt="Understanding large margin classification"/>中元素的值，所以投影<img src="img/4351OS_06_55.jpg" alt="Understanding large margin classification"/>必须足够大以确保<img src="img/4351OS_06_56.jpg" alt="Understanding large margin classification"/>和<img src="img/4351OS_06_57.jpg" alt="Understanding large margin classification"/>:</p><div><img src="img/4351OS_06_58.jpg" alt="Understanding large margin classification"/></div><p>因此，SVM 将确保输入变量<img src="img/4351OS_06_08.jpg" alt="Understanding large margin classification"/>在输出变量<img src="img/4351OS_06_09.jpg" alt="Understanding large margin classification"/>上的投影尽可能大。这意味着 SVM 将在训练数据中找到两类输入值之间的最大可能差值。</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec11"/>支持向量机的替代形式</h2></div></div></div><p>我们现在将描述代表 SVM 的几个可选形式。本节的剩余部分可以安全地跳过，但是建议读者了解这些形式，因为它们也是广泛使用的支持向量机的符号。</p><p>如果<img src="img/4351OS_06_59.jpg" alt="Alternative forms of SVMs"/>是由 SVM 估计的超平面的法线，我们可以使用下面的等式表示这个分离超平面:</p><div><img src="img/4351OS_06_61.jpg" alt="Alternative forms of SVMs"/></div><div><div><h3 class="title"><a id="note33"/>注</h3><p>注意，在前面的方程中，<img src="img/4351OS_06_60.jpg" alt="Alternative forms of SVMs"/>项是超平面的 y 截距，类似于我们之前描述的超平面方程中的<img src="img/4351OS_06_39.jpg" alt="Alternative forms of SVMs"/>项。</p></div></div><p>该超平面的两个外围支持向量具有以下等式:</p><div><img src="img/4351OS_06_62.jpg" alt="Alternative forms of SVMs"/></div><p>我们可以使用表达式<img src="img/4351OS_06_63.jpg" alt="Alternative forms of SVMs"/>来确定给定输入值集合<a id="id564" class="indexterm"/>的类别。如果这个表达式的值小于或等于-1，那么我们可以说<a id="id565" class="indexterm"/>输入值属于两类数据中的一类。类似地，如果表达式<img src="img/4351OS_06_63.jpg" alt="Alternative forms of SVMs"/>的值大于或等于 1，则预测输入值属于第二类。这可以正式表示如下:</p><div><img src="img/4351OS_06_64.jpg" alt="Alternative forms of SVMs"/></div><p>上式中描述的两个不等式可以合并成一个不等式，如下所示:</p><div><img src="img/4351OS_06_65.jpg" alt="Alternative forms of SVMs"/></div><p>因此，我们可以简明地将支持向量机的优化问题重写如下:</p><div><img src="img/4351OS_06_66.jpg" alt="Alternative forms of SVMs"/></div><p>在前面等式中定义的约束问题中，我们使用参数向量<img src="img/4351OS_06_04.jpg" alt="Alternative forms of SVMs"/>的法线<img src="img/4351OS_06_59.jpg" alt="Alternative forms of SVMs"/>而不是<a id="id566" class="indexterm"/>来参数化优化问题。通过使用拉格朗日乘数<img src="img/4351OS_06_67.jpg" alt="Alternative forms of SVMs"/>，我们可以将优化问题表达如下:</p><div><img src="img/4351OS_06_68.jpg" alt="Alternative forms of SVMs"/></div><p>这种形式的 SVM 优化问题被称为<strong>原始形式</strong> <a id="id567" class="indexterm"/>。请注意，在实践中，只有少数拉格朗日乘数的值会大于 0。此外，该解可以用输入向量<img src="img/4351OS_06_08.jpg" alt="Alternative forms of SVMs"/>和输出变量<img src="img/4351OS_06_09.jpg" alt="Alternative forms of SVMs"/>的线性组合<a id="id568" class="indexterm"/>表示，如下所示:</p><div><img src="img/4351OS_06_69.jpg" alt="Alternative forms of SVMs"/></div><p>我们还可以用<em>对偶形式</em>来表达 SVM 的优化问题，这是一种约束表示，可描述如下:</p><div><img src="img/4351OS_06_70.jpg" alt="Alternative forms of SVMs"/></div><p>在前面的<a id="id570" class="indexterm"/>方程中描述的约束问题<a id="id569" class="indexterm"/>中，函数<img src="img/4351OS_06_71.jpg" alt="Alternative forms of SVMs"/>被称为<strong>核函数</strong> <a id="id571" class="indexterm"/>，我们将在本章的后面部分讨论更多关于这个函数在支持向量机中的作用。</p></div></div></div>





<title>Linear classification using SVMs</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>使用支持向量机的线性分类</h1></div></div></div><p>如前所述，支持向量机可用于对两个不同的类别进行线性分类。SVM <a id="id572" class="indexterm"/>将试图找到一个分离这两个类别的超平面，使得估计的超平面描述在我们的模型中这两个类别之间的最大可实现分离裕度。</p><p>例如，两类数据之间的估计超平面可以使用以下曲线图来可视化:</p><div><img src="img/4351OS_06_72.jpg" alt="Linear classification using SVMs"/></div><p>如前面的曲线图所示，圆圈和十字用于表示样本数据中的两类<a id="id573" class="indexterm"/>输入值。这条线表示 SVM 的估计超平面。</p><p>实际上，使用实现的 SVM 比实现我们自己的 SVM 更有效。有几个库实现了移植到多种编程语言的 SVM。一个这样的库是<strong>LibLinear</strong><a id="id574" class="indexterm"/>(<a class="ulink" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">http://www.csie.ntu.edu.tw/~cjlin/liblinear/</a>)，它使用 SVM 实现了一个线性分类器。LibLinear 的 Clojure 包装器是<code class="literal">clj-liblinear</code>(<a class="ulink" href="https://github.com/lynaghk/clj-liblinear">https://github.com/lynaghk/clj-liblinear</a>)，我们现在将探索如何使用这个库来轻松构建一个线性分类器。</p><div><div><h3 class="title"><a id="note34"/>注意</h3><p>通过向<code class="literal">project.clj</code>文件添加以下依赖关系，可以将<code class="literal">clj-liblinear</code>库添加到 Leiningen 项目中:</p><div><pre class="programlisting">[clj-liblinear "0.1.0"]</pre></div><p>对于下面的示例，命名空间声明应该类似于下面的声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use [clj-liblinear.core :only [train predict]]))</pre></div></div></div><p>首先，让我们生成一些训练数据，这样我们就有两类输入值。对于本例，我们将模拟两个输入变量，如下所示:</p><div><pre class="programlisting">(def training-data
  (concat
   (repeatedly
    500 #(hash-map :class 0
                   :data {:x (rand)
                          :y (rand)}))
   (repeatedly
    500 #(hash-map :class 1
                   :data {:x (- (rand))
                          :y (- (rand))}))))</pre></div><p>使用前面代码中所示的<code class="literal">repeatedly</code>函数<a id="id575" class="indexterm"/>，我们生成两个地图序列。这两个序列中的每个地图都包含关键字<code class="literal">:class</code>和<code class="literal">:data</code>。<code class="literal">:class</code>键的值代表输入值的类别，而<code class="literal">:data</code>键的值本身是另一个带有<code class="literal">:x</code>和<code class="literal">:y</code>键的映射。键<code class="literal">:x</code>和<code class="literal">:y</code>的值代表<a id="id576" class="indexterm"/>我们训练数据中的两个输入变量。这些输入变量的值是使用<code class="literal">rand</code>功能随机生成的。生成训练数据，使得如果两个输入值都是正的，则一组输入值的类别是<code class="literal">0</code>，如果两个输入值都是负的，则一组输入值的类别是<code class="literal">1</code>。如前面的代码所示，使用<code class="literal">repeatedly</code>函数为两个类生成总共 1000 个样本作为两个序列，然后使用<code class="literal">concat</code>函数将其组合成一个序列。我们可以在 REPL 中检查这些输入值，如下所示:</p><div><pre class="programlisting">user&gt; (first training-data)
{:class 0,
 :data {:x 0.054125811753944264, :y 0.23575052637986382}}
user&gt; (last training-data)
{:class 1,
 :data {:x -0.8067872409710037, :y -0.6395480020409928}}</pre></div><p>我们可以使用生成的训练数据来创建和训练 SVM。为此，我们使用<code class="literal">train</code>功能。<code class="literal">train</code>函数接受两个参数，包括一系列输入值和一系列输出值。假设两个序列的顺序相同。出于分类的目的，可以将输出变量设置为一组给定输入值的类，如以下代码所示:</p><div><pre class="programlisting">(defn train-svm []
  (train
   (map :data training-data)
   (map :class training-data)))</pre></div><p>前面代码中定义的<code class="literal">train-svm</code>函数<a id="id577" class="indexterm"/>将用<code class="literal">training-data</code>序列实例化和训练一个 SVM。现在，我们可以使用训练好的 SVM 通过<code class="literal">predict</code>函数<a id="id578" class="indexterm"/>进行分类，如下面的代码所示:</p><div><pre class="programlisting">user&gt; (def svm (train-svm))
#'user/svm
user&gt; (predict svm {:x 0.5 :y 0.5})
0.0
user&gt; (predict svm {:x -0.5 :y 0.5})
0.0
user&gt; (predict svm {:x -0.4 :y 0.4})
0.0
user&gt; (predict svm {:x -0.4 :y -0.4})
1.0
user&gt; (predict svm {:x 0.5 :y -0.5})
1.0</pre></div><p><code class="literal">predict</code>函数需要<a id="id579" class="indexterm"/>两个参数，它们是一个 SVM 的实例和一组输入值。</p><p>如前面的代码所示，我们使用<code class="literal">svm</code>变量来表示一个经过训练的 SVM。然后，我们将<code class="literal">svm</code>变量传递给<code class="literal">predict</code>函数，同时传递的还有一组新的输入值，我们打算预测这些值的类别。观察到<code class="literal">predict</code>函数的输出与训练数据一致。有趣的是，只要输入值<code class="literal">:y</code>是正的，分类器就将任意一组输入值的类预测为<code class="literal">0</code>，反之<code class="literal">:y</code>特征为负的一组输入值的类预测为<code class="literal">1</code>。</p><p>在前面的示例中，我们使用了 SVM 来执行分类。然而，经过训练的 SVM 的输出变量总是一个数字。因此，我们也可以像前面代码中描述的那样使用<code class="literal">clj-liblinear</code>库来训练一个回归模型。</p><p><code class="literal">clj-liblinear</code>库还支持更复杂的 SVM 要素类型，如矢量、地图和集合。我们现在将演示如何训练一个使用集合作为输入变量的分类器，而不是像前面的例子中所示的普通数字。假设我们有一个来自给定用户的 Twitter feed 的 tweets 流。假设用户将手动将这些推文分类到特定的类别中，该类别是从一组预定义的类别中选择的。这个经过处理的 tweets 序列可以表示如下:</p><div><pre class="programlisting">(def tweets
  [{:class 0 :text "new lisp project released"}
   {:class 0 :text "try out this emacs package for common lisp"}
   {:class 0 :text "a tutorial on guile scheme"}

   {:class 1 :text "update in javascript library"}
   {:class 1 :text "node.js packages are now supported"}
   {:class 1 :text "check out this jquery plugin"}

   {:class 2 :text "linux kernel news"}
   {:class 2 :text "unix man pages"}
   {:class 2 :text "more about linux software"}])</pre></div><p>前面代码中定义的 tweets 向量包含几个映射，每个映射都有键<code class="literal">:class</code>和<code class="literal">:text</code>。<code class="literal">:text</code>关键字包含一条推文的文本，我们将使用<code class="literal">:text</code>关键字包含的值训练一个 SVM。但是我们不能逐字使用文本，因为一些<a id="id580" class="indexterm"/>单词可能会在 tweet 中重复。此外，我们需要一些方法来处理本文中字母的大小写。让我们定义一个函数来将这个文本转换成一个集合，如下所示:</p><div><pre class="programlisting">(defn extract-words [text]
  (-&gt;&gt; #" "
       (split text)
       (map lower-case)
       (into #{})))</pre></div><p>前面代码中定义的<code class="literal">extract-words</code>函数<a id="id581" class="indexterm"/>会将参数<code class="literal">text</code>表示的任何字符串转换成一组全部为小写的单词。为了创建一个集合，我们使用<code class="literal">(into #{})</code>表单。根据定义，这个集合不会包含任何重复的值。注意<code class="literal">-&gt;&gt;</code>线程宏在<code class="literal">extract-words</code>功能定义中的使用。</p><div><div><h3 class="title"><a id="note36"/>注意</h3><p>在<code class="literal">extract-words</code>函数中，<code class="literal">-&gt;&gt;</code>形式可以等价地写成<code class="literal">(into #{} (map lower-case (split text #" ")))</code>。</p></div></div><p>我们可以检查 REPL 中<code class="literal">extract-words</code>函数的行为，如下所示:</p><div><pre class="programlisting">user&gt; (extract-words "Some text to extract some words")
#{"extract" "words" "text" "some" "to"}</pre></div><p>使用<code class="literal">extract-words</code>函数<a id="id582" class="indexterm"/>，我们可以用一组字符串作为特征变量有效地训练一个 SVM。如前所述，这可以通过使用<code class="literal">train</code>功能<a id="id583" class="indexterm"/>来完成，如下所示:</p><div><pre class="programlisting">(defn train-svm []
  (train (-&gt;&gt; tweets
              (map :text)
              (map extract-words))
         (map :class tweets)))</pre></div><p>前面代码中定义的<code class="literal">train-svm</code>函数<a id="id584" class="indexterm"/>将使用<code class="literal">train</code>和<code class="literal">extract-word</code> s 函数，使用 tweets 变量中经过处理的训练数据创建并训练一个 SVM。我们现在需要在下面的代码中编写<code class="literal">predict</code>和<code class="literal">extract-words</code>函数，这样我们就可以预测给定 tweet 的类别:</p><div><pre class="programlisting">(defn predict-svm [svm text]
  (predict
    svm (extract-words text)))</pre></div><p>前面代码中定义的<code class="literal">predict-svm</code>函数<a id="id585" class="indexterm"/>可以用来对给定的 tweet 进行分类。我们可以为 REPL 的一些任意推文验证预测的 SVM 的<a id="id586" class="indexterm"/>类，如下所示:</p><div><pre class="programlisting">user&gt; (def svm (train-svm))
#'user/svm
user&gt; (predict-svm svm "a common lisp tutorial")
0.0
user&gt; (predict-svm svm "new javascript library")
1.0
user&gt; (predict-svm svm "new linux kernel update")
2.0</pre></div><p>总之，<code class="literal">clj-liblinear</code>库允许我们用大多数 Clojure 数据类型轻松构建和训练 SVM。这个库施加的唯一限制是，训练数据必须可以线性分离到我们模型的类中。我们将在本章接下来的部分研究如何构建更复杂的分类器。</p></div>





<title>Using kernel SVMs</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>使用内核支持向量机</h1></div></div></div><p>在某些情况下，可用的<a id="id587" class="indexterm"/>训练数据不是线性可分的，我们无法使用线性分类对数据建模。因此，我们需要使用不同的模型来拟合非线性数据。如第 4 章<a class="link" href="ch04.html" title="Chapter 4. Building Neural Networks">、<em>构建神经网络</em>中所述，人工神经网络可用于对此类数据建模。在本节中，我们将介绍如何使用核函数拟合非线性数据的 SVM。包含核函数的 SVM 被称为<strong>核支持向量机</strong>。请注意，在本节中，术语 SVM 和内核 SVM 可以互换使用。核 SVM 将基于非线性决策边界对数据进行分类，决策边界的性质取决于 SVM 使用的核函数。为了说明这种行为，内核 SVM 将训练数据分为两类，如下图所示:</a></p><div><img src="img/4351OS_06_73.jpg" alt="Using kernel SVMs"/></div><p>在支持向量机中使用核函数的概念实际上是基于数学变换。SVM 内核函数的作用<a id="id588" class="indexterm"/>是转换训练数据中的输入变量，使转换后的特征可线性分离。由于 SVM 根据较大的裕量对输入数据进行线性划分，因此在非线性空间中也可以观察到两类数据之间的这种较大差距。</p><p>内核函数被写成<img src="img/4351OS_06_71.jpg" alt="Using kernel SVMs"/>，其中<img src="img/4351OS_06_08.jpg" alt="Using kernel SVMs"/>是来自训练数据的输入值的向量，<img src="img/4351OS_06_74.jpg" alt="Using kernel SVMs"/>是<img src="img/4351OS_06_75.jpg" alt="Using kernel SVMs"/>的变换向量。函数<img src="img/4351OS_06_71.jpg" alt="Using kernel SVMs"/>表示这两个向量的相似度，等价于这两个向量在变换空间中的内积。如果输入向量<img src="img/4351OS_06_75.jpg" alt="Using kernel SVMs"/>有给定的类，那么当这两个向量的核函数值接近 1 时，即<img src="img/4351OS_06_76.jpg" alt="Using kernel SVMs"/>时，向量<img src="img/4351OS_06_74.jpg" alt="Using kernel SVMs"/>的类与向量<img src="img/4351OS_06_75.jpg" alt="Using kernel SVMs"/>的类相同。核函数可以用数学方法表示如下:</p><div><img src="img/4351OS_06_77.jpg" alt="Using kernel SVMs"/></div><p>在上式中，函数<img src="img/4351OS_06_78.jpg" alt="Using kernel SVMs"/>执行从非线性空间<img src="img/4351OS_06_79.jpg" alt="Using kernel SVMs"/>到线性空间<img src="img/4351OS_06_46.jpg" alt="Using kernel SVMs"/>的变换。注意不需要<img src="img/4351OS_06_78.jpg" alt="Using kernel SVMs"/>的显式表示，知道<img src="img/4351OS_06_46.jpg" alt="Using kernel SVMs"/>是内积空间就够了。尽管我们可以自由选择任意核函数来模拟给定的训练数据<a id="id589" class="indexterm"/>，但我们必须努力减少最小化公式化 SVM 模型的成本函数的问题。因此，通常选择核函数，使得计算 SVM 判决边界仅需要确定变换特征空间中的矢量的点积<img src="img/4351OS_06_46.jpg" alt="Using kernel SVMs"/>。</p><p>SVM 的核函数的常见选择是<strong>多项式核函数</strong> <a id="id590" class="indexterm"/>，也称为<strong>多项式核函数</strong>、<a id="id591" class="indexterm"/>，其将训练数据建模为原始特征变量的多项式。读者可能会从<a class="link" href="ch05.html" title="Chapter 5. Selecting and Evaluating Data">第 5 章</a>、<em>选择和评估数据</em>中回忆起，我们已经讨论了多项式特征如何能够极大地提高给定机器学习模型的性能。多项式核函数可以被认为是应用于支持向量机的这一概念的扩展。该函数可以正式表示如下。</p><div><img src="img/4351OS_06_80.jpg" alt="Using kernel SVMs"/></div><p>在上式中，术语<img src="img/4351OS_06_81.jpg" alt="Using kernel SVMs"/>代表多项式特征的最高次数。此外，当(常数)<img src="img/4351OS_06_82.jpg" alt="Using kernel SVMs"/>时，内核被称为<a id="id592" class="indexterm"/> <strong>同质</strong>。</p><p>另一个广泛使用的核函数是<strong>高斯核函数</strong> <a id="id593" class="indexterm"/>。大多数精通线性代数的读者不需要介绍高斯函数。<a id="id594" class="indexterm"/>要知道这个函数代表数据的正态分布，其中的数据点更接近数据的平均值，这一点很重要。</p><p>在支持向量机的上下文中，高斯核函数可用于表示一个模型，在该模型中，训练数据中的两个类之一具有接近任意平均值的输入变量值。高斯核函数可以正式表示如下:</p><div><img src="img/4351OS_06_83.jpg" alt="Using kernel SVMs"/></div><p>在上式中定义的高斯核函数中，<img src="img/4351OS_06_84.jpg" alt="Using kernel SVMs"/>项代表训练数据的方差，并代表高斯核的<em>宽度</em>。</p><p>内核函数的另一个流行选择是对字符串值执行<a id="id596" class="indexterm"/>操作的<strong>字符串内核函数</strong> <a id="id595" class="indexterm"/>。对于术语<em>字符串</em>，我们指的是有限的符号序列。字符串核函数本质上是<a id="id597" class="indexterm"/>测量两个给定字符串之间的相似性。如果传递给字符串内核函数的两个字符串相同，那么这个函数返回的值将是<code class="literal">1</code>。因此，字符串核函数对于将要素表示为字符串的数据建模非常有用。</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec12"/>序列最小优化</h2></div></div></div><p>SVM 的优化问题<a id="id598" class="indexterm"/>可以用<strong>序贯最小优化</strong> ( <strong> SMO </strong>)来解决。SVM 的优化问题是跨越几个维度的成本<a id="id599" class="indexterm"/>函数的数值优化，以便减少训练的 SVM 的总体误差。在实践中，这必须通过数值优化技术来完成。对 SMO 算法的完整讨论超出了本书的范围。但是，我们必须注意到，该算法通过<em>分治</em>技术来解决优化问题。本质上，SMO 将多维度的优化问题分成几个更小的二维问题，这些问题可以解析求解(更多信息，请参考<em>序列最小优化:一种训练支持向量机的快速算法</em>)。</p><p><strong> LibSVM </strong> <a id="id600" class="indexterm"/>是一个流行的库，它实现了 SMO 来训练一个 SVM。<code class="literal">svm-clj</code>库是 LibSVM 的 Clojure 包装器，现在我们将探索如何使用这个库来构建 SVM 模型。</p><div><div><h3 class="title"><a id="note37"/>注意</h3><p>通过向<code class="literal">project.clj</code>文件添加以下依赖关系，可以将<code class="literal">svm-clj</code>库添加到 Leiningen 项目中:</p><div><pre class="programlisting">[svm-clj "0.1.3"]</pre></div><p>对于下面的示例，命名空间声明应该类似于下面的声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use svm.core))</pre></div></div></div><p>本例将使用简化版本的<strong> SPECT 心脏</strong>数据集<a id="id601" class="indexterm"/>(<a class="ulink" href="http://archive.ics.uci.edu/ml/datasets/SPECT+Heart">http://archive.ics.uci.edu/ml/datasets/SPECT+Heart</a>)。该数据集描述了使用<strong>单质子发射计算机断层扫描</strong> ( <strong> SPECT </strong>)图像对几名心脏病患者的诊断。<a id="id602" class="indexterm"/>原始数据集总共包含 267 个样本，其中每个样本<a id="id603" class="indexterm"/>有 23 个特征。数据集的输出变量描述了给定患者的阳性或阴性诊断，分别用+1 或-1 表示。</p><p>对于这个例子，训练数据存储在一个名为<code class="literal">features.dat</code>的文件中。这个文件必须放在 Leiningen 项目的<code class="literal">resources/</code>目录中才能使用。该文件包含几个输入要素和这些输入值的类别。让我们看看该文件中的以下示例值之一:</p><div><pre class="programlisting">+1 2:1 3:1 4:-0.132075 5:-0.648402 6:1 7:1 8:0.282443 9:1 10:0.5 11:1 12:-1 13:1</pre></div><p>如前面的代码行所示，第一个值<code class="literal">+1</code>表示样本的类别，其他值表示输入变量。请注意，输入变量的索引也已给出。此外，前面示例中第一个特性的值是<code class="literal">0</code>，因为没有使用<code class="literal">1:</code>键提及它。从前面一行可以清楚地看出，每个样本最多有 12 个特性。按照 LibSVM 的规定，所有样本值必须符合这种格式。</p><p>我们可以使用这个样本数据来训练 SVM。为此，我们使用了<code class="literal">svm-clj</code>库中的<code class="literal">train-model</code>函数。此外，由于我们必须首先从文件中加载样本数据，我们将需要首先使用以下代码调用<code class="literal">read-dataset</code>函数:</p><div><pre class="programlisting">(def dataset (read-dataset "resources/features.dat"))

(def model (train-model dataset))</pre></div><p>由前面代码中定义的模型变量表示的已训练 SVM 现在可用于预测一组输入值的类别。<code class="literal">predict</code>功能可用于此目的。为简单起见，我们将使用数据集变量本身的一个样本值，如下所示:</p><div><pre class="programlisting">user&gt; (def feature (last (first dataset)))
#'user/feature
user&gt; feature
{1 0.708333, 2 1.0, 3 1.0, 4 -0.320755, 5 -0.105023,
 6 -1.0, 7 1.0, 8 -0.4198, 9 -1.0, 10 -0.2258, 12 1.0, 13 -1.0}
user&gt; (feature 1)
0.708333
user&gt; (predict model feature)
1.0</pre></div><p>如前面代码中的 REPL 输出所示，<code class="literal">dataset</code>可以被视为一系列地图。<a id="id605" class="indexterm"/>每个映射包含一个代表样本中输出变量的值的键。在<code class="literal">dataset</code>图中这个键的值是另一个图，代表给定<a id="id606" class="indexterm"/>样本的输入变量。由于<code class="literal">feature</code>变量代表一个地图，我们可以将其作为一个函数调用，如前面代码中的<code class="literal">(feature 1)</code>调用所示。</p><p>预测值与一组给定输入值的输出变量或类的实际值一致。总之，<code class="literal">svm-clj</code>库为我们提供了一个简单明了的 SVM 实现。</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec13"/>使用内核函数</h2></div></div></div><p>正如我们之前提到的，<a id="id607" class="indexterm"/>当我们需要拟合一些非线性数据时，我们可以为 SVM 选择一个核函数。我们现在将演示如何使用<code class="literal">clj-ml</code>库在实践中实现这个<a id="id608" class="indexterm"/>。由于这个库已经在前面的章节中讨论过了，我们将不会关注 SVM 的完整训练，而是关注如何创建一个使用内核函数的 SVM。</p><div><div><h3 class="title"><a id="note39"/>注</h3><p>对于下面的示例，命名空间声明应该类似于下面的声明:</p><div><pre class="programlisting">(ns my-namespace
  (:use [clj-ml classifiers kernel-functions]))</pre></div></div></div><p>来自<code class="literal">clj-ml.kernel-functions</code>名称空间的函数<code class="literal">make-kernel-function</code>用于创建可用于 SVM 的内核函数。例如，我们可以通过向这个函数传递:<code class="literal">polynomic</code>关键字来创建一个多项式核函数，如下所示:</p><div><pre class="programlisting">(def K (make-kernel-function :polynomic {:exponent 3}))</pre></div><p>如前一行所示，由变量<code class="literal">K</code>定义的多项式核函数的多项式次数为<code class="literal">3</code>。类似地，我们也可以使用<code class="literal">:string</code>关键字创建一个字符串内核函数，如下所示:</p><div><pre class="programlisting">(def K (make-kernel-function :string))</pre></div><p>在<code class="literal">clj-ml</code>库中有几个这样的内核函数，我们鼓励读者在这个库中探索更多的内核函数。这个名称空间的文档可以在<a class="ulink" href="http://antoniogarrote.github.io/clj-ml/clj-ml.kernel-functions-api.html">http://antoniogarrote . github . io/clj-ml/clj-ml . kernel-functions-API . html</a>上找到。我们可以通过指定<code class="literal">:support-vector-machine</code>和<code class="literal">:smo</code>关键字，使用<code class="literal">make-classifier</code>函数创建一个 SVM；以及带有关键字选项<code class="literal">:kernel-function</code>的内核函数<a id="id609" class="indexterm"/>，如下所示:</p><div><pre class="programlisting">(def classifier
  (make-classifier :support-vector-machine :smo
                   :kernel-function K))</pre></div><p>我们现在可以训练由变量分类器表示的 SVM <a id="id610" class="indexterm"/>，就像我们在前面章节中所做的那样。因此，<code class="literal">clj-ml</code>库允许我们创建展示给定内核函数的 SVM。</p></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>总结</h1></div></div></div><p>在这一章中，我们探讨了支持向量机以及如何用它们来拟合线性和非线性数据。以下是我们讨论过的其他主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我们已经研究了支持向量机如何能够进行大范围分类，以及支持向量机优化问题的各种形式</li><li class="listitem" style="list-style-type: disc">我们已经讨论了如何使用核函数和 SMO 来训练具有非线性样本数据的 SVM</li><li class="listitem" style="list-style-type: disc">我们还展示了如何使用几个 Clojure 库来构建和训练 SVM</li></ul></div><p>我们将在下一章把重点转移到无监督学习，我们将探索聚类技术来模拟这些类型的机器学习问题。</p></div>
</body></html>