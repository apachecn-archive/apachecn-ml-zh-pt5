<html><head/><body>









  <title>Chapter_7</title>

  

  







  <div><h1 class="chapterNumber">七</h1>

    <h1 id="_idParaDest-126" class="chapterTitle">用朴素贝叶斯优化区块链</h1>

    <p class="normal">在这个由三部分组成的章节中，我们将使用区块链通过朴素贝叶斯优化供应链。为了实现这一目标，我们将首先以理解如何使用加密货币生成区块链为例。</p>

    <p class="normal">区块链已经进入公司，并在这里呆了下来。数百家大公司已经实现了 IBM Hyperledger。这些公司的供应商将逐渐加入网络。由于有数百万行代码需要更新新功能和维护，区块链公司将在未来许多年继续工作。</p>

    <p class="normal">开采加密货币是区块链最广为人知的用途。加密货币正在世界各地发展。本章首先以比特币为例，解释了区块链的矿业是如何运作的。</p>

    <p class="normal">然后，我们将继续分析如何将区块链用于不同于生成加密货币的目的。例如，公司使用区块链记录公司之间的交易。</p>

    <p class="normal">IBM 成立于 1911 年，是当今该领域最有经验的公司。谷歌、亚马逊和微软也提供创造历史的机器学习平台。然而，IBM 提供了机器学习平台，这些平台得到了该公司 100 多年经验的支持。</p>

    <p class="normal">IBM 在计算机和软件市场的多年经历有些坎坷。一些糟糕的决定给公司带来了很多世界范围的问题。IBM 从这些错误中吸取了教训，现在提供了强大的解决方案，包括 IBM Hyperledger for 区块链解决方案。IBM 提倡在公司交易中使用区块链。</p>

    <p class="normal">我们将最终转向本章的第三部分，这一部分解释了区块链对世界各地的公司意味着什么，以及如何使用信息区块链来提供具有人工智能的优化算法。朴素贝叶斯将应用于区块链样本，以优化库存水平。</p>

    <p class="normal">本章将涵盖以下主题:</p>

    <ul>

      <li class="list">区块链的背景</li>

      <li class="list">利用区块链挖掘比特币</li>

      <li class="list">使用区块链进行商业交易</li>

      <li class="list">区块链的块如何提供在公司之间共享信息的独特方式</li>

      <li class="list">将人工智能应用于区块链的区块，以预测和建议交易</li>

      <li class="list">朴素贝叶斯</li>

      <li class="list">如何对区块链的块使用朴素贝叶斯来预测进一步的事务和块</li>

    </ul>

    <p class="normal">让我们先简单介绍一下区块链。</p>

    <h1 id="_idParaDest-127" class="title">第一部分-区块链技术的背景</h1>

    <p class="normal">在本节中，我们将和区块链一起探讨加密货币挖掘。用区块链生产比特币使这项技术具有了颠覆性。本节的目的是在继续区块链技术的后续应用之前，理解区块链探险是如何开始的。</p>

    <p class="normal">区块链技术将改变每个领域的交易。区块链出现在 2008 年。没有人确切知道是谁发明了它们。每个块都包含其前身(前一个块)的加密散列、日期时间(时间戳)数据和有关事务的信息。</p>

    <p class="normal">1000 多年来，交易大多是本地簿记系统。在过去的 100 年里，尽管计算机时代改变了信息管理的方式，但事情并没有改变太多。每家公司继续对自己的交易保密，只是通过繁琐的系统分享一些信息。</p>

    <p class="normal"><strong class="bold">区块链</strong>使交易<strong class="bold">区块</strong>对产生交易的全球网络可见。</p>

    <p class="normal">要记住的基本概念是<strong class="bold">共享</strong>和<strong class="bold">隐私控制</strong>。这两种想法似乎造成了认知上的不一致，这是无法解决的。然而这个问题已经解决了，它将改变世界。</p>

    <p class="normal">当一个块(任何种类的事务)被生成时，它被整个网络共享。如果该块的监管者希望该信息保持私有，则读取该块内的信息的许可仍然是可管理的，因此是私有的。</p>

    <p class="normal">无论目标是通过区块挖掘比特币，还是使用区块进行交易，人工智能都会很快增强这种创新。</p>

    <p class="normal">在接下来的章节中，我们将更详细地讨论区块链及其应用。了解如何生产加密货币的区块将使我们能够掌握区块链技术。一旦我们理解了区块链技术，就更容易理解这种安全的加密方法如何应用于加密货币之外的任何类型的商业交易。我们先去挖矿吧！</p>

    <h2 id="_idParaDest-128" class="title">挖掘比特币</h2>

    <p class="normal">在区块链创建一个区块并不一定会产生比特币，这是一种与其他交易形式一样的交易形式。但了解如何挖掘加密货币为了解区块链以及如何将它们应用到许多其他领域提供了一个很好的方法。</p>

    <p class="normal">挖掘一个比特币意味着为一个有效的交易创建一个数学块，并将这个块添加到链中；区块链:</p>

    <p class="center"><em class="italics">区块链</em> = { <em class="italics">区块</em> <sub> 1 </sub>，<em class="italics">区块</em> <sub> 2 </sub>，<em class="italics">区块刚加了</em> … <em class="italics">区块</em> <sub style="font-style: italic;"> n </sub> }</p>

    <p class="normal">区块链不能回到过去。这就像生活中的时间约会功能。在第<em class="italics">分钟 m </em>时，你做某件事，在第<em class="italics">分钟 m </em>时+ 1 件事，在第<em class="italics">分钟 m </em> + <em class="italics"> n </em>件事，以此类推。你不能回到过去。木已成舟。</p>

    <p class="normal">当一个区块被添加到比特币链中时，就没有办法撤销交易。</p>

    <p class="normal">比特币挖矿的全球网络<a id="_idIndexMarker303"/>由<strong class="bold">个节点</strong>组成。使用适当的软件，您可以打开一个端口，分配大约 150+ GB 的磁盘空间，并生成新的数据块。这些节点相互通信，并将信息转发给整个网络中的其他节点。</p>

    <p class="normal">一个节点要成为矿工，它必须解决复杂的数学难题，这是比特币程序的一部分。</p>

    <p class="normal">要解决这个难题，软件必须找到一个与生成的块中的数据相结合的特定范围内的数字。该数字通过哈希函数传递。</p>

    <p class="normal">你可以把这个数叫做<strong class="bold"> nonce </strong>，它只使用一次。例如，必须为比特币生成一个介于 0 和 4，294，967，296 之间的整数。</p>

    <p class="normal">这个过程是随机的。软件生成一个数字，通过哈希函数传递，然后发送到网络。第一个<strong class="bold">挖掘器</strong>产生预期范围内的数字，通知整个网络<a id="_idIndexMarker304"/>该特定块已经生成。网络的其余部分停止在该块上工作，并转移到另一个块上。</p>

    <p class="normal">矿工的报酬自然是用比特币支付的。考虑到网络中的竞争和产生正确结果所需的成本(CPU、电力、磁盘空间和时间),它代表了很多钱，但很难获得。</p>

    <div><p class="Information-Box--PACKT-">开采比特币或任何其他加密货币的成本与开采所得之间必须保持恒定的平衡。</p>

    </div>

    <p class="normal">谈过了挖掘比特币，我们就简单讨论一下实际使用加密货币。</p>

    <h2 id="_idParaDest-129" class="title">使用加密货币</h2>

    <p class="normal">小心使用<a id="_idIndexMarker306"/>加密货币。现在有 1500 多种加密货币。这个概念听起来很吸引人，但结果仍然是货币。货币可能会波动，如果发生崩盘，你可能会在不到一小时内失去一生的积蓄。</p>

    <div><p class="Information-Box--PACKT-"><strong class="bold">黄金法则</strong>:如果你无法抗拒投资加密货币，就不要投资超过你承受得起的损失。</p>

    </div>

    <p class="normal">也就是说，要使用加密货币，首先要设置一个钱包来存储你的比特币。钱包可以是在线的，通过提供商，或者甚至是离线的。</p>

    <p class="normal">一旦完成，你就可以随心所欲地用现金或使用信用卡、借记卡和转账来购买比特币。</p>

    <p class="normal">请记住，你购买这些货币就像购买任何其他货币一样，既有潜力，也有风险。</p>

    <p class="normal">在本节中，我们看到了区块链时代如何从比特币生产开始，以了解如何使用区块链通过比特币挖掘加密货币。记住了区块链被创造的最初方式，我们可以将区块链应用到许多其他领域。</p>

    <p class="normal">在我们的三部分章节的第二部分，我们将了解如何在加密货币之外使用区块链。我们将把它们应用到供应链中。</p>

    <h1 id="_idParaDest-130" class="title">第二部分——利用区块链共享供应链中的信息</h1>

    <p class="normal">在<em class="italics">第一部分——区块链技术的背景</em>中，我们看到了如何使用区块链挖掘加密货币。<a id="_idIndexMarker308"/>进入区块链世界的先决条件已经实现，本节将展示如何在供应链中使用区块链。这将不涉及加密货币。它开启了用人工智能创新区块链的道路。</p>

    <p class="normal">供应链是一个生产和服务链，将产品从起点送到消费者手中。例如，从印度运到突尼斯的一卷布料。在突尼斯，布料被裁剪成图案，然后组装成衣服。然后衣服被运到法国，在那里被包装在一个印有品牌的盒子里。然后，它被储存在仓库里，运送到实体店或直接给网上顾客。我们可以将这个供应链总结如下:</p>

    <p class="center"><em class="italics">布料从印度</em>-&gt;-<em class="italics">裁剪，在突尼斯</em>-&gt;-<em class="italics">运往法国</em>-&gt;-<em class="italics">打包</em>-&gt;-<em class="italics">储存</em>-&gt;-<em class="italics">运往商店或直接送给消费者</em></p>

    <p class="normal">一个供应链流程，如服装生产和交付系统，沿途涉及成千上万的人:生产现场、运输人员、仓库员工和链条每一步的管理团队。</p>

    <p class="normal">这就是现代区块链技术在一个系统中跟踪所有交易的便利之处。</p>

    <p class="normal">在下面的例子中，我们将选取名为 A、B、C、D、E 和 f 的六家公司。在<em class="italics">第 1 章</em>、<em class="italics">通过强化学习开始下一代人工智能</em>中，我们使用了一个大小为六的奖励矩阵。在那一章中，我们用 A、B、C、D、E 和 F 来表示强化学习的马尔可夫决策过程中的位置。在本章的最后，我们看到奖励矩阵可以应用于许多不同的领域。在我们的例子中，我们将这六个项目(A、B、C、D、E 和 F)称为供应链流程中的公司及其位置(在本例中为每个公司一个)。</p>

    <p class="normal">每个公司，从 A 到 F，都是使用区块链的供应链成员，可以优化其活动。不是每个公司都有单独的交易分类账，一个中央区块链将包含所有交易(块):</p>

    <ul>

      <li class="list">这些布料离开印度的时间和数量</li>

      <li class="list">它什么时候上船的，花了多长时间</li>

      <li class="list">当船到达突尼斯时</li>

      <li class="list">…直接面向消费者的所有中间活动</li>

    </ul>

    <p class="normal">有了这些数据，区块链的区块(交易记录)已经成为机器学习的金矿，可以用来检测信息和进行预测。使用该系统的一个有利可图的原因是降低库存水平。堆积未售出的商品以期待销售是昂贵的，而且会毁掉公司的利润。相反，如果供应链中的每个公司都可以通过区块链的区块看到其他合作伙伴的库存水平和真实需求，他们就可以根据需求调整库存水平，从而节省大量资金！</p>

    <p class="normal">让我们以 IBM 软件为例来看看这是如何工作的。</p>

    <p class="normal">基于 Hyperledger Fabric 的 IBM 区块链为世界各地的公司提供了一种共享区块链交易网络的方式，而不必担心采矿或使用加密货币。</p>

    <p class="normal">该系统基于 Linux 基金会项目。Hyperledger 是一个由 Linux 基金会主持的开源协作项目。</p>

    <p class="normal">在这一层，Hyperledger 使用区块链来保证安全交易，而无需尝试优化加密货币方面。该软件在所有相关方共享的区块链网络中生成区块，但他们不必购买货币意义上的加密货币——只需购买技术意义上的加密货币。</p>

    <p class="normal">在下图中，我们将使用六个节点(公司 A 到 F)来说明我们在<em class="italics">第 1 章</em>、<em class="italics">通过强化学习开始下一代人工智能</em>中学习的马尔可夫决策过程如何应用于区块链:</p>

    <figure class="mediaobject"><img src="img/B15438_07_01.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_07-1.jpg"/></figure>

    <p class="packt_figref">图 7.1:马尔可夫决策过程图</p>

    <p class="normal">每个节点代表一个参与为这六个公司建立的 IBM Hyperledger 网络的公司，如下表所示:</p>

    <table id="table001-5" class="No-Table-Style _idGenTablePara-1">

      <colgroup>

        <col/>

        <col/>

        <col/>

      </colgroup>

      <tbody>

        <tr class="No-Table-Style">

          <td class="No-Table-Style"><strong class="heading">公司</strong></td>

          <td class="No-Table-Style"><strong class="heading">活动</strong></td>

          <td class="No-Table-Style"><strong class="heading">毫升重量</strong></td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">A 在这个网络中买卖服装和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">在这个网络中买卖布料和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">在这个网络中买卖钮扣和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">在这个网络中买卖印花织物和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">E 在这个网络中买卖配件(皮带、手镯)和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">F 在这个网络中买卖包装盒和其他产品。</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">向网络提供商品，但保持低库存水平</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">库存水平</p>

          </td>

        </tr>

      </tbody>

    </table>

    <p class="normal">工作台的结构<a id="_idIndexMarker311"/>如下:</p>

    <ul>

      <li class="list"><strong class="bold">公司</strong>包含<a id="_idIndexMarker312"/>六个公司，{A，B，C，D，E，F}，它们有不同的活动。在本例中，每个公司只有一个位置，因此 A 到 F 也是公司位置。</li>

      <li class="list"><strong class="bold">活动</strong>:该集团的一部分公司向其成员供货，但确保昂贵的库存水平保持在较低水平。</li>

      <li class="list"><strong class="bold"> ML weight </strong>表示通过 ML 对库存水平进行分类，以进行预测。在我们的例子中，产生利润的关键是跟踪供应链中每个成员(A 到 F)的库存水平。例如，如果公司 F 的库存水平下降，网络的其他成员(A 到 E)可以预测并交付有限的必要数量，以使 F 的库存水平再次达到可接受的水平。</li>

    </ul>

    <p class="normal">随着每年数百万的商业交易和大量的运输(卡车、火车、轮船、飞机)，如果没有像 IBM Hyperledger 这样的解决方案，在 21 世纪有效地管理这种类型的网络变得越来越复杂。</p>

    <div><p class="Information-Box--PACKT-">有了 IBM Hyperledger，这些公司有了一个带有智能合同(在线)和实时跟踪的<strong class="bold">在线交易分类账。</strong></p>

    </div>

    <p class="normal">交易<a id="_idIndexMarker313"/>是安全的；在网络成员中，它们可以是私有的或公共的，它们为人工智能解决方案提供实时优化信息。</p>

    <h2 id="_idParaDest-131" class="title">在供应链网络中使用区块链</h2>

    <p class="normal"><em class="italics"> IBM Hyperledger 为人工智能开发者提供了超越任何其他数据集的独特优势——实时更新的 100%可靠的数据集。</em></p>

    <p class="normal">网络的每个<a id="_idIndexMarker315"/>公司成员(A 到 F)将为每笔交易创建一个<a id="_idIndexMarker316"/>块，以便人工智能分析师可以访问数据来进行预测。为了使系统工作，网络的每个成员(A 到 F)将在区块链中创建块，以便其他人可以查看记录的信息并使用这些信息来做出决策。</p>

    <h2 id="_idParaDest-132" class="title">创建块</h2>

    <p class="normal">使用所描述的用于挖掘比特币的方法来形成块<a id="_idIndexMarker317"/>，除了这一次，货币不是目标。目标是在必要时使用智能合约进行安全交易。下面的截图是一个可以定制的标准 IBM 界面:</p>

    <figure class="mediaobject"><img src="img/B15438_07_02.png" alt="C:\Users\gauravg\Desktop\9946\Chapter 14\B09940_14_02.png"/></figure>

    <p class="packt_figref">图 7.2:标准 IBM 界面</p>

    <p class="normal">你可以看到构成区块链的各个独特的板块。IBM Hyperledger 中的每个块都有一个唯一的编号。在本例中，它是带有放大块<strong class="bold"> 103 </strong>的<strong class="bold"> 111 </strong>。</p>

    <p class="normal">在我们的图(A 到 F)中的<a id="_idIndexMarker318"/>供应链网络中的一个块可以是带有合同的产品 X 的购买。例如，交易可以在公司 A 和 B 之间进行。下一步可能是将产品从 A 地运输到 B 地，例如在区块链网络中。</p>

    <p class="normal">附加到该块的信息位于 Hyperledger 存储库中:公司名称(A 到 F)、地址、电话号码、交易描述以及公司网络所需的任何其他类型的数据。每个块都可以被所有人或部分人查看，这取决于附加到它的权限属性。</p>

    <h2 id="_idParaDest-133" class="title">探索街区</h2>

    <p class="normal">探索<a id="_idIndexMarker319"/>区块为人工智能程序提供了一座金矿:真实的、100%可靠的数据集。</p>

    <p class="normal">人工智能优化的有趣部分是块信息，如下图所示。当前块与前一个块和交易代码一起被添加到链中:</p>

    <figure class="mediaobject"><img src="img/B15438_07_03.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_01-1.png"/></figure>

    <p class="packt_figref">图 7.3:探索区块链</p>

    <p class="normal">请注意，给定块的块哈希(参见前面的挖掘部分)链接到前一个块哈希，并拥有唯一的事务代码。</p>

    <p class="normal">一旦我们有了一组数据(交易类型、日期、金额)，我们就可以开始构建人工智能预测算法。IBM 通过脚本和其他工具提供了提取的可能性。</p>

    <div><p class="Information-Box--PACKT-">一旦我们有了包含区块链块的数据集，预测的目标将是确定库存级别类别，以查看供应链网络(A 到 F)的成员是否需要补充。</p>

    </div>

    <p class="normal">区块链提供的数据可用于预测网络在每次交易后将面临的库存水平类型。每个公司将能够运行一个预测算法，使用现有的数据来预测潜在的补货需求。例如，公司 A 可能发现公司 B 需要更多的布料。</p>

    <p class="normal">考虑到数据量，朴素贝叶斯等预测算法可以完成这项工作。</p>

    <h1 id="_idParaDest-134" class="title">第三部分——在区块链过程中用朴素贝叶斯优化供应链</h1>

    <p class="normal">朴素贝叶斯将使用一些关键信息作为<strong class="bold">特征</strong>，以在<a id="_idIndexMarker321"/>实时过程中优化仓库存储和产品可用性。</p>

    <p class="normal">朴素贝叶斯学习<a id="_idIndexMarker322"/>函数将从前面的<a id="_idIndexMarker323"/>块中学习如何预测应该插入区块链的下一个块(供应需要更多股票的另一家公司)。这些块将被插入到数据集中，就像任何其他形式的带有时间戳的数据一样，以便进行预测。</p>

    <p class="normal">朴素贝叶斯基于贝叶斯定理。贝叶斯定理应用条件概率，定义如下:</p>

    <figure class="mediaobject"><img src="img/B15438_07_001.png" alt=""/></figure>

    <ul>

      <li class="list"><em class="italics"> P </em> ( <em class="italics"> A </em> | <em class="italics"> B </em>)是一个<strong class="bold">后验概率</strong>，观察到一些事件后<em class="italics"> A </em>的<a id="_idIndexMarker324"/>概率(<em class="italics"> B </em>)。这也是一个<strong class="bold">条件概率</strong>:假设<em class="italics"> B </em>已经发生，则<em class="italics"> A </em>发生的<a id="_idIndexMarker325"/>可能性。</li>

      <li class="list"><em class="italics">P</em>(<em class="italics">B</em>|<em class="italics">A</em>)是给定先验观测值<em class="italics"> A </em>的情况下<em class="italics"> B </em>的概率。也是条件概率:给定<em class="italics"> A </em>已经发生的情况下<em class="italics"> B </em>发生的可能性。</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics"> A </em>)是<em class="italics"> A </em>在观测之前的概率。</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics"> B </em>)是预测的概率。</li>

    </ul>

    <p class="normal">朴素贝叶斯虽然基于贝叶斯定理，但它假设一个类中的特征是相互独立的。在许多情况下，这使得预测更容易实现。相关或不相关的特征的统计存在将产生预测。只要预测保持足够的效率，朴素贝叶斯提供了一个很好的解决方案。</p>

    <h2 id="_idParaDest-135" class="title">朴素贝叶斯例子</h2>

    <p class="normal">在这一节中，在编写 Python 程序之前，我们将首先用一个数学例子来说明朴素贝叶斯。本节的目标只是理解朴素贝叶斯中涉及的概念。</p>

    <p class="normal">这一部分不是开发章节，而是理解真实例子的基本概念和用于预测的数学的章节。</p>

    <p class="normal">本章中的区块链代表基于服装行业制成品的库存水平信息。有关更多信息，请阅读<em class="italics">第 12 章</em>、<em class="italics">人工智能和物联网(IoT) </em>，其中详细描述了人工智能优化的服装制造流程。</p>

    <p class="normal">在这一部分，我们将重点讨论存储。服装行业中一个缝纫站的负荷以<strong class="bold">库存单位</strong>(<strong class="bold">SKU</strong>)中的<a id="_idIndexMarker327"/>数量表示。例如，SKU 可以是产品 P:一条给定尺寸的牛仔裤。</p>

    <p class="normal">服装一旦生产出来，就被存放起来。此时，区块链中的块可以用机器学习算法的两个有用特征来表示该事务:</p>

    <ul>

      <li class="list">衣服存放的那天</li>

      <li class="list">现在库存 SKU 服装的总量</li>

    </ul>

    <p class="normal">区块链中的块包含交易信息中存储的日期(时间戳)和数量。</p>

    <p class="normal">由于区块链包含作为网络一部分的所有 A、B、C、D、E 和 F 公司位置的存储块，机器学习程序可以访问数据并做出预测。</p>

    <p class="normal">目标是将给定产品的存储数量平均分布在六个位置，如下图所示:</p>

    <figure class="mediaobject"><img src="img/B15438_07_04.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_04-1.jpg"/></figure>

    <p class="packt_figref">图 7.4:分布在六个位置的产品存储水平直方图</p>

    <p class="normal">该屏幕截图显示了分布在六个位置的产品 P 的存储水平。这个区块链网络中的每个位置都是一个<strong class="bold">中心</strong>。<strong class="bold">供应链管理</strong> ( <strong class="bold"> SCM </strong>)中的一个枢纽<a id="_idIndexMarker330"/>往往是<a id="_idIndexMarker331"/>一个中间存储仓库。例如，为了覆盖这六个位置的区域，相同的产品将存储在每个位置。这样，当地的卡车可以过来提货。</p>

    <p class="normal"><em class="italics">目标是在需要时在点位置 L (A 到 F)有可用的产品 P。</em></p>

    <p class="normal">例如，从一个位置<em class="italics"> L </em>到一个位置点<em class="italics">a</em>T77】1(一个商店或家)的交付时间只需要几个小时。例如，如果 A 没有储存 P，那么更好的消费者将不得不等待产品从 C 到达 A。</p>

    <p class="normal">如果区块链网络组织良好，一个地点可以专门生产产品 P(最佳生产成本),并平均分配六个地点储存的数量，包括它自己。</p>

    <p class="normal">通过在所有位置保持均衡的储存量，系统将在一个连续的交付过程中流动。</p>

    <p class="normal">在我们的例子中，一个公司=它的位置(A 到 F)。例如，使用这六个成员的区块链块，我们可以预测给定存储点(A 到 F)何时需要补充以减少等待时间。</p>

    <p class="normal">使用区块链优化存储级别是一种高效的新方法，可以在降低成本的同时更快地交付给客户。</p>

    <h3 id="_idParaDest-136" class="title">区块链期待新奇</h3>

    <p class="normal">以前，这六个位置(A 到 F)的所有仓库<a id="_idIndexMarker332"/>都必须确保每个位置的最低存储水平。由于他们不知道他们的供应链网络中实时发生了什么，他们经常存储比所需更多的产品，这增加了他们的成本，或者没有存储足够的产品，导致交付问题。</p>

    <p class="normal">在一个实时生产和销售的世界里，经销商需要预测需求。该系统需要由需求驱动。朴素贝叶斯可以解决这个问题。</p>

    <p class="normal">它将考虑前两个特征:</p>

    <ul>

      <li class="list"><strong class="bold">日</strong>:服装存放的日期</li>

      <li class="list"><strong class="bold">库存</strong>:现在库存的那件 SKU 服装的总量</li>

    </ul>

    <p class="normal">然后会增加一个新奇的东西——<em class="italics">与产品 P 相关的块数</em>。</p>

    <p class="normal">给定日期的高数量的块意味着该产品在总体上是有需求的(生产、分销)。区块越多，交易就越多。此外，如果存储水平(库存特征)正在减少，这是一个指标；这意味着必须补充存储水平。日功能标记了产品的历史。</p>

    <p class="normal">该块特征被命名为<strong class="bold">块</strong>。由于所有人都共享区块链，机器学习程序可以在几秒钟内访问可靠的全球数据。区块链提供的数据集可靠性本身就构成了使用区块链的块作为数据集来优化存储级别的<a id="_idIndexMarker333"/>动机。</p>

    <h3 id="_idParaDest-137" class="title">目标—使用区块链数据优化存储级别</h3>

    <p class="normal">目标是<em class="italics">通过<a id="_idIndexMarker334"/>在提出产品需求时提供快速交付，将库存维持在较低水平</em>。为了做出决定，ML 解决方案将<a id="_idIndexMarker335"/>实时分析区块链的块。</p>

    <p class="normal">该程序将获取给定产品 P 的日、库存和块(数量)特征，并产生结果。结果预测这个产品 P 是否会有需求。如果答案是肯定的(或 1)，这种产品的需求需要预测。</p>

    <h4 class="title">步骤 1–定义数据集</h4>

    <p class="normal">数据集包含来自序列中先前事件的<a id="_idIndexMarker336"/>原始数据，这使得它非常适合预测算法。例如，可以使用来自 IBM Hyperledger 的脚本提取块。这构成了一个独特的机会，可以看到所有公司的数据，而不必建立一个数据库。原始数据集将如下所示:</p>

    <figure class="mediaobject"><img src="img/B15438_07_05.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_02.jpg"/></figure>

    <p class="packt_figref">图 7.5:原始数据集</p>

    <p class="normal">该数据集包含以下内容:</p>

    <ul>

      <li class="list">产品 P 的<code class="Code-In-Text--PACKT-">Blocks</code>在第<code class="Code-In-Text--PACKT-">x</code>天出现在区块链，扫描区块链 30 天。<code class="Code-In-Text--PACKT-">No</code>表示没有发现大量的块体。<code class="Code-In-Text--PACKT-">Yes</code>表示已发现大量区块。如果发现了区块，这意味着区块链沿岸某个地方对这种产品有需求。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">Some_blocks</code>意味着<a id="_idIndexMarker337"/>块已经被发现，但是它们太稀疏以至于在不过度拟合预测的情况下不被考虑。然而，<code class="Code-In-Text--PACKT-">Yes</code>将和<code class="Code-In-Text--PACKT-">No</code>一样对预测有贡献。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">No_blocks</code>表示完全没有需求，稀疏或其他(<code class="Code-In-Text--PACKT-">Some_blocks</code>)，众多(<code class="Code-In-Text--PACKT-">Blocks</code>)或没有。这意味着这个产品的麻烦，p。</li>

    </ul>

    <p class="normal">目标是避免预测稀少(<code class="Code-In-Text--PACKT-">Some_blocks</code>)或缺乏(<code class="Code-In-Text--PACKT-">No_blocks</code>)产品的需求。本例试图预测产品 p 的多个块的潜在<code class="Code-In-Text--PACKT-">Yes</code>，只有预测到<code class="Code-In-Text--PACKT-">Yes</code>，系统才能触发自动需求流程(参见本章后面的<em class="italics">在 Python 中实现朴素贝叶斯</em>部分)。</p>

    <h4 class="title">步骤 2–计算频率</h4>

    <p class="normal">查看下面的<a id="_idIndexMarker338"/>频率表提供了附加信息:</p>

    <figure class="mediaobject"><img src="img/B15438_07_06.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_03-1.jpg"/></figure>

    <p class="packt_figref">图 7.6:频率表</p>

    <p class="normal">给定产品 P 在给定期间(过去 30 天)的每个功能(<code class="Code-In-Text--PACKT-">Blocks</code>、<code class="Code-In-Text--PACKT-">Some_blocks</code>或<code class="Code-In-Text--PACKT-">No_blocks</code>)的<code class="Code-In-Text--PACKT-">Yes</code>和<code class="Code-In-Text--PACKT-">No</code>状态已按频率分组。</p>

    <p class="normal">每个<code class="Code-In-Text--PACKT-">No</code>功能和<code class="Code-In-Text--PACKT-">Yes</code>功能的总和在底线上。比如<code class="Code-In-Text--PACKT-">Yes</code>和<code class="Code-In-Text--PACKT-">No_blocks</code>加起来就是 2。</p>

    <p class="normal">一些附加信息将证明对最终计算有用:</p>

    <ul>

      <li class="list">总<a id="_idIndexMarker339"/>样本数= 10。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">Yes</code>样本总数= 8。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">No</code>样本总数= 2。</li>

    </ul>

    <h4 class="title">步骤 3–计算可能性</h4>

    <p class="normal">现在<strong class="bold">频率</strong>表<a id="_idIndexMarker340"/>已经计算出来，下面的<strong class="bold">似然度</strong>表是使用该数据产生的:</p>

    <figure class="mediaobject"><img src="img/B15438_07_07.png" alt="https://packt-type-cloud.s3.amazonaws.com/uploads/sites/2134/2018/05/B09946_14_05-300x97.jpg"/></figure>

    <p class="packt_figref">图 7.7:可能性表</p>

    <p class="normal">该表包含以下统计信息:</p>

    <ul>

      <li class="list"><code class="Code-In-Text--PACKT-">No</code> = 2 = 20% = 0.2</li>

      <li class="list"><code class="Code-In-Text--PACKT-">Yes</code> = 8 = 80%=0.8</li>

      <li class="list"><code class="Code-In-Text--PACKT-">Some_blocks</code> = 2 = 20%=0.2</li>

      <li class="list"><code class="Code-In-Text--PACKT-">No_blocks</code> = 3 = 30%=0.3</li>

      <li class="list"><code class="Code-In-Text--PACKT-">Blocks</code> = 5 = 50%=0.5</li>

    </ul>

    <p class="normal"><code class="Code-In-Text--PACKT-">Blocks</code>代表样本的重要比例，这意味着与<code class="Code-In-Text--PACKT-">Some_blocks</code>一起，需求看起来不错。</p>

    <h4 class="title">步骤 4–应用朴素贝叶斯方程</h4>

    <p class="normal">现在的目标是<a id="_idIndexMarker341"/>在朴素贝叶斯方程中表示贝叶斯定理的每个变量，以获得<strong class="bold">对产品 P 的需求</strong>的概率，并触发区块链网络的购买场景。贝叶斯定理可以表述如下:</p>

    <figure class="mediaobject"><img src="img/B15438_07_001.png" alt=""/></figure>

    <ul>

      <li class="list"><em class="italics"> P </em> ( <em class="italics">是</em> | <em class="italics">挡</em> ) = <em class="italics"> P </em> ( <em class="italics">挡</em> | <em class="italics">是</em> ) * <em class="italics"> P </em> ( <em class="italics">是</em> )/ <em class="italics"> P </em> ( <em class="italics">挡</em>)</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics">是</em> ) = 8/10 = 0.8</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics">块</em> ) = 5/10 = 0.5</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics">块</em> | <em class="italics">是</em> ) = 4/8 = 0.5</li>

      <li class="list"><em class="italics"> P </em> ( <em class="italics">是</em> | <em class="italics">块</em> ) = (0.5*0.8)/0.5 = 0.8</li>

    </ul>

    <p class="normal">这个要求看起来可以接受。然而，处罚是必要的，并且还必须考虑其他因素(通过其他区块勘探过程的运输可用性)。</p>

    <p class="normal">这个例子和方法展示了朴素贝叶斯方法的概念。这个例子只不过是对贝叶斯定理哲学的一个简化的数学解释。</p>

    <p class="normal">通过从头开始做这个<a id="_idIndexMarker342"/>计算，我们现在知道了贝叶斯定理的基本概念:使用先验值来预测未来事件，同时考虑几个特征。</p>

    <p class="normal">我们现在将从这种理论方法进入实施阶段。我们将使用 Python 中的朴素贝叶斯构建一个程序。</p>

    <h2 id="_idParaDest-138" class="title">朴素贝叶斯在 Python 中的实现</h2>

    <p class="normal">本节<a id="_idIndexMarker343"/>展示了如何使用朴素<a id="_idIndexMarker344"/>贝叶斯的库存水平优化版本。区块链为寻找优化领域和创造利润的 ML 矿商提供了非常可靠的数据集。选择正确的模式仍然是关键的挑战。</p>

    <h3 id="_idParaDest-139" class="title">高斯朴素贝叶斯</h3>

    <p class="normal">我们将实现<a id="_idIndexMarker345"/>高斯朴素贝叶斯，因为它适合服装行业。比如你卖连衣裙，会有一个目标中号<em class="italics"> S </em>。营销部门知道这个尺码的 S 将代表大部分的销售额。较大的<em class="italics"> S </em> + <em class="italics"> n </em>尺寸和较小的<em class="italics">S</em>–<em class="italics">n</em>将产生较少的销售，形成高斯曲线。</p>

    <p class="normal">在实施模式下，将使用包含来自区块链的原始数据的数据集，而不使用下表中的朴素贝叶斯的要素解释函数:</p>

    <table id="table002-3" class="No-Table-Style _idGenTablePara-1">

      <colgroup>

        <col/>

        <col/>

        <col/>

        <col/>

      </colgroup>

      <tbody>

        <tr class="No-Table-Style">

          <td class="No-Table-Style"><strong class="heading">天</strong></td>

          <td class="No-Table-Style"><strong class="heading">股票</strong></td>

          <td class="No-Table-Style"><strong class="heading">积木</strong></td>

          <td class="No-Table-Style"><strong class="heading">需求</strong></td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">10</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1455</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">78</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">11</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1666</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">67</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">12</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1254</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">57</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">14</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1563</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">45</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">15</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1674</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">89</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">10</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1465</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">89</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">12</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1646</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">76</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">一</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">15</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1746</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">87</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">2</p>

          </td>

        </tr>

        <tr class="No-Table-Style">

          <td class="No-Table-Style">

            <p class="content">12</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">1435</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">78</p>

          </td>

          <td class="No-Table-Style">

            <p class="content">2</p>

          </td>

        </tr>

      </tbody>

    </table>

    <p class="normal">每行代表一个块:</p>

    <ul>

      <li class="list"><code class="Code-In-Text--PACKT-">DAY</code>:数据集中分析的周期的日期。在这种情况下，我们分析的是给定月份的天数，它代表一个财务周期。运行计算不需要其他信息。在其他情况下，可以使用 dd/mm/yyyy 格式。您也可以从周期开始的第一天开始使用一个计数器(1 到<em class="italics"> n </em>),并在几周、几个月或几年内运行它。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">STOCK</code>:在块中找到的给定位置(A、B 或… F)的总输入，并在当天合计。由于这表示一个位置且仅一个位置的输入，因此不需要位置信息。在其他情况下，可以添加位置。</li>

      <li class="list"><code class="Code-In-Text--PACKT-">BLOCKS</code>: The number of blocks containing product P for location A, for example.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">在<code class="Code-In-Text--PACKT-">BLOCK</code>列中的高块数和在<code class="Code-In-Text--PACKT-">STOCK</code>列中的低数量意味着需求高。</p>

      </li>

      <li class="list"><code class="Code-In-Text--PACKT-">DEMAND = 1</code>. The <a id="_idIndexMarker346"/>proof of demand is a transaction block that contains a purchase in the past. These transaction blocks provide vital information.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">BLOCK</code>列中的低块数和<code class="Code-In-Text--PACKT-">STOCK</code>列中的高数量意味着需求低。</p>

      </li>

      <li class="list"><code class="Code-In-Text--PACKT-">DEMAND = 2</code>。未发现交易的证明。</li>

    </ul>

    <div><p class="Information-Box--PACKT-"><strong class="bold">朴素贝叶斯的极限</strong></p>

      <p class="Information-Box--PACKT-">在<a id="_idIndexMarker347"/>某些情况下，<code class="Code-In-Text--PACKT-">DEMAND = 1</code>当股票高而板块低的时候。这就是为什么严格相关没有那么有用的原因。这将是朴素贝叶斯的极限，它只是分析统计数据并学习如何预测，而忽略了实际的条件概率，即特征之间的相互作用。</p>

    </div>

    <p class="normal">在本节中，我们描述了在编写带有现成算法的朴素贝叶斯程序时将会考虑到的数据集和特征。</p>

    <h4 class="title">Python 程序</h4>

    <p class="normal">我们现在知道什么是<a id="_idIndexMarker348"/>区块链，以及如何使用区块链的块来优化公司网络(A 到 F)位置的股票水平。我们也知道贝叶斯定理和朴素贝叶斯的基本概念。</p>

    <p class="normal">考虑到这一点，我们可以构建一个 Python 程序来预测区块链传入块的股票级别类别。这些预测将帮助当地经理增加他们的库存水平，以满足他们所在供应链中的合作伙伴(公司 A 到 F)的需求。</p>

    <p class="normal">Python <code class="Code-In-Text--PACKT-">naive_bayes_blockchains.py</code>程序使用了一个<code class="Code-In-Text--PACKT-">sklearn</code>类。考虑下面的片段:</p>

    <pre class="programlisting"><code class="hljs elm">import numpy as np

import pandas as pd

from sklearn.naive_bayes import GaussianNB

</code></pre>

    <p class="normal">它将数据集读入数据结构。以下代码将<code class="Code-In-Text--PACKT-">data_BC.csv</code>读入<code class="Code-In-Text--PACKT-">df</code>:</p>

    <pre class="programlisting"><code class="hljs stylus">#Reading the data

df = pd.read_csv('data_BC.csv')

print("Blocks of the Blockchain")

print(df.head())

</code></pre>

    <p class="normal">它在以下输出中打印文件的顶部:</p>

    <pre class="programlisting"><code class="hljs angelscript">Blocks of the Blockchain

DAY STOCK BLOCKS DEMAND

0 10 1455 78 1

1 11 1666 67 1

2 12 1254 57 1

3 14 1563 45 1

4 15 1674 89 1

</code></pre>

    <p class="normal">它准备训练集，在下面的代码中使用<code class="Code-In-Text--PACKT-">X</code>查找和预测<code class="Code-In-Text--PACKT-">Y</code>:</p>

    <pre class="programlisting"><code class="hljs ini"># Prepare the training set

X = df.loc[:,'DAY':'BLOCKS']

Y = df.loc[:,'DEMAND']

</code></pre>

    <p class="normal">它选择类别并训练以下<code class="Code-In-Text--PACKT-">clfG</code>模型:</p>

    <pre class="programlisting"><code class="hljs makefile">#Choose the class

clfG = GaussianNB()

# Train the model

clfG.fit(X,Y)

</code></pre>

    <p class="normal">然后程序<a id="_idIndexMarker349"/>获取区块链的一些块，进行预测，并使用下面的<code class="Code-In-Text--PACKT-">clfG.predict</code>函数打印出来:</p>

    <pre class="programlisting"><code class="hljs lua"># Predict with the model(return the class)

print("Blocks for the prediction of the A-F blockchain")

blocks=[[14,1345,12],

        [29,2034,50],

        [30,7789,4],

        [31,6789,4]]

print(blocks)

prediction = clfG.predict(blocks)

for i in range(4):

    print("Block #",i+1," Gauss Naive Bayes Prediction:",

           prediction[i])

</code></pre>

    <p class="normal">显示块，并产生以下预测。<code class="Code-In-Text--PACKT-">2</code>表示暂时没有需求；<code class="Code-In-Text--PACKT-">1</code>将触发一个购买阻止:</p>

    <pre class="programlisting"><code class="hljs angelscript">Blocks for the prediction of the A-F blockchain

[[14, 1345, 12], [29, 2034, 50], [30, 7789, 4], [31, 6789, 4]]

Block # 1 Gauss Naive Bayes Prediction: 1

Block # 2 Gauss Naive Bayes Prediction: 2

Block # 3 Gauss Naive Bayes Prediction: 2

Block # 4 Gauss Naive Bayes Prediction: 2

</code></pre>

    <p class="normal">这是一个补给计划。它将模拟需求。找不到需求，什么都不会发生；当发现需求时，它触发一个购买块。一些连锁店知道某一天(或一周或另一个单位)购买的服装数量，并自动购买该数量。其他人有其他购买规则。寻找业务规则是项目咨询方面的一部分。</p>

    <p class="normal">在本节中，我们实现了朴素贝叶斯来预测传入块的类别。如果需求很高，那么供应链经理就会知道需要储存更多的产品。</p>

    <p class="normal">如果需求低，经理会避免储存更多的产品。区块链中的块为全天候扫描块并实时生成建议的程序提供了可靠的数据集。</p>

    <h1 id="_idParaDest-140" class="title">摘要</h1>

    <p class="normal">区块链中可靠的块序列为无尽的机器学习算法打开了大门。朴素贝叶斯似乎是开始优化区块链块的实用方法。它通过学习数据集的独立特征来计算相关性并做出预测，而不管这种关系是否是有条件的。</p>

    <p class="normal">这种自由式预测方法符合区块链思想开放的精神，这种精神如今正被数百万人用无限的资源传播。</p>

    <p class="normal">IBM Hyperledger 通过 Linux 基金会项目将区块链的“边疆”开发带到了另一个层次。IBM 还提供云平台和服务。</p>

    <p class="normal">IBM、微软、亚马逊和谷歌为云平台提供了一系列颠覆性的机器学习算法。这为您的市场或部门提供了一个顺畅的途径，同时能够在短时间内在线建立一个区块链原型。使用这种方法，您可以在模型中输入一些额外的原型数据，导出数据，或者使用 API 来读取块序列。然后，你将能够将机器学习算法应用于这些可靠的数据集。唯一的限制是我们的想象力。</p>

    <p class="normal">下一章将带领我们进入更多的人工智能领域，探索神经网络的世界。</p>

    <h1 id="_idParaDest-141" class="title">问题</h1>

    <ol>

      <li class="list">加密货币是当今区块链的唯一用途。(是|否)</li>

      <li class="list">开采区块链可能有利可图。(是|否)</li>

      <li class="list">公司的区块链不能应用于销售。(是|否)</li>

      <li class="list">区块链的智能合同比标准的离线合同更容易书写。(是|否)</li>

      <li class="list">一旦一个区块在区块链网络中，网络中的每个人都可以阅读其内容。(是|否)</li>

      <li class="list">区块链中的块保证绝对没有欺诈可能。(是|否)</li>

      <li class="list">应用贝叶斯定理只有一种方法。(是|否)</li>

      <li class="list">训练朴素贝叶斯数据集需要一个标准函数。(是|否)</li>

      <li class="list">机器学习算法不会改变公司业务的本质。(是|否)</li>

    </ol>

    <h1 id="_idParaDest-142" class="title">进一步阅读</h1>

    <ul>

      <li class="list">想在 scikit-learn 网站上了解更多关于朴素贝叶斯的信息:<a href="https://scikit-learn.org/stable/modules/naive_bayes.html">https://scikit-learn.org/stable/modules/naive_bayes.html</a></li>

      <li class="list">探索 IBM 的 Hyperledger 解决方案:【https://www.ibm.com/blockchain/hyperledger.html T2】</li>

    </ul>

  </div>



</body></html>