<html><head/><body>
<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Get Closer to Your Data</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">更接近您的数据</h1>
                
            
            
                
<p class="calibre2">在本章中，我们将介绍以下配方:</p>
<ul class="calibre10">
<li class="calibre11">使用 Python 进行数据操作</li>
<li class="calibre11">分析、可视化和处理缺失值</li>
<li class="calibre11">探索性数据分析</li>
</ul>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Introduction</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">介绍</h1>
                
            
            
                
<p class="calibre2">在本书中，我们将涵盖各种集成技术，并将学习如何集成多种机器学习算法来增强模型的性能。我们将使用 pandas、NumPy、scikit-learn 和 Matplotlib，所有这些都是为使用 Python 而构建的，正如我们将在整本书中所做的那样。到目前为止，您应该非常了解数据操作和探索。</p>
<p class="calibre2">在本章中，我们将回顾如何在 Python 中读取和操作数据，如何分析和处理缺失值，以及如何探索数据以获得更深入的见解。我们将使用各种 Python 包，比如用于数据操作和探索的<kbd class="calibre12">numpy</kbd>和<kbd class="calibre12">pandas</kbd>，以及用于数据可视化的<kbd class="calibre12">seaborn</kbd>包。在本书后面的章节中，我们将继续使用这些库的一部分或全部。我们还将使用 Anaconda 发行版进行 Python 编码。如果你没有安装 Anaconda，你需要从<a href="https://www.anaconda.com/download/#macos" class="calibre9">https://www.anaconda.com/download</a>下载。在写这本书的时候，Anaconda 的最新版本是 5.2，同时提供了 Python 3.6 和 Python 2.7。我们建议您下载 Python 3.6 版的 Anaconda。我们还将使用 GitHub 上提供的<kbd class="calibre12">HousePrices</kbd>数据集。</p>
<p class="calibre2"/>
<p class="calibre2"/>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Data manipulation with Python</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">使用 Python 进行数据操作</h1>
                
            
            
                
<p class="calibre2">在现实生活中，通常很难获得完全按照我们需要的格式编排的完整、干净的数据集。我们收到的数据往往不能直接用于统计或机器学习算法。我们需要处理原始数据，以便处理后的数据可以用于进一步的分析和建模。首先，我们需要导入所需的包，比如<kbd class="calibre12">pandas</kbd>，并将数据集读入 Python。</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Getting ready</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">做好准备</h1>
                
            
            
                
<p class="calibre2">我们将在操作系统的相关功能中使用<kbd class="calibre12">os</kbd>包，在数据操作中使用<kbd class="calibre12">pandas</kbd>包。</p>
<p class="calibre2">现在让我们看一下数据定义来理解我们的变量。在下面的代码中，我们列出了几个变量的数据定义。GitHub 上提供了数据集和完整的数据定义。以下是数据描述文件的节略版本:</p>
<pre class="calibre18">MS SubClass (Nominal): Identifies the type of dwelling involved in the sale<br class="title-page-name"/>Lot Frontage (Continuous): Linear feet of street connected to property<br class="title-page-name"/>Alley (Nominal): Type of alley access to property<br class="title-page-name"/>Overall Qual (Ordinal): Rates the overall material and finish of the house<br class="title-page-name"/>Overall Cond (Ordinal): Rates the overall condition of the house<br class="title-page-name"/>Year Built (Discrete): Original construction date<br class="title-page-name"/>Mas Vnr Type (Nominal): Masonry veneer type<br class="title-page-name"/>Mas Vnr Area (Continuous): Masonry veneer area in square feet<br class="title-page-name"/>Garage Type (Nominal): Garage location<br class="title-page-name"/>Garage Yr Blt (Discrete): Year garage was built<br class="title-page-name"/>Garage Finish (Ordinal): Interior finish of the garage<br class="title-page-name"/>Garage Cars (Discrete): Size of garage in car capacity<br class="title-page-name"/>Garage Area (Continuous): Size of garage in square feet<br class="title-page-name"/>Garage Qual (Ordinal): Garage quality<br class="title-page-name"/>Garage Cond (Ordinal): Garage condition<br class="title-page-name"/>...<br class="title-page-name"/>...<br class="title-page-name"/>SalePrice (Continuous): Sale price $$</pre>
<p class="calibre2">然后，我们将导入<kbd class="calibre12">os</kbd>和<kbd class="calibre12">pandas</kbd>包，并根据我们的需求设置我们的工作目录，如下面的代码块所示:</p>
<pre class="calibre18">import os<br class="title-page-name"/>import pandas as pd<br class="title-page-name"/><br class="title-page-name"/># Set working directory as per your need<br class="title-page-name"/>os.chdir(".../.../Chapter 1")<br class="title-page-name"/>os.getcwd()</pre>
<p class="calibre2">下一步是从 GitHub 下载数据集，并将其复制到您的工作目录中。</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How to do it...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">怎么做...</h1>
                
            
            
                
<p class="calibre2">现在，让我们执行一些数据操作步骤:</p>
<ol class="calibre14">
<li class="calibre11">首先，我们将从当前工作目录中读取<kbd class="calibre12">HousePrices.csv</kbd>中的数据，并创建第一个数据帧进行操作。我们将数据帧命名为<kbd class="calibre12">housepricesdata</kbd>，如下所示:</li>
</ol>
<pre class="calibre18">housepricesdata = pd.read_csv("HousePrices.csv")</pre>
<ol start="2" class="calibre14">
<li class="calibre11">现在让我们来看看我们的数据帧，看看它是什么样子的:</li>
</ol>
<pre class="calibre18"># See first five observations from top<br class="title-page-name"/>housepricesdata.head(5)</pre>
<div><p class="calibre2">您可能看不到所有的行；朱庇特会截断一些变量。为了在 Jupyter 中查看任何输出的所有行和列，请执行以下命令:</p>
<p class="calibre2"><kbd class="calibre19"># Setting options to display all rows and columns</kbd> <br class="calibre6"/> <kbd class="calibre19">pd.options.display.max_rows = None</kbd> <br class="calibre6"/> <kbd class="calibre19">pd.options.display.max_columns = None</kbd></p>
</div>
<ol start="3" class="calibre14">
<li class="calibre11">我们可以用<kbd class="calibre12">shape</kbd>看到数据框的尺寸。<kbd class="calibre12">shape</kbd>是<kbd class="calibre12">pandas</kbd>数据帧的一个属性:</li>
</ol>
<pre class="calibre18">housepricesdata.shape</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre20">使用前面的命令，我们可以看到行数和列数，如下所示:</p>
<pre class="calibre18">(1460, 81)</pre>
<p class="calibre20">在这里，我们可以看到数据帧有<kbd class="calibre12">1460</kbd>观察值和<kbd class="calibre12">81</kbd>列。</p>
<ol start="4" class="calibre14">
<li class="calibre11">让我们来看看数据帧中变量的数据类型:</li>
</ol>
<pre class="calibre18">housepricesdata.dtypes</pre>
<p class="calibre20">在下面的代码块中，我们可以看到数据帧中每个变量的数据类型:</p>
<pre class="calibre18">Id                 int64
MSSubClass         int64
MSZoning          object
LotFrontage      float64
LotArea            int64
LotConfig         object
LandSlope         object
                  ...   
BedroomAbvGr       int64
KitchenAbvGr       int64
KitchenQual       object
TotRmsAbvGrd       int64
SaleCondition     object
SalePrice          int64
Length: 81, dtype: object</pre>
<p class="calibre20">我们现在已经准备好开始我们的数据操作，我们可以用许多不同的方式来做。在这一节中，我们将看一些方法，在这些方法中，我们可以操纵和准备我们的数据，以便进行分析。</p>
<p class="calibre20">让我们从总结我们的数据开始。</p>
<ol start="5" class="calibre14">
<li class="calibre11"><kbd class="calibre12">describe()</kbd>功能将只显示数字变量的统计数据:</li>
</ol>
<pre class="calibre18">housepricesdata.describe()</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre20">我们可以在下面的截图中看到输出:</p>
<p class="CDPAlignCenter"><img class="aligncenter" src="img/ae71b07f-4ae3-49f4-824c-63a95f2fabd8.png"/></p>
<ol start="6" class="calibre14">
<li class="calibre11">我们将删除<kbd class="calibre12">id</kbd>列，因为这对我们的分析是不必要的:</li>
</ol>
<pre class="calibre18"># inplace=True will overwrite the DataFrame after dropping Id column<br class="title-page-name"/>housepricesdata.drop(['Id'], axis=1, inplace=True)</pre>
<ol start="7" class="calibre14">
<li class="calibre11">现在让我们看看一些对象类型变量的分布，也就是分类变量。在下面的例子中，我们将看看<kbd class="calibre12">LotShape</kbd>和<kbd class="calibre12">LandContour</kbd>。我们可以用下面代码块中所示的相同方法研究数据集的其他分类变量:</li>
</ol>
<pre class="calibre18"># Name the count column as "count"<br class="title-page-name"/>lotshape_frequencies = pd.crosstab(index=housepricesdata["LotShape"], columns="count") <br class="title-page-name"/><br class="title-page-name"/>landcountour_frequencies = pd.crosstab(index=housepricesdata["LandContour"], columns="count") # Name the count column as "count"<br class="title-page-name"/><br class="title-page-name"/>print(lotshape_frequencies)<br class="title-page-name"/>print("\n") # to keep a blank line for display<br class="title-page-name"/>print(landcountour_frequencies)</pre>
<ol start="8" class="calibre14">
<li class="calibre11">我们现在将了解如何在数据类型之间执行转换。我们注意到，变量的数据定义如<kbd class="calibre12">MSSubClass</kbd>、<kbd class="calibre12">OverallQual</kbd>和<kbd class="calibre12">OverallCond</kbd>都是分类变量。但是，导入数据集后，它们会显示为整数。</li>
</ol>
<p>在对任何变量进行类型转换之前，请确保没有丢失值。</p>
<p class="calibre20">这里，我们将把变量转换成分类数据类型:</p>
<pre class="calibre18"># Using astype() to cast a pandas object to a specified datatype<br class="title-page-name"/>housepricesdata['MSSubClass'] = housepricesdata['MSSubClass'].astype('object')<br class="title-page-name"/>housepricesdata['OverallQual'] = housepricesdata['OverallQual'].astype('object')<br class="title-page-name"/>housepricesdata['OverallCond'] = housepricesdata['OverallCond'].astype('object')<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Check the datatype of MSSubClass after type conversion<br class="title-page-name"/>print(housepricesdata['MSSubClass'].dtype)<br class="title-page-name"/>print('\n') # to keep a blank line for display<br class="title-page-name"/><br class="title-page-name"/># Check the distribution of the levels in MSSubClass after conversion<br class="title-page-name"/># Make a crosstab with pd.crosstab()<br class="title-page-name"/># Name the count column as "count"<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["MSSubClass"], columns="count")) </pre>
<p class="calibre20">我们可以看到每类房屋的观察计数，如下面的代码块所示:</p>
<pre class="calibre18">category

col_0       count
MSSubClass       
20            536
30             69
40              4
45             12
50            144
60            299
70             60
75             16
80             58
85             20
90             52
120            87
160            63
180            10
190            30</pre>
<p class="calibre20">有许多变量本身可能不是很有用，但是转换它们会给我们很多有趣的见解。让我们创建一些新的，有意义的变量。</p>
<p class="calibre2"/>
<p class="calibre2"/>
<ol start="9" class="calibre14">
<li class="calibre11"><kbd class="calibre12">YearBuilt</kbd>和<kbd class="calibre12">YearRemodAdd</kbd>分别代表原施工日期和改造日期。然而，如果它们可以转换成年龄，这些变量将告诉我们这些建筑有多老，以及它们被改造了多少年。为此，我们创建两个新变量，<kbd class="calibre12">BuildingAge</kbd>和<kbd class="calibre12">RemodelAge</kbd>:</li>
</ol>
<pre class="calibre18"># Importing datetime package for date time operations<br class="title-page-name"/>import datetime as dt<br class="title-page-name"/><br class="title-page-name"/># using date time package to find the current year<br class="title-page-name"/>current_year = int(dt.datetime.now().year)<br class="title-page-name"/><br class="title-page-name"/># Subtracting the YearBuilt from current_year to find out the age of the building<br class="title-page-name"/>building_age = current_year - housepricesdata['YearBuilt']<br class="title-page-name"/><br class="title-page-name"/># Subtracting the YearRemonAdd from current_year to find out the age since the<br class="title-page-name"/># building was remodelled<br class="title-page-name"/>remodelled_age = current_year - housepricesdata['YearRemodAdd']</pre>
<ol start="10" class="calibre14">
<li class="calibre11">现在，让我们将两个变量添加到我们的数据集:</li>
</ol>
<pre class="calibre18"># Adding the two variables to the DataFrame<br class="title-page-name"/>housepricesdata['building_age'] = building_age<br class="title-page-name"/>housepricesdata['remodelled_age'] = remodelled_age<br class="title-page-name"/><br class="title-page-name"/># Checking our DataFrame to see if the two variables got added<br class="title-page-name"/>housepricesdata.head(5)</pre>
<p class="calibre20">我们注意到<kbd class="calibre12">building_age</kbd>和<kbd class="calibre12">remodelled_age</kbd>现在被添加到数据帧中，如下面的屏幕截图所示:</p>
<p class="CDPAlignCenter"><img class="aligncenter1" src="img/9a775483-e117-482a-9a06-ca71ada35476.png"/></p>
<p class="calibre20">包含标签数据的变量需要转换成数字形式，以供机器学习算法使用。为了解决这个问题，我们将执行编码，将标签转换为数字形式，以便算法可以使用它们。</p>
<p class="calibre2"/>
<ol start="11" class="calibre14">
<li class="calibre11">我们需要识别需要编码的变量，包括<kbd class="calibre12">Street</kbd>、<kbd class="calibre12">LotShape</kbd>和<kbd class="calibre12">LandContour</kbd>。我们将执行一键编码，这是将分类变量表示为二进制向量。我们将使用 Python 中的<kbd class="calibre12">pandas</kbd>包来完成这项工作:</li>
</ol>
<pre class="calibre18"># We use get_dummies() function to one-hot encode LotShape<br class="title-page-name"/>one_hot_encoded_variables = pd.get_dummies(housepricesdata['LotShape'],prefix='LotShape')<br class="title-page-name"/><br class="title-page-name"/># Print the one-hot encoded variables to see how they look like<br class="title-page-name"/>print(one_hot_encoded_variables)</pre>
<p class="calibre20">我们可以在下面的屏幕截图中看到已经创建的一次性编码变量:</p>
<p class="CDPAlignCenter"><img class="aligncenter2" src="img/394c838b-dc90-47d9-9e03-9676cca5c3c2.png"/></p>
<ol start="12" class="calibre14">
<li class="calibre11">将独热编码变量添加到我们的数据帧中，如下所示:</li>
</ol>
<pre class="calibre18"># Adding the new created one-hot encoded variables to our DataFrame<br class="title-page-name"/>housepricesdata = pd.concat([housepricesdata,one_hot_encoded_variables],axis=1)<br class="title-page-name"/><br class="title-page-name"/># Let's take a look at the added one-hot encoded variables<br class="title-page-name"/># Scroll right to view the added variables<br class="title-page-name"/>housepricesdata.head(5)</pre>
<p class="calibre2"/>
<p class="calibre20">在下面的屏幕截图中，我们可以看到将一位热码编码变量添加到数据帧后得到的输出:</p>
<p class="CDPAlignCenter"><img class="aligncenter3" src="img/62732d2d-f5c0-4382-8ab2-7a6820ab2193.png"/></p>
<ol start="13" class="calibre14">
<li class="calibre11">现在，让我们删除原来的变量，因为我们已经创建了我们的一次性编码变量:</li>
</ol>
<pre class="calibre18"># Dropping the original variable after one-hot encoding the original variable<br class="title-page-name"/># inplace = True option will overwrite the DataFrame<br class="title-page-name"/><br class="title-page-name"/>housepricesdata.drop(['LotShape'],axis=1, inplace=True)</pre>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How it works...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">它是如何工作的...</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre12">pandas</kbd>模块是 Python 标准库的一部分——它是数据操作的关键模块之一。我们也用过其他的包，比如<kbd class="calibre12">os</kbd>和<kbd class="calibre12">datetime</kbd>。在我们设置了工作目录并将 CSV 文件作为<kbd class="calibre12">pandas</kbd>数据帧读入 Python 之后，我们继续研究一些数据操作方法。</p>
<p class="calibre2"><em class="calibre13">上一节的步骤 1 </em>到<em class="calibre13">步骤 5 </em>向我们展示了如何使用<kbd class="calibre12">pandas</kbd>从 Python 中的 CSV 文件读取数据，以及如何使用<kbd class="calibre12">dtypes</kbd>等函数。</p>
<p><kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas</kbd>包还提供了从各种文件类型中读取数据的方法。例如，<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas.read_excel()</kbd>将 Excel 表格读入<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas</kbd>data frame；<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas.read_json()</kbd>将 JSON 字符串转换成<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas</kbd>对象；并且<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas.read_parquet()</kbd>从文件路径加载一个 parquet 对象并返回<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pandas</kbd>数据帧。有关这方面的更多信息可以在 https://bit.ly/2yBqtvd<a xmlns:epub="http://www.idpf.org/2007/ops" href="https://bit.ly/2yBqtvd" class="calibre21">找到。</a></p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">还可以使用<kbd class="calibre12">h5py</kbd>包读取 Python 中的 HDF5 格式文件。<kbd class="calibre12">h5py</kbd>包是 HDF5 二进制数据格式的 Python 接口。HDF 支持 n 维数据集，数据集中的每个元素本身都可能是一个复杂的对象。集合中数据对象的数量或大小没有限制。更多信息可以在<a href="https://www.hdfgroup.org/" class="calibre9">https://www.hdfgroup.org/</a>找到。示例代码块如下所示:</p>
<pre class="calibre22">import h5py<br class="title-page-name"/><br class="title-page-name"/># With 'r' passed as a parameter to the h5py.File() <br class="title-page-name"/># the file will be read in read-only mode<br class="title-page-name"/>data = h5py.File('File Name.h5', 'r')</pre>
<p class="calibre2">我们查看变量的数据类型，并使用<kbd class="calibre12">describe()</kbd>查看数字变量的汇总统计数据。我们需要注意的是<kbd class="calibre12">describe()</kbd>只对数值型变量起作用，并且足够智能，可以忽略非数值型变量。在<em class="calibre13">步骤 6 </em>中，我们看到了如何查看分类变量(如<kbd class="calibre12">LotShape</kbd>和<kbd class="calibre12">LandContour</kbd>)的每个级别的计数。我们可以用同样的代码来看看其他分类变量的分布。</p>
<p class="calibre2">在<em class="calibre13">步骤 7 </em>中，我们使用<kbd class="calibre12">pd.crosstab()</kbd>查看了<kbd class="calibre12">LotShape</kbd>和<kbd class="calibre12">LandContour</kbd>变量的分布。</p>
<p>交叉表中的一个常见需求是包含行和列的小计。我们可以使用关键字<kbd class="calibre19">margins</kbd>显示小计。我们将<kbd class="calibre19">margins=True</kbd>传递给<kbd class="calibre19">pd.crosstab()</kbd>函数。我们还可以使用关键字<kbd class="calibre19">margins_name</kbd>给小计列命名。<kbd class="calibre19">margins_name</kbd>的默认值为<kbd class="calibre19">All</kbd>。</p>
<p class="calibre2">然后我们继续学习如何转换数据类型。我们有一些变量实际上是分类的，但在数据集中似乎是数字的。现实生活中经常会出现这种情况，因此我们需要学习如何对变量进行类型转换。<em class="calibre13">第 8 步</em>向我们展示了如何将一个数字变量，比如<kbd class="calibre12">MSSubClass</kbd>，转换成一个分类类型。在<em class="calibre13">步骤 8 </em>中，我们将一些变量转换成分类数据类型。然后我们创建了一个交叉表来可视化每一级分类变量的频率。</p>
<p class="calibre2">在<em class="calibre13">步骤 9 </em>中，我们从现有变量中创建了新的有意义的变量。我们分别从<kbd class="calibre12">YearBuilt</kbd>和<kbd class="calibre12">YearRemodAdd</kbd>中创建了新的变量<kbd class="calibre12">BuildingAge</kbd>和<kbd class="calibre12">RemodelAge</kbd>，来表示建筑的年龄和自建筑被改造以来已经过去的年数。这种创建新变量的方法可以为我们的分析和建模提供更好的见解。这个创建新特征的过程被称为<strong class="calibre4">特征工程</strong>。在<em class="calibre13">步骤 10 </em>中，我们将新变量添加到我们的数据框架中。</p>
<p class="calibre2">从那里，我们继续对我们的分类变量进行编码。我们需要对我们的分类变量进行编码，因为它们有命名的描述。许多机器学习算法无法对带标签的数据进行操作，因为它们要求所有输入和输出变量都是数字。在<em class="calibre13">步骤 12 </em>中，我们用一键编码对它们进行编码。在<em class="calibre13">步骤 11 </em>中，我们学习了如何使用<kbd class="calibre12">get_dummies()</kbd>函数，它是<kbd class="calibre12">pandas</kbd>包的一部分，来创建独热编码变量。在<em class="calibre13">步骤 12 </em>中，我们将<kbd class="calibre12">one-hot_encoded_variables</kbd>添加到我们的数据帧中。最后，在<em class="calibre13">步骤 13 </em>中，我们删除了现在被一键编码的原始变量。</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>There's more...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">还有更多...</h1>
                
            
            
                
<p class="calibre2">所需的数据操作类型取决于您的业务需求。在第一个方法中，我们看到了一些执行数据操作的方法，但是对于您可以做什么以及如何操作数据进行分析没有限制。</p>
<p class="calibre2">我们还看到了如何将数字变量转换成分类变量。我们可以用很多方法来做这种类型转换。例如，如果需要，我们可以使用以下代码将分类变量转换为数值变量:</p>
<pre class="calibre15"># Converting a categorical variable to numerical<br class="title-page-name"/># Using astype() to cast a pandas object to a specified datatype<br class="title-page-name"/><br class="title-page-name"/># Here we typecast GarageYrBlt from float64 type to int64 type<br class="title-page-name"/>housepricesdata['GarageYrBlt'] = housepricesdata['GarageYrBlt'].astype('int64')</pre>
<p class="calibre2">只有当<kbd class="calibre12">GarageYrBlt</kbd>变量不包含任何缺失值时，才能转换该变量。前面的代码将抛出一个错误，因为<kbd class="calibre12">GarageYrBlt</kbd>包含缺失值。</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">我们已经了解了如何使用一键编码将分类变量转换为数值变量，以及为什么要这样做。除了一键编码之外，我们还可以执行其他类型的编码，例如标签编码、频率编码等等。下面的代码块给出了标签编码的示例代码:</p>
<pre class="calibre15"># We use sklearn.preprocessing and import LabelEncoder class<br class="title-page-name"/>from sklearn.preprocessing import LabelEncoder<br class="title-page-name"/><br class="title-page-name"/># Create instance of LabelEncoder class<br class="title-page-name"/>lb_make = LabelEncoder()<br class="title-page-name"/><br class="title-page-name"/># We create a new variable LotConfig_code to hold the new numerical labels<br class="title-page-name"/># We label encode LotConfig variable<br class="title-page-name"/>housepricesdata["LotConfig_Code"] = lb_make.fit_transform(housepricesdata["LotConfig"])<br class="title-page-name"/><br class="title-page-name"/># Display the LotConfig variable and its corresponding label encoded numerical values<br class="title-page-name"/>housepricesdata[["LotConfig", "LotConfig_Code"]]</pre>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>See also</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">请参见</h1>
                
            
            
                
<ul class="calibre10">
<li class="calibre11">熊猫指南类型转换功能(<a href="https://bit.ly/2MzFwiG" class="calibre9">https://bit.ly/2MzFwiG</a>)</li>
<li class="calibre11">熊猫指南使用<kbd class="calibre12">get_dummies()</kbd>(<a href="https://bit.ly/2N1xjTZ" class="calibre9">https://bit.ly/2N1xjTZ</a>)进行一键编码</li>
<li class="calibre11">sci kit-一键编码学习指南(<a href="https://bit.ly/2wrNNLz" class="calibre9">https://bit.ly/2wrNNLz</a>)</li>
<li class="calibre11">sci kit-标签编码学习指南(<a href="https://bit.ly/2pDddVb" class="calibre9">https://bit.ly/2pDddVb</a>)</li>
</ul>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Analyzing, visualizing, and treating missing values</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">分析、可视化和处理缺失值</h1>
                
            
            
                
<p class="calibre2">缺失值是由不完整的数据引起的。有效处理缺失值非常重要，因为它们会导致不准确的推断和结论。在本节中，我们将了解如何分析、可视化和处理缺失值。</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How to do it...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">怎么做...</h1>
                
            
            
                
<p class="calibre2">让我们从分析缺失值的变量开始。设置 pandas 中的选项以查看所有行和列，如前一节所示:</p>
<ol class="calibre14">
<li class="calibre11">使用以下语法，我们可以看到哪些变量缺少值:</li>
</ol>
<pre class="calibre18"># Check which variables have missing values<br class="title-page-name"/><br class="title-page-name"/>columns_with_missing_values = housepricesdata.columns[housepricesdata.isnull().any()]<br class="title-page-name"/>housepricesdata[columns_with_missing_values].isnull().sum()</pre>
<p class="calibre2"/>
<p class="calibre20">这将产生以下输出:</p>
<p class="CDPAlignCenter"><img class="aligncenter4" src="img/9acdec10-9936-422f-9b64-e31b4d337ac2.png"/></p>
<ol start="2" class="calibre14">
<li class="calibre11">您可能还想查看百分比形式的缺失值。要查看缺失值的计数和百分比，请执行以下命令:</li>
</ol>
<pre class="calibre18">import numpy as np<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/> <br class="title-page-name"/># To hold variable names<br class="title-page-name"/>labels = [] <br class="title-page-name"/><br class="title-page-name"/># To hold the count of missing values for each variable <br class="title-page-name"/>valuecount = [] <br class="title-page-name"/><br class="title-page-name"/># To hold the percentage of missing values for each variable<br class="title-page-name"/>percentcount = [] <br class="title-page-name"/><br class="title-page-name"/>for col in columns_with_missing_values:<br class="title-page-name"/>    labels.append(col)<br class="title-page-name"/>    valuecount.append(housepricesdata[col].isnull().sum())<br class="title-page-name"/>    # housepricesdata.shape[0] will give the total row count<br class="title-page-name"/>   percentcount.append(housepricesdata[col].isnull().sum()/housepricesdata.shape[0])<br class="title-page-name"/>    <br class="title-page-name"/>ind = np.arange(len(labels))<br class="title-page-name"/><br class="title-page-name"/>fig, (ax1, ax2) = plt.subplots(1,2,figsize=(20,18))<br class="title-page-name"/><br class="title-page-name"/>rects = ax1.barh(ind, np.array(valuecount), color='blue')<br class="title-page-name"/>ax1.set_yticks(ind)<br class="title-page-name"/>ax1.set_yticklabels(labels, rotation='horizontal')<br class="title-page-name"/>ax1.set_xlabel("Count of missing values")<br class="title-page-name"/>ax1.set_title("Variables with missing values")<br class="title-page-name"/><br class="title-page-name"/>rects = ax2.barh(ind, np.array(percentcount), color='pink')<br class="title-page-name"/>ax2.set_yticks(ind)<br class="title-page-name"/>ax2.set_yticklabels(labels, rotation='horizontal')<br class="title-page-name"/>ax2.set_xlabel("Percentage of missing values")<br class="title-page-name"/>ax2.set_title("Variables with missing values")</pre>
<p class="calibre20">它将以绝对值和百分比的形式显示缺失的值，如下面的屏幕截图所示:</p>
<p class="CDPAlignCenter"><img class="aligncenter5" src="img/56aadd15-3792-4bd6-af6b-8494ad2e1288.png"/></p>
<p class="calibre20">我们注意到，变量<strong class="calibre4"> Alley </strong>、<strong class="calibre4"> PoolQC </strong>、<strong class="calibre4"> Fence </strong>和<strong class="calibre4">misfeature</strong>有<strong class="calibre4"> 80% </strong>到<strong class="calibre4"> 90% </strong>的值缺失。<strong class="calibre4"> FireplaceQu </strong>有<strong class="calibre4"> 47.26% </strong>的值缺失。其他一些变量，如<strong class="calibre4"> LotFrontage </strong>、<strong class="calibre4"> MasVnrType </strong>、<strong class="calibre4"> MasVnrArea </strong>、<strong class="calibre4"> BsmtQual </strong>、<strong class="calibre4"> BsmtCond </strong>，以及其他一些与车库相关的变量也有缺失值。</p>
<p class="calibre2"/>
<p class="calibre20">但是有一个问题。我们再来看一下<kbd class="calibre12">Alley</kbd>变量。它显示它有<strong class="calibre4"> 93.76% </strong>的缺失值。现在再看一下我们在上一节中看到的数据描述。<kbd class="calibre12">Alley</kbd>的变量描述显示其有三个级别:<em class="calibre13">砾石</em>、<em class="calibre13">铺砌</em>、<em class="calibre13">无通路</em>。在原始数据集中，<kbd class="calibre12">'No Access'</kbd>被编码为<kbd class="calibre12">NA</kbd>。在 Python 中读取<kbd class="calibre12">NA</kbd>时，它被当作<strong class="calibre4"> NaN </strong>，这意味着缺少一个值，所以我们需要小心。</p>
<ol start="3" class="calibre14">
<li class="calibre11">现在，我们将用有效值替换<kbd class="calibre12">Alley</kbd>的缺失值，例如<kbd class="calibre12">'No Access'</kbd>:</li>
</ol>
<pre class="calibre18"># Replacing missing values with 'No Access' in Alley variable<br class="title-page-name"/>housepricesdata['Alley'].fillna('No Access', inplace=True)</pre>
<ol start="4" class="calibre14">
<li class="calibre11">现在，让我们将缺失的值可视化，并尝试看看如何处理它们。以下代码生成一个图表，展示缺失值的分布情况。这里我们使用<kbd class="calibre12">seaborn</kbd>库来绘制图表:</li>
</ol>
<pre class="calibre18"># Lets import seaborn. We will use seaborn to generate our charts<br class="title-page-name"/>import seaborn as sns<br class="title-page-name"/><br class="title-page-name"/># We will import matplotlib to resize our plot figure<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/>plt.figure(figsize=(20, 10))<br class="title-page-name"/><br class="title-page-name"/># cubehelix palette is a part of seaborn that produces a colormap<br class="title-page-name"/>cmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)<br class="title-page-name"/>sns.heatmap(housepricesdata.isnull(), cmap=cmap)</pre>
<p class="calibre20">通过<kbd class="calibre12">cubehelix_palette()</kbd>功能生成亮度线性增加的地图颜色:</p>
<p class="CDPAlignCenter"><img class="aligncenter6" src="img/fce12232-d35b-4808-a677-f6aa0a48a877.png"/></p>
<p class="calibre20">从前面的图中，可以更容易地看出缺失值的分布。图表上的白色标记表示缺少的值。注意<kbd class="calibre12">Alley</kbd>不再报告任何丢失的值。</p>
<ol start="5" class="calibre14">
<li class="calibre11"><kbd class="calibre12">LotFrontage</kbd>为连续变量，缺失<strong class="calibre1"> 17.74% </strong>的值。将此变量中缺失的值替换为其中值，如下所示:</li>
</ol>
<pre class="calibre18"># Filling in the missing values in LotFrontage with its median value<br class="title-page-name"/>housepricesdata['LotFrontage'].fillna(housepricesdata['LotFrontage'].median(), inplace=True)</pre>
<p class="calibre2">让我们再次查看缺失值图，看看来自<kbd class="calibre12">LotFrontage</kbd>的缺失值是否已被估算。复制并执行前面的代码。缺失值图如下所示:</p>
<ol start="6" class="calibre14">
<li class="calibre11"><img class="aligncenter7" src="img/3fee1f9b-cda4-48f0-acaf-6dddba9faf97.png"/></li>
</ol>
<p class="CDPAlignCenter">这里，我们可以在前面的图中看到，<kbd class="calibre12">Alley</kbd>或<kbd class="calibre12">LotFrontage</kbd>不再有缺失值。</p>
<p class="calibre20">我们从数据描述中发现，有几个变量的值被编码为<kbd class="calibre12">NA</kbd>。因为这在 Python 中被读取为缺失值，所以我们用它们的实际值替换所有这些值，我们可以在下面的代码块中显示的数据描述中看到这些值:</p>
<ol start="7" class="calibre14">
<li class="calibre11">在处理了前面的变量之后，让我们来看看缺失值图:</li>
</ol>
<pre class="calibre18"># Replacing all NA values with their original meaning<br class="title-page-name"/>housepricesdata['BsmtQual'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtCond'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtExposure'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtFinType1'].fillna('No Basement', inplace=True)<br class="title-page-name"/>housepricesdata['BsmtFinType2'].fillna('No Basement', inplace=True)<br class="title-page-name"/><br class="title-page-name"/>housepricesdata['GarageYrBlt'].fillna(0, inplace=True)<br class="title-page-name"/><br class="title-page-name"/># For observations where GarageType is null, we replace null values in GarageYrBlt=0<br class="title-page-name"/>housepricesdata['GarageType'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageFinish'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageQual'].fillna('No Garage', inplace=True)<br class="title-page-name"/>housepricesdata['GarageCond'].fillna('No Garage', inplace=True)<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>housepricesdata['PoolQC'].fillna('No Pool', inplace=True)<br class="title-page-name"/>housepricesdata['Fence'].fillna('No Fence', inplace=True)<br class="title-page-name"/>housepricesdata['MiscFeature'].fillna('None', inplace=True)<br class="title-page-name"/><br class="title-page-name"/>housepricesdata['FireplaceQu'].fillna('No Fireplace', inplace=True)</pre>
<ol start="8" class="calibre14">
<li class="calibre11"><img class="aligncenter8" src="img/e0321ab2-6f0f-4f91-9157-699fdae69fed.png"/></li>
</ol>
<p class="CDPAlignCenter">我们从前面的图中注意到，对于我们刚刚处理过的变量，不再有丢失的值。然而，我们在<kbd class="calibre12">MasVnrType</kbd>、<kbd class="calibre12">MasVnrArea</kbd>和<kbd class="calibre12">Electrical</kbd>中留下了一些缺失的值。</p>
<p class="calibre20">让我们用一个交叉表来看看<kbd class="calibre12">MasVnrArea</kbd>对<kbd class="calibre12">MasVnrType</kbd>的分布:</p>
<ol start="9" class="calibre14">
<li class="calibre11">以下输出显示，当<kbd class="calibre12">MasVnrArea</kbd>为零时，我们在大多数情况下将<kbd class="calibre12">MasVnrType</kbd>作为<kbd class="calibre12">None</kbd>:</li>
</ol>
<pre class="calibre18"># Using crosstab to generate the count of MasVnrType by type of MasVnrArea<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["MasVnrType"],\<br class="title-page-name"/>                  columns=housepricesdata["MasVnrArea"], dropna=False, margins=True)) </pre>
<p class="calibre20"><img class="aligncenter9" src="img/a65a465b-030d-4368-8a76-e1c0e6b36702.png"/></p>
<p class="CDPAlignCenter">然后，我们将在<kbd class="calibre12">MasVnrType</kbd>中用<kbd class="calibre12">None</kbd>和<kbd class="calibre12">MasVnrArea</kbd>中用零来估算缺失值。这是通过以下代码块中显示的命令完成的:</p>
<ol start="10" class="calibre14">
<li class="calibre11">我们仍然在<kbd class="calibre12">Electrical</kbd>变量中缺少一个值。</li>
</ol>
<pre class="calibre18"># Filling in the missing values for MasVnrType and MasVnrArea with None and 0 respectively<br class="title-page-name"/>housepricesdata['MasVnrType'].fillna('None', inplace=True)<br class="title-page-name"/>housepricesdata['MasVnrArea'].fillna(0, inplace=True)</pre>
<p class="calibre20">让我们看看<kbd class="calibre12">Electrical</kbd>有一个缺失值的观察结果:</p>
<ol start="11" class="calibre14">
<li class="calibre11"><img class="aligncenter10" src="img/9dbf6447-f753-49e3-8e0a-7a674d0c92d4.png"/></li>
</ol>
<pre class="calibre18">housepricesdata['MSSubClass'][housepricesdata['Electrical'].isnull()]</pre>
<p class="CDPAlignCenter">我们看到当<kbd class="calibre12">Electrical</kbd>为空时<kbd class="calibre12">MSSubClass</kbd>为<kbd class="calibre12">80</kbd>。让我们看看<kbd class="calibre12">MSSubClass</kbd>的<kbd class="calibre12">Electrical</kbd>型的分布:</p>
<ol start="12" class="calibre14">
<li class="calibre11">从下面的输出中，我们可以看到当<kbd class="calibre12">MSSubClass</kbd>为<kbd class="calibre12">80</kbd>时，<kbd class="calibre12">Electrical</kbd>类型的大多数情况是<kbd class="calibre12">SBrkr</kbd>:</li>
</ol>
<pre class="calibre18"># Using crosstab to generate the count of Electrical Type by MSSubClass<br class="title-page-name"/>print(pd.crosstab(index=housepricesdata["Electrical"],\<br class="title-page-name"/>columns=housepricesdata['MSSubClass'], dropna=False, margins=True))</pre>
<p class="CDPAlignLeft1"><img class="aligncenter11" src="img/ba143935-687a-420c-955c-06f40a4920d6.png"/></p>
<p class="CDPAlignCenter">继续执行以下代码，用<kbd class="calibre12">SBrKr</kbd>估算<kbd class="calibre12">Electrical</kbd>变量中的缺失值:</p>
<ol start="13" class="calibre14">
<li class="calibre11">之后，让我们最后一次看看我们的缺失值图:</li>
</ol>
<pre class="calibre18">housepricesdata['Electrical'].fillna('SBrkr', inplace=True)</pre>
<ol start="14" class="calibre14">
<li class="calibre11">我们得到的输出可以在下面的图表中看到:</li>
</ol>
<pre class="calibre18">import seaborn as sns<br class="title-page-name"/>import matplotlib.pyplot as plt<br class="title-page-name"/>%matplotlib inline<br class="title-page-name"/>plt.figure(figsize=(20, 10))<br class="title-page-name"/><br class="title-page-name"/>cmap = sns.cubehelix_palette(light=1, as_cmap=True, reverse=True)<br class="title-page-name"/>sns.heatmap(housepricesdata.isnull(), cmap=cmap)</pre>
<p class="calibre20"><img class="aligncenter12" src="img/ce0bfa9e-4173-4621-9497-9242509f5889.png"/></p>
<p class="CDPAlignCenter">请注意，图已经改变，现在在我们的数据框架中没有显示缺失值。</p>
<p class="calibre2">它是如何工作的...</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How it works...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">在<em class="calibre13">步骤 1 </em>和<em class="calibre13">步骤</em> <em class="calibre13"> 2 </em>中，我们以绝对值和百分比的形式查看了缺失值的变量。我们注意到<kbd class="calibre12">Alley</kbd>变量丢失了超过<strong class="calibre4"> 93% </strong>的值。然而，从数据描述中，我们发现<kbd class="calibre12">Alley</kbd>变量有一个<strong class="calibre4">不能访问通道</strong>的值，该值在数据集中被编码为<kbd class="calibre12">NA</kbd>。当在 Python 中读取该值时，所有的<kbd class="calibre12">NA</kbd>实例都被视为缺失值。在<em class="calibre13">步骤 3 </em>中，我们将<kbd class="calibre12">Alley</kbd>中的<kbd class="calibre12">NA</kbd>替换为<kbd class="calibre12">No Access</kbd>。</h1>
                
            
            
                
<p class="calibre2">注意，我们在<em class="calibre23">步骤 2 </em>中使用了<kbd class="calibre19">%matplotlib inline</kbd>。这是一个神奇的功能，可以渲染笔记本本身的剧情。</p>
<p>在<em class="calibre13">步骤 4 </em>中，我们使用了<kbd class="calibre12">seaborn</kbd>库来绘制缺失值图表。在这个图表中，我们确定了缺少值的变量。缺失的值用白色表示，而存在的数据用彩色表示。我们从图表中注意到<kbd class="calibre12">Alley</kbd>不再有丢失的值。</p>
<p class="calibre2">在<em class="calibre23">步骤 4 </em>中，我们使用了<kbd class="calibre19">seaborn</kbd>库中的<kbd class="calibre19">cubehelix_palette()</kbd>，它产生了一个亮度线性降低(或增加)的彩色地图。<kbd class="calibre19">seaborn</kbd>库还为我们提供了包括<kbd class="calibre19">light_palette()</kbd>和<kbd class="calibre19">dark_palette()</kbd>在内的选项。<kbd class="calibre19">light_palette()</kbd>给出从亮到色混合的连续调色板，而<kbd class="calibre19">dark_palette()</kbd>产生从暗到色混合的连续调色板。</p>
<p>在<em class="calibre13">步骤 5 </em>中，我们注意到其中一个数值变量<kbd class="calibre12">LotFrontage</kbd>有超过<strong class="calibre4"> 17% </strong>的值缺失。我们决定用这个变量的中间值来估算缺失值。我们重新查看了<em class="calibre13">步骤 6 </em>中的缺失值图表，以查看变量是否有缺失值。我们注意到<kbd class="calibre12">Alley</kbd>和<kbd class="calibre12">LotFrontage</kbd>没有显示白色标记，这表明这两个变量都没有任何进一步缺失的值。</p>
<p class="calibre2">在<em class="calibre13">步骤 7 </em>中，我们确定了一些变量，这些变量的数据用<kbd class="calibre12">NA</kbd>编码。这导致了我们之前遇到的同样的问题，因为 Python 将它们视为缺失值。我们用实际信息取代了所有这些编码值。</p>
<p class="calibre2">然后，我们在<em class="calibre13">步骤 8 </em>中重新查看了缺失值图表。我们看到，除了<kbd class="calibre12">MasVnrType</kbd>、<kbd class="calibre12">MasVnrArea</kbd>和<kbd class="calibre12">Electrical</kbd>，几乎所有的变量都没有缺失值。</p>
<p class="calibre2">在<em class="calibre13">第 9 步</em>和<em class="calibre13">第 10 步</em>中，我们填充了<kbd class="calibre12">MasVnrType</kbd>和<kbd class="calibre12">MasVnrArea</kbd>变量的缺失值。我们注意到，每当<kbd class="calibre12">MasVnrArea</kbd>是<kbd class="calibre12">0.0</kbd>的时候<kbd class="calibre12">MasVnrType</kbd>就是<kbd class="calibre12">None</kbd>，除了一些极少数的场合。因此，我们用<kbd class="calibre12">None</kbd>估算<kbd class="calibre12">MasVnrType</kbd>变量，用<kbd class="calibre12">0.0</kbd>估算<kbd class="calibre12">MasVnrArea</kbd>变量，只要这两个变量有缺失值。然后我们只剩下一个缺少值的变量，<kbd class="calibre12">Electrical</kbd>。</p>
<p class="calibre2">在<em class="calibre13">步骤 11 </em>中，我们查看了哪种类型的房屋缺少<kbd class="calibre12">Electrical</kbd>值。我们注意到<kbd class="calibre12">MSSubClass</kbd>表示住宅类型，对于缺少的<kbd class="calibre12">Electrical </kbd>值，<kbd class="calibre12">MSSubClass</kbd>是<kbd class="calibre12">80</kbd>，这意味着它是分割的或多层次的。在<em class="calibre13">步骤 12 </em>中，我们按住宅类型查看了<kbd class="calibre12">Electrical</kbd>的分布，为<kbd class="calibre12">MSSubClass</kbd>。我们注意到当<kbd class="calibre12">MSSubClass</kbd>等于<kbd class="calibre12">80</kbd>时，<kbd class="calibre12">Electrical</kbd>的大部分值是<kbd class="calibre12">SBrkr</kbd>，代表标准断路器和 Romex。为此，我们决定用<kbd class="calibre12">SBrkr</kbd>来估算<kbd class="calibre12">Electrical</kbd>中缺失的值。</p>
<p class="calibre2">最后，在<em class="calibre13">步骤 14 </em>中，我们再次查看缺失值图表，发现数据集中不再有缺失值。</p>
<p class="calibre2">还有更多...</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>There's more...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">使用前面的图和缺失值图表，很容易计算出数据集中缺失值的数量、百分比和分布。我们注意到，对于相同的观察结果，许多变量都有缺失值。但是查阅数据描述后，我们看到大部分的缺失值其实并没有缺失，只是由于它们被编码为<kbd class="calibre12">NA</kbd>，熊猫将其作为缺失值处理。</h1>
                
            
            
                
<p class="calibre2">对于数据分析师来说，理解数据描述并恰当地处理缺失值是非常重要的。</p>
<p class="calibre2">通常，丢失的数据分为三类:</p>
<p class="calibre2"><strong class="calibre1">完全随机缺失</strong> ( <strong class="calibre1"> MCAR </strong> ): MCAR 表示缺失值与被研究对象无关。换句话说，当一个变量缺失数据的概率与其他测量变量或值本身无关时，数据就是 MCAR。这方面的一个例子可能是，某项调查中某些被调查者的年龄没有被记录下来，这完全是偶然的。</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">随机缺失</strong> ( <strong class="calibre1"> MAR </strong>):名称 MAR 在这里有点误导，因为在这种情况下，值的缺失不是随机的。如果数据的缺失与其他观察到的变量有关，但与数据本身的潜在值无关，则数据是 MAR。例如，当我们从客户那里收集数据时，与其他客户相比，富裕客户不太可能披露他们的收入，从而导致 MAR 数据。</li>
<li class="calibre11"><strong class="calibre1">非随机遗漏</strong> ( <strong class="calibre1"> MNAR </strong>):数据是 MNAR，如果不能归类为 MCAR 或马尔，也称为<strong class="calibre1">不可忽略</strong>。例如，当年龄超过 40 岁时，可能有些消费者不想分享他们的年龄，因为他们想隐瞒年龄。</li>
<li class="calibre11">有多种策略可用于估算缺失值，如下所示:</li>
</ul>
<p class="calibre2">寻找缺失数据的来源</p>
<ul class="calibre10">
<li class="calibre11">省略不完整的观察</li>
<li class="calibre11">用估计值替换缺失的数据，如平均值或中值</li>
<li class="calibre11">估计数据集中其他变量的缺失数据</li>
<li class="calibre11">请参见</li>
</ul>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>See also</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">用于插补的 scikit-learn 模块(<a href="https://bit.ly/2MzFwiG" class="calibre9">https://bit.ly/2MzFwiG</a>)</h1>
                
            
            
                
<ul class="calibre10">
<li class="calibre11">使用 Python 中的<kbd class="calibre12">StatsModels</kbd>库通过链式方程进行多重插补(<a href="https://bit.ly/2PYLuYy" class="calibre9">https://bit.ly/2PYLuYy</a>)</li>
<li class="calibre11">使用范西姆普特(<a href="https://bit.ly/2MJKfOY" class="calibre9">https://bit.ly/2MJKfOY</a>)的特征插补算法</li>
<li class="calibre11">探索性数据分析</li>
</ul>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Exploratory data analysis</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">我们将从上一节停止的地方继续分析和处理缺失值。数据科学家花大部分时间做数据准备和探索，而不是建模和优化。既然我们的数据集没有缺失值，我们可以继续进行探索性数据分析。</h1>
                
            
            
                
<p class="calibre2">怎么做...</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How to do it...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">在关于数据操作的第一部分中，我们看到了数据集的汇总统计数据。然而，自从输入缺失值后，我们就没有再研究过这个问题。</h1>
                
            
            
                
<ol class="calibre14">
<li class="calibre11">现在，让我们使用以下代码来查看数据及其基本统计信息:</li>
</ol>
<p class="calibre20">通过前面的代码，我们可以看到前面部分中变量的汇总统计数据。</p>
<pre class="calibre18"># To take a look at the top 5 rows in the dataset<br class="title-page-name"/>housepricesdata.head(5)<br class="title-page-name"/><br class="title-page-name"/># To display the summary statistics for all variables<br class="title-page-name"/>housepricesdata.describe()</pre>
<ol start="2" class="calibre14">
<li class="calibre11">现在让我们来看看数据类型有多少列:</li>
</ol>
<p class="calibre20">下面的代码向我们展示了每种数据类型有多少个变量。我们可以看到，我们有 3 个浮点类型变量、33 个整数类型变量、45 个对象类型变量和 4 个无符号整数，它们保存了<kbd class="calibre12">LotShape</kbd>变量的一位热码编码值:</p>
<pre class="calibre18"># How many columns with different datatypes are there?<br class="title-page-name"/>housepricesdata.get_dtype_counts()</pre>
<p class="calibre20"><img class="aligncenter13" src="img/90ebfe78-e84f-406b-9455-c774e6817f53.png"/></p>
<p class="CDPAlignCenter">让我们创建两个变量来保存数值变量和分类变量的名称:</p>
<ol start="3" class="calibre14">
<li class="calibre11">这向我们展示了数字和分类变量的数量:</li>
</ol>
<pre class="calibre18"># Pulling out names of numerical variables by conditioning dtypes NOT equal to object type<br class="title-page-name"/>numerical_features = housepricesdata.dtypes[housepricesdata.dtypes != "object"].index<br class="title-page-name"/>print("Number of Numerical features: ", len(numerical_features))<br class="title-page-name"/><br class="title-page-name"/># Pulling out names of categorical variables by conditioning dtypes equal to object type<br class="title-page-name"/>categorical_features = housepricesdata.dtypes[housepricesdata.dtypes == "object"].index<br class="title-page-name"/>print("Number of Categorical features: ", len(categorical_features))</pre>
<p class="calibre20"><img class="aligncenter14" src="img/a2029e24-dcf1-403a-b0f3-11f5a2444dfe.png"/></p>
<p class="CDPAlignCenter">我们现在将使用之前创建的<kbd class="calibre12">numerical_features</kbd>变量来查看数值变量的分布。我们将使用<kbd class="calibre12">seaborn</kbd>库来绘制图表:</p>
<ol start="4" class="calibre14">
<li class="calibre11">我们使用熊猫的<kbd class="calibre19">melt()</kbd>方法来重塑我们的数据框架。在使用<kbd class="calibre19">melt()</kbd>方法了解数据帧的排列方式后，您可能想要查看整形后的数据。</li>
</ol>
<p>上述代码使用分布图向我们展示了数值变量观测值的单变量分布:</p>
<pre class="calibre18">melt_num_features = pd.melt(housepricesdata, value_vars=numerical_features)<br class="title-page-name"/><br class="title-page-name"/>grid = sns.FacetGrid(melt_num_features, col="variable", col_wrap=5, sharex=False, sharey=False)<br class="title-page-name"/>grid = grid.map(sns.distplot, "value", color="blue") </pre>
<p class="calibre20"><img class="aligncenter15" src="img/e7c5098f-9d3f-4ddd-b430-a60b5a8883c6.png"/></p>
<p class="CDPAlignCenter"><img class="aligncenter15" src="img/e7c5098f-9d3f-4ddd-b430-a60b5a8883c6.png"/></p>
<p class="calibre2"/>
<p class="calibre2">现在，我们使用<kbd class="calibre12">categorical_features</kbd>变量来绘制每个分类变量的房价分布图:</p>
<ol start="5" class="calibre14">
<li class="calibre11">在我们的数据集中，我们看到各种各样的属性可以驱动房价。我们可以尝试查看属性和表示房屋价格的变量<kbd class="calibre19">SalesPrice</kbd>之间的关系。</li>
</ol>
<pre class="calibre18">melt_cat_features = pd.melt(housepricesdata, id_vars=['SalePrice'], value_vars=categorical_features)<br class="title-page-name"/><br class="title-page-name"/>grid = sns.FacetGrid(melt_cat_features, col="variable", col_wrap=2, sharex=False, sharey=False, size=6)<br class="title-page-name"/>grid.map(sns.boxplot, "value", "SalePrice", palette="Set3")<br class="title-page-name"/>grid.fig.subplots_adjust(wspace=1, hspace=0.25)<br class="title-page-name"/><br class="title-page-name"/>for ax in grid.axes.flat: <br class="title-page-name"/>    plt.setp(ax.get_xticklabels(), rotation=90)</pre>
<p>让我们在下面的图中看到每个分类变量的房屋销售价格分布:</p>
<p class="CDPAlignLeft1"><img class="aligncenter16" src="img/f69cc0a0-e586-4c9f-8e8a-74fd2816c47e.png"/></p>
<p class="CDPAlignCenter">我们现在将使用以下代码来查看所有数值变量的相关矩阵:</p>
<ol start="6" class="calibre14">
<li class="calibre11">这将为您提供以下输出:</li>
</ol>
<pre class="calibre18"># Generate a correlation matrix for all the numerical variables<br class="title-page-name"/>corr=housepricesdata[numerical_features].corr()<br class="title-page-name"/>print(corr)</pre>
<p class="calibre20"><img class="aligncenter17" src="img/1e63dc46-aceb-4074-b6c0-5c5ec3261313.png"/></p>
<p class="CDPAlignCenter">可能很难查看前面格式中显示的相关性。你可能想用图表来看看这种相关性。</p>
<p class="calibre20">我们还可以查看数值变量的相关矩阵图。为此，我们使用在<em class="calibre23">步骤 3 </em>中创建的<kbd class="calibre12">numerical_features</kbd>变量来保存所有数值变量的名称:</p>
<ol start="7" class="calibre14">
<li class="calibre11">在前面的代码中，我们使用了<kbd class="calibre19">select_dtypes(include=[np.number])</kbd>来创建<kbd class="calibre19">df_numeric_features</kbd>变量。然而在<em class="calibre23">步骤 3 </em>中，我们用了<kbd class="calibre19">dtypes[housepricesdata.dtypes != "object"].index</kbd>。注意，<kbd class="calibre19">select_dtypes()</kbd>返回一个<kbd class="calibre19">pandas.DataFrame</kbd>，而<kbd class="calibre19">dtypes[].index</kbd>返回一个<kbd class="calibre19">pandas.Index</kbd>对象。</li>
</ol>
<pre class="calibre18"># Get correlation of numerical variables<br class="title-page-name"/>df_numerical_features= housepricesdata.select_dtypes(include=[np.number])<br class="title-page-name"/><br class="title-page-name"/>correlation= df_numerical_features.corr()<br class="title-page-name"/>correlation["SalePrice"].sort_values(ascending=False)*100<br class="title-page-name"/># Correlation Heat Map (Seaborn library)<br class="title-page-name"/>f, ax= plt.subplots(figsize=(14,14))<br class="title-page-name"/>plt.title("Correlation of Numerical Features with Sale Price", y=1, size=20)<br class="title-page-name"/><br class="title-page-name"/># cmap - matplotlib colormap name or object - can be used to set the color options<br class="title-page-name"/># vmin and vmax is used to anchor the colormap<br class="title-page-name"/>sns.heatmap(correlation, square= True, vmin=-0.2, vmax=0.8, cmap="YlGnBu")</pre>
<p>In the preceding code, we used <kbd class="calibre19">select_dtypes(include=[np.number])</kbd> to create the <kbd class="calibre19">df_numeric_features</kbd> variable. However, in <em class="calibre23">Step 3</em>, we used <kbd class="calibre19">dtypes[housepricesdata.dtypes != "object"].index</kbd>. Note that <kbd class="calibre19">select_dtypes()</kbd> returns a <kbd class="calibre19">pandas.DataFrame</kbd>, whereas <kbd class="calibre19">dtypes[].index</kbd> returns a <kbd class="calibre19">pandas.Index</kbd> object.</p>
<p class="calibre2"/>
<p class="calibre2">我们现在可以将相关图可视化如下:</p>
<p class="calibre20"><img class="aligncenter18" src="img/43b35176-1948-4674-89e9-07bfac1934cd.png"/></p>
<p class="CDPAlignCenter"><img class="aligncenter18" src="img/43b35176-1948-4674-89e9-07bfac1934cd.png"/></p>
<p class="calibre2"/>
<p class="calibre2">您可能还想评估数值变量与<kbd class="calibre12">SalePrice</kbd>的相关性，以了解这些数值变量与房价的关系:</p>
<div><kbd class="calibre19">cmap</kbd> is a Matplotlib color map object.There are various categories of color map, including sequential, diverging, and qualitative. Among the sequential colors, you may choose to set your <kbd class="calibre19">cmap</kbd> parameter to <kbd class="calibre19">BuPu</kbd> or <kbd class="calibre19">YlGn</kbd>. For qualitative colors, you can set it to values such as <kbd class="calibre19">Set3</kbd>, <kbd class="calibre19">Pastel2</kbd>, and so on. More information on color options can be found at <a href="https://matplotlib.org/tutorials/colors/colormaps.html" class="calibre21">https://matplotlib.org/tutorials/colors/colormaps.html</a>.</div>
<ol start="8" class="calibre14">
<li class="calibre11">下面的截图向我们展示了相关图。这里，我们绘制了每个数值变量与<kbd class="calibre12">SalePrice</kbd>之间的相关性:</li>
</ol>
<pre class="calibre18">row_count = 11<br class="title-page-name"/>col_count = 3<br class="title-page-name"/><br class="title-page-name"/>fig, axs = plt.subplots(row_count, col_count, figsize=(12,36))<br class="title-page-name"/>exclude_columns = ['Id', 'SalePrice']<br class="title-page-name"/>plot_numeric_features = [col for col in numerical_features if col not in exclude_columns]<br class="title-page-name"/><br class="title-page-name"/>for eachrow in range(0, row_count):<br class="title-page-name"/>    for eachcol in range(0, col_count): <br class="title-page-name"/>        i = eachrow*col_count + eachcol<br class="title-page-name"/>        if i &lt; len(plot_numeric_features):<br class="title-page-name"/>            sns.regplot(housepricesdata[plot_numeric_features[i]], housepricesdata['SalePrice'], \<br class="title-page-name"/>                ax = axs[eachrow][eachcol], color='purple', fit_reg=False)<br class="title-page-name"/><br class="title-page-name"/># tight_layout automatically adjusts subplot params so that the subplot(s) fits in to the figure area <br class="title-page-name"/>plt.tight_layout() <br class="title-page-name"/>plt.show()</pre>
<p class="CDPAlignLeft1"><br class="calibre6"/> <img class="aligncenter19" src="img/6a52456a-94c6-48ac-a721-8808c27fbaff.png"/></p>
<p class="CDPAlignCenter1">如果您想要评估数值变量与房屋销售价格之间的相关性，可以使用以下命令:</p>
<ol start="9" class="calibre14">
<li class="calibre11">您可以在下表中查看按降序排序的相关性输出:</li>
</ol>
<pre class="calibre18"># See correlation between numerical variables with house prices<br class="title-page-name"/>corr=housepricesdata.corr()["SalePrice"]<br class="title-page-name"/><br class="title-page-name"/># Sort the correlation values. <br class="title-page-name"/># Use [::-1] to sort it in descending manner<br class="title-page-name"/># Use [::+1] to sort it in ascending manner<br class="title-page-name"/>corr[np.argsort(corr)[::-1]]</pre>
<p class="calibre20"><img class="aligncenter20" src="img/ed9ccd39-d221-4fd8-b335-5dd28ab8cee9.png"/></p>
<p class="CDPAlignCenter">它是如何工作的...</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How it works...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">在<em class="calibre13">步骤 1 </em>中，我们从读取和描述我们的数据开始。这一步为我们的数据集提供了汇总统计数据。我们在<em class="calibre13">步骤 2 </em>中查看了每种数据类型的变量数量。</h1>
                
            
            
                
<p class="calibre2">在<em class="calibre13">步骤 3 </em>中，我们创建了两个变量，即<kbd class="calibre12">numerical_features</kbd>和<kbd class="calibre12">categorical_features</kbd>，分别存放数值型和分类型变量的名称。当我们分别处理数字和分类特征时，我们在步骤中使用了这两个变量。</p>
<p class="calibre2">In <em class="calibre13">Step 3</em>, we created two variables, namely, <kbd class="calibre12">numerical_features</kbd> and <kbd class="calibre12">categorical_features</kbd>, to hold the names of numerical and categorical variables respectively. We used these two variables in the steps when we worked with numerical and categorical features separately. </p>
<p class="calibre2"/>
<p class="calibre2">在<em class="calibre13">步骤</em> 4 和<em class="calibre13">步骤</em> 5 中，我们使用<kbd class="calibre12">seaborn</kbd>库来绘制我们的图表。我们还引入了来自 pandas 的<kbd class="calibre12">melt()</kbd>函数，该函数可用于重塑我们的数据帧，并将其提供给<kbd class="calibre12">seaborn</kbd>库的<kbd class="calibre12">FacetGrid()</kbd>函数。在这里，我们展示了如何一次性绘制所有数值变量的分布图。我们还向您展示了如何使用相同的<kbd class="calibre12">FacetGrid()</kbd>函数来绘制每个分类变量的<kbd class="calibre12">SalesPrice</kbd>分布。</p>
<p class="calibre2">我们在<em class="calibre13">步骤 6 </em>中使用 DataFrame 对象的<kbd class="calibre12">corr()</kbd>函数生成了相关矩阵。然而，我们注意到，由于变量太多，显示不便于您识别相关性。在<em class="calibre13">步骤 7 </em>中，我们使用<kbd class="calibre12">seaborn</kbd>库中的<kbd class="calibre12">heatmap()</kbd>函数绘制了相关矩阵热图。</p>
<p class="calibre2"><kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">corr()</kbd>函数计算变量的成对相关性，排除缺失值。<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">pearson</kbd>方法被用作计算相关性的默认方法。根据您的需求，您也可以使用<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">kendall</kbd>或<kbd xmlns:epub="http://www.idpf.org/2007/ops" class="calibre19">spearman</kbd>方法。更多信息可以在 https://bit.ly/2CdXr8n 找到。</p>
<p>在<em class="calibre13">步骤 8 </em>中，我们使用散点图矩阵看到了数字变量如何与房屋销售价格相关联。我们使用<kbd class="calibre12">seaborn</kbd>库中的<kbd class="calibre12">regplot()</kbd>函数生成了散点图矩阵。注意，我们使用了一个参数<kbd class="calibre12">fit_reg=False</kbd>，从散点图中移除回归线。</p>
<p class="calibre2">在<em class="calibre13">第 9 步</em>中，我们重复了<em class="calibre13">第 8 步</em>，以数字格式查看数字变量与房屋销售价格的关系，而不是散点图。我们还通过向<kbd class="calibre12">corr()</kbd>函数传递一个<kbd class="calibre12">[::-1]</kbd>参数来对输出进行降序排序。</p>
<p class="calibre2">还有更多...</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>There's more...</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">我们已经看到了几种探索数据的方法，既有统计的，也有视觉的。Python 中有相当多的库可以用来可视化数据。其中最广泛使用的是<kbd class="calibre12">ggplot</kbd>。在我们看几个命令之前，让我们学习一下<kbd class="calibre12">ggplot</kbd>是如何工作的。</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre12">ggplot</kbd>中有七层语法元素，其中前三层是必须的:</p>
<p class="calibre2">数据</p>
<ul class="calibre10">
<li class="calibre11">美学</li>
<li class="calibre11">几何学图形</li>
<li class="calibre11">面状</li>
<li class="calibre11">统计数字</li>
<li class="calibre11">协调</li>
<li class="calibre11">主题</li>
<li class="calibre11">您通常会从向<kbd class="calibre12">ggplot()</kbd>提供数据集开始。然后，使用<kbd class="calibre12">aes()</kbd>函数提供一个美学映射，将变量映射到<em class="calibre13"> x </em>和<em class="calibre13"> y </em>轴。使用<kbd class="calibre12">aes()</kbd>，您还可以设置图表的颜色、大小、形状和位置。然后，使用<kbd class="calibre12">geom_point()</kbd>或<kbd class="calibre12">geom_histogram()</kbd>等功能添加所需的几何形状类型。您还可以添加各种选项，如绘制统计汇总、刻面、视觉主题和坐标系。</li>
</ul>
<p class="calibre2">以下代码是我们在本章中已经使用的代码的扩展，因此我们将在这里直接深入研究<kbd class="calibre12">ggplot</kbd>代码:</p>
<p class="calibre2">前面的代码生成了下面的图表:</p>
<pre class="calibre15">f = pd.melt(housepricesdata, id_vars=['SalePrice'],value_vars= numerical_features[0:9])<br class="title-page-name"/>ggplot(f,aes('value', 'SalePrice')) + geom_point(color='orange') + facet_wrap('variable',scales='free')</pre>
<p class="calibre2"><img class="aligncenter21" src="img/33685075-4116-479c-9e26-f86291e74187.png"/></p>
<p class="CDPAlignCenter">类似地，为了查看数字变量的密度图，我们可以执行以下代码:</p>
<p class="calibre2">该图显示了每个数值变量的单变量密度图。<kbd class="calibre12">geom_density()</kbd>计算并绘制内核密度估计值，这是直方图的平滑版本:</p>
<pre class="calibre15">f_1 = pd.melt(housepricesdata, value_vars=numerical_features[0:9])<br class="title-page-name"/>ggplot(f_1, aes('value')) + geom_density(color="red") + facet_wrap('variable',scales='free') </pre>
<p class="calibre2"><img class="aligncenter22" src="img/77c12994-1627-466f-a8f9-e17432430292.png"/></p>
<p class="CDPAlignCenter">请参见</p>


            

            
        
    </body>

</html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>See also</title>
    <meta content="urn:uuid:64b74aae-7be0-4e73-89f3-687dd4470606" name="Adept.expected.resource"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body class="calibre">
        

                            
                    <h1 class="header-title">图书馆指南(<a href="https://bit.ly/2iU2aRU" class="calibre9">https://bit.ly/2iU2aRU</a>)</h1>
                
            
            
                
<div><p class="calibre2">The guide to the <kbd class="calibre12">seaborn</kbd> library (<a href="https://bit.ly/2iU2aRU" class="calibre9">https://bit.ly/2iU2aRU</a>) </p>
</div>


            

            
        
    </body>

</html>
</body></html>