<html><head/><body>


    
        <title>Classification Model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">分类模型</h1>
                
            
            
                
<p>回归模型已经过去，现在是时候深入分类模型了。在这一章中，我们将研究分类模型背后的数学，以及分类模型的各种应用。此外，我们将构建两个新的 ML.NET 分类应用程序:第一个，一个二元分类示例，它将预测汽车的价格是否划算，类似于您在汽车购买网站上找到的内容；另一个应用程序，一个多类分类应用程序，对电子邮件进行分类。最后，我们将探索如何用 model 在分类模型中揭示的属性来评估分类模型。</p>
<p>在本章中，我们将讨论以下主题:</p>
<ul>
<li>打破分类模式</li>
<li>创建二元分类应用程序</li>
<li>创建多类分类应用程序</li>
<li>评估分类模型</li>
</ul>


            

            
        
    






    
        <title>Breaking down classification models</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">打破分类模式</h1>
                
            
            
                
<p>正如在<a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">第一章</a>、<em>机器学习入门和 ML.NET</em>中提到的，分类分为两个主要类别——两类和多类。在两类分类器(也称为二元分类器)中，预测只返回 0 或 1。在多类问题中，返回预先选择的返回标签范围，如病毒类型或汽车类型。</p>
<p>机器学习生态系统中有几种二进制分类模型类型可供选择，如下所示:</p>
<ul>
<li><kbd>AveragedPerceptronTrainer</kbd></li>
<li><kbd>SdcaLogisticRegressionBinaryTrainer</kbd></li>
<li><kbd>SdcaNonCalibratedBinaryTrainer</kbd></li>
</ul>
<ul>
<li><kbd>SymbolicSgdLogisticRegressionBinaryTrainer</kbd></li>
<li><kbd>LbfgsLogisticRegressionBinaryTrainer</kbd></li>
<li><kbd>LightGbmBinaryTrainer</kbd></li>
<li><kbd>FastTreeBinaryTrainer</kbd></li>
<li><kbd>FastForestBinaryTrainer</kbd></li>
<li><kbd>GamBinaryTrainer</kbd></li>
<li><kbd>FieldAwareFactorizationMachineTrainer</kbd></li>
<li><kbd>PriorTrainer</kbd></li>
<li><kbd>LinearSvmTrainer</kbd></li>
</ul>
<p>我们将在本章后面创建的汽车价值应用程序利用了<kbd>FastTreeBinaryTrainer</kbd>模型。</p>
<p>ML.NET 还提供了以下多类分类器:</p>
<ul>
<li><kbd>LightGbmMulticlassTrainer</kbd></li>
<li><kbd>SdcaMaximumEntropyMulticlassTrainer</kbd></li>
<li><kbd>SdcaNonCalibratedMulticlassTrainer</kbd></li>
<li><kbd>LbfgsMaximumEntropyMulticlassTrainer</kbd></li>
<li><kbd>NaiveBayesMulticlassTrainer</kbd></li>
<li><kbd>OneVersusAllTrainer</kbd></li>
<li><kbd>PairwiseCouplingTrainer</kbd></li>
</ul>
<p>对于多类分类器示例应用程序，我们将使用<kbd>SdcaMaximumEntropyMulticlassTrainer</kbd>模型。其原因是<strong>随机对偶坐标上升</strong> ( <strong> SDCAs </strong>)可以在不调整的情况下提供良好的默认性能。</p>


            

            
        
    






    
        <title>Choosing a classification trainer</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">选择分类培训师</h1>
                
            
            
                
<p>给定两种分类，你应该选择哪一种？如本章前面所述，与回归模型相比，您的预测输出类型将在二元分类和多类分类之间做出决定。您的问题是简单地预测值的真或假，还是基于预定义的值集提供更多样的输出？如果你的答案是前者，你需要使用二元分类法。如果是后者，您将需要使用多类分类。在本章中，我们将演示这两种模型预测类型。</p>
<p>对于特定的二元分类训练器，SDCA、LightGBM 和 FastTree 是最受欢迎的选项，也是记录最多的。</p>
<p>对于特定的多级分类训练器，LightGBM 和 SDCA 是最受欢迎和记录最好的选项。</p>


            

            
        
    






    
        <title>Creating a binary classification application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">创建二元分类应用程序</h1>
                
            
            
                
<p>如前所述，我们将创建的应用程序是一个汽车价值预测器。给定一组与汽车相关的属性，人们可以预测价格是否划算。本例中包含的属性不是属性的最终列表，也不应该在生产环境中按原样使用。然而，我们可以以此为起点，根据几个属性来预测一个简单的对错答案。</p>
<p>和前面的章节一样，完整的项目代码、样本数据集和项目文件可以在这里下载:<a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04">https://github . com/packt publishing/Hands-On-Machine-Learning-With-ML。网/树/主/第 04 章</a>。</p>


            

            
        
    






    
        <title>Diving into the trainer</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">潜入教练</h1>
                
            
            
                
<p>如前所述，对于这个二进制分类应用程序，我们将使用快速树训练器。</p>
<p>FastTree 基于<strong>多重可加回归树</strong> ( <strong>集市</strong>)梯度推进算法。梯度推进是一种非常流行的技术，在最终选择最佳树之前，以逐步的方式构建一系列树。MART 将这种方法向前推进了一步，它学习了在叶子中使用标量值的回归树的集合。</p>
<p>快速树训练器不要求标准化，但要求所有特征列使用<kbd>float</kbd>变量类型，标签列为<kbd>bool</kbd>变量类型。</p>
<p>如果你对玛特感兴趣，康奈尔大学有一篇 2015 年关于这个主题的论文:<a href="https://arxiv.org/abs/1505.01866.">https://arxiv.org/abs/1505.01866</a>。<a href="https://arxiv.org/abs/1505.01866."/></p>


            

            
        
    






    
        <title>Exploring the project architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索项目架构</h1>
                
            
            
                
<p>基于我们在<a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">第三章</a>、<em>回归模型</em>中创建的项目架构和代码，本例中架构上的主要变化是输入机制。对于这个应用程序，由于我们使用 FastTree 算法，这需要引用<kbd>Microsoft.ML.FastTree</kbd> NuGet 包(在撰写本文时，版本 1.3.1 是最新的)。<strong> </strong>如果您正在从头开始构建这个项目，并且不记得如何添加一个 NuGet 引用，请参考第 2 章<a href="b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml"/>，<em>设置 ML.NET 环境</em>。</p>
<p>在下面的屏幕截图中，您将找到该项目的 Visual Studio 解决方案资源管理器视图。该解决方案的新增内容是<kbd>testdata.csv</kbd>文件，我们将在这里查看:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/68e93a35-367b-4d5d-a63d-6e0dad029632.png" style="width:22.00em;height:30.58em;"/></p>
<p><kbd>sampledata.csv</kbd>文件包含 18 行随机数据。请随意调整数据以适应您自己的观察或调整训练好的模型。以下是数据片段:</p>
<div><pre>0,0,0,4000,0<br/>1,1,1,4500,1<br/>0,1,0,5000,0<br/>0,0,1,4500,0<br/>0,0,0,3000,1<br/>0,1,0,3100,1<br/>0,1,1,3500,1<br/>1,1,1,5500,0<br/>1,1,1,4200,1</pre></div>
<p>这些行中的每一行都包含了新创建的<kbd>CarInventory</kbd>类中的属性值，我们将在本章的后面进行回顾。</p>
<p>此外，在本章中，我们添加了包含额外数据点的<kbd>testdata.csv</kbd>文件，以测试新训练的模型并对其进行评估。下面是<kbd>testdata.csv</kbd>中的一段数据:</p>
<pre>0,0,0,2010,1<br/>1,0,0,2600,1<br/>1,0,0,3700,0<br/>1,1,0,3100,1<br/>1,1,0,3600,0<br/>0,1,0,3500,0<br/>0,0,1,3400,1<br/>0,0,1,5100,0</pre>


            

            
        
    






    
        <title>Diving into the code</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">钻研代码</h1>
                
            
            
                
<p>对于这个应用程序，如前一节所述，我们在第三章、<em>中完成的工作基础上构建回归模型</em>。在这次深入探讨中，我们将只关注针对该应用程序更改的代码。</p>
<p>更改或添加的类如下:</p>
<ul>
<li><kbd>CarInventory</kbd></li>
<li><kbd>CarInventoryPrediction</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            

            
        
    






    
        <title>The CarInventory class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">CarInventory 类</h1>
                
            
            
                
<p><kbd>CarInventory</kbd>类是容器类，包含预测和训练我们模型的数据。这些列按照之前查看的样本数据的顺序进行映射。如果开始尝试新功能并添加到以下类中，请确保适当增加数组索引，如下所示:</p>
<div><pre>using Microsoft.ML.Data;<br/><br/>namespace chapter04.ML.Objects<br/>{<br/>    public class CarInventory<br/>    {<br/>        [LoadColumn(0)]<br/>        public float HasSunroof { get; set; }<br/><br/>        [LoadColumn(1)]<br/>        public float HasAC { get; set; }<br/><br/>        [LoadColumn(2)]<br/>        public float HasAutomaticTransmission { get; set; }<br/><br/>        [LoadColumn(3)]<br/>        public float Amount { get; set; }<br/><br/>        [LoadColumn(4)]<br/>        public bool Label { get; set; }<br/>    }<br/>}</pre></div>


            

            
        
    






    
        <title>The CarInventoryPrediction class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">CarInventoryPrediction 类</h1>
                
            
            
                
<p>除了用于模型评估的<kbd>Score</kbd>和<kbd>Probability</kbd>属性之外，<kbd>CarInventoryPrediction</kbd>类包含映射到我们的预测输出的属性。<kbd>PredictedLabel</kbd>属性包含我们的分类结果，而不是前面章节中的标签，如下面的代码块所示:</p>
<div><pre>namespace chapter04.ML.Objects<br/>{<br/>    public class CarInventoryPrediction<br/>    {<br/>        public bool Label { get; set; }<br/><br/>        public bool PredictedLabel { get; set; }<br/><br/>        public float Score { get; set; }<br/><br/>        public float Probability { get; set; }<br/>    }<br/>}</pre></div>


            

            
        
    






    
        <title>The Predictor class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">预测器类</h1>
                
            
            
                
<p>为了处理就业预测场景，该类中有一些变化，如下所示:</p>
<ol>
<li>第一个变化是预测调用本身。正如您可能猜到的那样，<kbd>TSrc</kbd>和<kbd>TDst</kbd>参数需要调整以利用我们创建的两个新类，<kbd>CarInventory</kbd>和<kbd>CarInventoryPrediction</kbd>，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;CarInventory, CarInventoryPrediction&gt;(mlModel);            </pre></div>
<ol start="2">
<li>鉴于我们不再简单地传入字符串并动态构建一个对象，我们需要首先以文本形式读入文件。然后我们将 JSON 反序列化成我们的<kbd>CarInventory</kbd> <strong> </strong>对象，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var prediction = predictionEngine.Predict(JsonConvert.DeserializeObject&lt;CarInventory&gt;(json));</pre></div>
<ol start="3">
<li>最后，我们需要调整预测的输出，以匹配新的<kbd>CarInventoryPrediction</kbd> <strong> </strong>属性，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">Console.WriteLine(<br/>    $"Based on input json:{System.Environment.NewLine}" +<br/>    $"{json}{System.Environment.NewLine}" + <br/>    $"The car price is a {(prediction.PredictedLabel ? "good" : "bad")} deal, with a {prediction.Probability:P0} confidence");</pre></div>


            

            
        
    






    
        <title>The Trainer class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">培训师课程</h1>
                
            
            
                
<p>在<kbd>Trainer</kbd>类中，需要进行一些修改来支持二进制分类，如下所示:</p>
<ol>
<li>第一个变化是检查以确保测试文件名存在，如下面的代码块所示:</li>
</ol>
<div><pre style="padding-left: 60px">if (!File.Exists(testFileName))<br/>{<br/>    Console.WriteLine($"Failed to find test data file ({testFileName}");<br/>    <br/>    return;<br/>}</pre></div>
<ol start="2">
<li>然后，我们使用在第三章、<em>回归模型</em>、<strong>、</strong>中使用的<kbd>NormalizeMeanVariance</kbd>转换方法对输入值构建数据处理管道，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">IEstimator&lt;ITransformer&gt; dataProcessPipeline = MlContext.Transforms.Concatenate("Features",<br/> typeof(CarInventory).ToPropertyList&lt;CarInventory&gt;(nameof(CarInventory.Label)))<br/> .Append(MlContext.Transforms.NormalizeMeanVariance(inputColumnName: "Features",<br/> outputColumnName: "FeaturesNormalizedByMeanVar"));</pre></div>
<ol start="3">
<li>然后，我们可以使用来自<kbd>CarInventory</kbd>类的标签和标准化的均值方差创建<kbd>FastTree</kbd>训练器，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var trainer = MlContext.BinaryClassification.Trainers.FastTree(<br/>    labelColumnName: nameof(CarInventory.Label),<br/>    featureColumnName: "FeaturesNormalizedByMeanVar",<br/>    numberOfLeaves: 2,<br/>    numberOfTrees: 1000,<br/>    minimumExampleCountPerLeaf: 1,<br/>    learningRate: 0.2);</pre></div>
<p>稍后，在您运行应用程序之后，考虑调整树叶的数量和树的数量，以查看模型指标和您的预测概率百分比如何变化。</p>
<ol start="4">
<li>最后，我们调用<kbd>Regression.Evaluate</kbd>方法来提供特定于回归的指标，然后调用<kbd>Console.WriteLine</kbd>将这些指标提供给控制台输出。我们将在本章的最后一节详细讨论这些代码的含义，但是现在，可以在这里看到代码:</li>
</ol>
<pre style="padding-left: 60px">var trainingPipeline = dataProcessPipeline.Append(trainer);<br/><br/>var trainedModel = trainingPipeline.Fit(trainingDataView);<br/><br/>MlContext.Model.Save(trainedModel, trainingDataView.Schema, ModelPath);</pre>
<p style="padding-left: 60px">现在，我们评估刚刚训练的模型，就像这样:</p>
<pre style="padding-left: 60px">var evaluationPipeline = trainedModel.Append(MlContext.Transforms<br/> .CalculateFeatureContribution(trainedModel.LastTransformer)<br/> .Fit(dataProcessPipeline.Fit(trainingDataView).Transform(trainingDataView)));<br/><br/>var testDataView = MlContext.Data.LoadFromTextFile&lt;CarInventory&gt;(testFileName, ',', hasHeader: false);<br/><br/>var testSetTransform = evaluationPipeline.Transform(testDataView);<br/><br/>var modelMetrics = MlContext.BinaryClassification.Evaluate(data: testSetTransform,<br/> labelColumnName: nameof(CarInventory.Label),<br/> scoreColumnName: "Score");</pre>
<p style="padding-left: 60px">最后，我们输出所有的分类指标。我们将在下一节详细介绍每一项，但是现在，可以在这里看到代码:</p>
<pre style="padding-left: 60px">Console.WriteLine($"Accuracy: {modelMetrics.Accuracy:P2}");<br/>Console.WriteLine($"Area Under Curve: {modelMetrics.AreaUnderRocCurve:P2}");<br/>Console.WriteLine($"Area under Precision recall Curve: {modelMetrics.AreaUnderPrecisionRecallCurve:P2}");<br/>Console.WriteLine($"F1Score: {modelMetrics.F1Score:P2}");<br/>Console.WriteLine($"LogLoss: {modelMetrics.LogLoss:#.##}");<br/>Console.WriteLine($"LogLossReduction: {modelMetrics.LogLossReduction:#.##}");<br/>Console.WriteLine($"PositivePrecision: {modelMetrics.PositivePrecision:#.##}");<br/>Console.WriteLine($"PositiveRecall: {modelMetrics.PositiveRecall:#.##}");<br/>Console.WriteLine($"NegativePrecision: {modelMetrics.NegativePrecision:#.##}");<br/>Console.WriteLine($"NegativeRecall: {modelMetrics.NegativeRecall:P2}");</pre>


            

            
        
    






    
        <title>The Program class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">程序类</h1>
                
            
            
                
<p>在<kbd>Program</kbd>类中唯一的变化是帮助文本，指示训练者接受测试文件的用法，如下面的代码块所示:</p>
<pre>if (args.Length &lt; 2)<br/>{<br/>    Console.WriteLine($"Invalid arguments passed in, exiting.{Environment.NewLine}        {Environment.NewLine}Usage:{Environment.NewLine}" +<br/> $"predict &lt;path to input json file&gt;{Environment.NewLine}" +<br/> $"or {Environment.NewLine}" +<br/> $"train &lt;path to training data file&gt; &lt;path to test data file&gt;{Environment.NewLine}");<br/><br/>    return;<br/>}</pre>
<p>最后，我们修改<kbd>switch</kbd> / <kbd>case</kbd>语句来支持<kbd>Train</kbd>方法的附加参数，如下所示:</p>
<pre>switch (args[0])<br/>{<br/>    case "predict":<br/>        new Predictor().Predict(args[1]);<br/>        break;<br/>    case "train":<br/>        new Trainer().Train(args[1], args[2]);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"{args[0]} is an invalid option");<br/>        break;<br/>}</pre>


            

            
        
    






    
        <title>Running the application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">运行应用程序</h1>
                
            
            
                
<p>为了运行该应用程序，该过程与第 3 章、<em>回归模型</em>中的示例应用程序几乎相同，除了在训练时传递测试数据集之外，描述如下:</p>
<ol>
<li>要在命令行上运行训练，正如我们在<a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">第 1 章</a>、<em>机器学习入门和 ML.NET</em>中所做的那样，我们只需传入以下命令(假设您正在使用包含的样本数据集和测试数据集):</li>
</ol>
<div><pre style="padding-left: 60px"><strong>PS chapter04\bin\Debug\netcoreapp3.0&gt; .\chapter04.exe train ..\..\..\Data\sampledata.csv ..\..\..\Data\testdata.csv</strong><br/>Accuracy: 88.89%<br/>Area Under Curve: 100.00%<br/>Area under Precision recall Curve: 100.00%<br/>F1Score: 87.50%<br/>LogLoss: 2.19<br/>LogLossReduction: -1.19<br/>PositivePrecision: 1<br/>PositiveRecall: .78<br/>NegativePrecision: .82<br/>NegativeRecall: 100.00%</pre></div>
<p style="padding-left: 60px">请注意扩展后的输出包括了几个度量数据点——我们将在本章的最后讨论每个数据点的含义。</p>
<ol start="2">
<li>训练完模型后，构建一个样本 JSON 文件，并将其保存为<kbd>input.json</kbd>，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">{<br/>    "HasSunroof":0,<br/>    "HasAC":0,<br/>    "HasAutomaticTransmission":0,<br/>    "Amount":1300<br/>}</pre></div>
<ol start="3">
<li>要使用该文件运行模型，只需将文件名传递给构建的应用程序，就会出现预测的输出，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px"><strong>PS chapter04\bin\Debug\netcoreapp3.0&gt; .\chapter04.exe predict .\input.json</strong><br/>Based on input json:<br/>{<br/>"HasSunroof":0,"HasAC":0,"HasAutomaticTransmission":0,"Amount":1300<br/>}<br/>The car price is a good deal, with a 100% confidence</pre></div>
<p style="padding-left: 60px">您可以随意修改这些值，并查看预测如何基于模型所基于的数据集而发生变化。从这一点来看，一些实验领域可能如下:</p>
<ul>
<li style="padding-left: 60px">根据您自己的购车体验添加一些附加功能</li>
<li style="padding-left: 60px">修改<kbd>sampledata.csv</kbd>文件以包含您自己的购车经历</li>
<li style="padding-left: 60px">修改示例应用程序，使其具有一个<strong>图形用户界面</strong> ( <strong> GUI </strong>)，从而使运行预测更加容易</li>
</ul>


            

            
        
    






    
        <title>Creating a multi-class classification application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">创建多类分类应用程序</h1>
                
            
            
                
<p>如前所述，我们现在将创建一个多类分类应用程序，将电子邮件分为三类:</p>
<ul>
<li>命令</li>
<li>罐头猪肉</li>
<li>朋友</li>
</ul>
<p>为生产应用程序清除这个示例，除了更多的特性之外，很可能会包含更多的类别。然而，这是演示多类分类用例的良好起点。</p>
<p>与其他示例一样，完整的项目代码、样本数据集和项目文件可以从这里下载:<a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter04-multiclass">https://github . com/packt publishing/Hands-On-Machine-Learning-With-ML。NET/tree/master/chapter 04-multi class</a>。</p>


            

            
        
    






    
        <title>Diving into the trainer</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">潜入教练</h1>
                
            
            
                
<p>如前所述，对于这个多级分类应用，我们将使用<kbd>SdcaMaximumEntropy</kbd>训练器。</p>
<p><kbd>SdcaMaximumEntropy</kbd>类，顾名思义，基于我们在<a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">第三章</a>、<em>回归模型</em>中深入钻研的 SDCA，使用经验风险最小化，基于训练数据进行优化。这确实为异常值或异常留下了极大影响预测性能的可能性。因此，在使用此训练器时，为训练器提供预期数据的充足样本，以避免预测数据时的过度拟合和潜在错误。</p>
<p>与前面的二元分类例子不同，<kbd>SdcaMaximumEntropy</kbd>训练器确实需要归一化。另外，不需要缓存；然而，我们在构建管道时确实利用了缓存。</p>


            

            
        
    






    
        <title>Exploring the project architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索项目架构</h1>
                
            
            
                
<p>基于本章前面创建的项目架构和代码，这个项目中没有新的 NuGet 包，因为 SDCA 培训师被认为是核心培训师。主要的变化是在<kbd>Training</kbd>管道中，我们将在本节的后面更详细地讨论它。</p>
<p>在下面的屏幕截图中，您将看到该项目的 Visual Studio 解决方案资源管理器视图:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7df2ac8b-d10d-460b-9d8a-5cfde49e58b6.png" style="width:19.42em;height:24.83em;"/></p>
<p><kbd>sampledata.csv</kbd>文件包含六行随机数据。请随意调整数据以适应您自己的观察或调整训练好的模型。以下是数据片段:</p>
<div><pre>"Order #1234","Thank you for ordering a new CPU","order@cpulandia.com","orders"<br/>"Get Free Free","Click here for everything free","freefree@asasdasd.com","spam"<br/>"Checking in","How is it going?","johndough@gmail.com","friend"<br/>"Order 4444","Thank you for ordering a pizza","order@pizzalandia.com","orders"<br/>"Unlock Free","Click here to unlock your spam","spammer@asasdasd.com","spam"<br/>"Hello","Did you see my last message?","janedough@gmail.com","friend"</pre></div>
<p>这些行中的每一行都包含了新创建的<kbd>Email</kbd>类中的属性值，我们将在本章的后面进行回顾。</p>
<p>此外，在本章中，我们添加了包含额外数据点的<kbd>testdata.csv</kbd>文件，用于测试新训练的模型。以下是数据片段:</p>
<pre>"Order 955","Thank you for ordering a new gpu","order@gpulandia.com","orders"<br/>"Win Free Money","Lottery winner, click here","nowfree@asasdasd.com","spam"<br/>"Yo","Hey man?","john@gmail.com","friend"</pre>


            

            
        
    






    
        <title>Diving into the code</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">钻研代码</h1>
                
            
            
                
<p>对于这个应用程序，如前所述，我们在第三章、<em>中完成的工作基础上构建回归模型</em>。在这次深入探讨中，我们将只关注针对该应用程序更改的代码。</p>
<p>更改或添加的类如下:</p>
<ul>
<li><kbd>Email</kbd></li>
<li><kbd>EmailPrediction</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            

            
        
    






    
        <title>The Email class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">电子邮件类</h1>
                
            
            
                
<p><kbd>Email</kbd>类是容器类，包含预测和训练我们模型的数据。这些列按顺序映射到前面查看的样本数据。如果您开始尝试新功能并添加到此列表中，请确保适当增加数组索引，如下面的代码块所示:</p>
<div><pre>using Microsoft.ML.Data;<br/><br/>namespace chapter04_multiclass.ML.Objects<br/>{<br/>    public class Email<br/>    {<br/>        [LoadColumn(0)]<br/>        public string Subject { get; set; }<br/><br/>        [LoadColumn(1)]<br/>        public string Body { get; set; }<br/><br/>        [LoadColumn(2)]<br/>        public string Sender { get; set; }<br/><br/>        [LoadColumn(3)]<br/>        public string Category { get; set; }<br/>    }<br/>}</pre></div>


            

            
        
    






    
        <title>The EmailPrediction class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">EmailPrediction 类</h1>
                
            
            
                
<p><kbd>EmailPrediction</kbd>类包含映射到用于模型评估的预测输出的属性。在下面的代码块中，我们将返回<kbd>Category</kbd>值(字符串值):</p>
<div><pre>using Microsoft.ML.Data;<br/><br/>namespace chapter04_multiclass.ML.Objects<br/>{<br/>    public class EmalPrediction<br/>    {<br/>        [ColumnName("PredictedLabel")]<br/>        public string Category;<br/>    }<br/>}</pre></div>


            

            
        
    






    
        <title>The Predictor class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">预测器类</h1>
                
            
            
                
<p>该类中有几处更改可以处理电子邮件分类预测场景，如下所示:</p>
<ol>
<li>第一个变化是预测调用本身。正如您可能猜到的那样，<kbd>TSrc</kbd>和<kbd>TDst</kbd>参数需要调整以利用我们创建的两个新类<kbd>Email</kbd>和<kbd>EmailPrediction</kbd>，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;Email, EmailPrediction&gt;(mlModel);            </pre></div>
<ol start="2">
<li>鉴于我们不再简单地传入字符串并动态构建一个对象，我们需要首先以文本形式读入文件。然后我们将 JSON 反序列化成我们的<kbd>Email</kbd> <strong> </strong>对象，就像这样:</li>
</ol>
<div><pre style="padding-left: 60px">var prediction = predictionEngine.Predict(JsonConvert.DeserializeObject&lt;Email&gt;(json));</pre></div>
<ol start="3">
<li>最后，我们需要调整预测的输出，以匹配新的<kbd>EmailPrediction</kbd> <strong> </strong>属性，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">Console.WriteLine(<br/>    $"Based on input json:{System.Environment.NewLine}" +<br/>    $"{json}{System.Environment.NewLine}" + <br/>    $"The email is predicted to be a {prediction.Category}");</pre></div>


            

            
        
    






    
        <title>The Trainer class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">培训师课程</h1>
                
            
            
                
<p>该类中有几处更改可以处理电子邮件分类预测场景，如下所示:</p>
<ol>
<li>首先，我们读入<kbd>trainingFileName</kbd>字符串并将其类型转换为<kbd>Email</kbd>对象，如下所示:</li>
</ol>
<div><pre>var trainingDataView = MlContext.Data.LoadFromTextFile&lt;Email&gt;(trainingFileName, ',', hasHeader: false);           </pre></div>
<ol start="2">
<li>接下来，在追加 SDCA 训练器之前，我们将创建将输入属性映射到<kbd>FeaturizeText</kbd>转换的管道，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var dataProcessPipeline = MlContext.Transforms.Conversion.MapValueToKey(inputColumnName: nameof(Email.Category), outputColumnName: "Label")<br/>    .Append(MlContext.Transforms.Text.FeaturizeText(inputColumnName: nameof(Email.Subject), outputColumnName: "SubjectFeaturized"))<br/>    .Append(MlContext.Transforms.Text.FeaturizeText(inputColumnName: nameof(Email.Body), outputColumnName: "BodyFeaturized"))<br/>    .Append(MlContext.Transforms.Text.FeaturizeText(inputColumnName: nameof(Email.Sender), outputColumnName: "SenderFeaturized"))<br/>    .Append(MlContext.Transforms.Concatenate("Features", "SubjectFeaturized", "BodyFeaturized", "SenderFeaturized"))<br/>    .AppendCacheCheckpoint(MlContext);<br/><br/>var trainingPipeline = dataProcessPipeline<br/>    .Append(MlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy("Label", "Features"))<br/>    .Append(MlContext.Transforms.Conversion.MapKeyToValue("PredictedLabel"));</pre></div>
<ol start="3">
<li>最后，我们加载测试数据，运行<kbd>MultiClassClassification</kbd>评估，然后输出四个模型评估属性，如下所示:</li>
</ol>
<div><pre style="padding-left: 60px">var testDataView = MlContext.Data.LoadFromTextFile&lt;Email&gt;(testFileName, ',', hasHeader: false);<br/><br/>var modelMetrics = MlContext.MulticlassClassification.Evaluate(trainedModel.Transform(testDataView));<br/><br/>Console.WriteLine($"MicroAccuracy: {modelMetrics.MicroAccuracy:0.###}");<br/>Console.WriteLine($"MacroAccuracy: {modelMetrics.MacroAccuracy:0.###}");<br/>Console.WriteLine($"LogLoss: {modelMetrics.LogLoss:#.###}");<br/>Console.WriteLine($"LogLossReduction: {modelMetrics.LogLossReduction:#.###}");</pre></div>


            

            
        
    






    
        <title>Running the application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">运行应用程序</h1>
                
            
            
                
<div><p>要运行该应用程序，流程与第 3 章、<em>回归模型</em>中的示例应用程序几乎相同，只是在训练时传递测试数据集:</p>
</div>
<ol>
<li>要像我们在<a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">第 1 章</a>、<em>机器学习入门和 ML.NET</em>中所做的那样在命令行上运行训练，只需传入以下命令(假设您使用的是附带的样本数据集和测试数据集):</li>
</ol>
<pre style="padding-left: 60px"><strong>PS chapter04-multiclass\bin\Debug\netcoreapp3.0&gt; .\chapter04-multiclass.exe train ..\..\..\Data\sampledata.csv ..\..\..\Data\testdata.csv</strong><br/>MicroAccuracy: 1<br/>MacroAccuracy: 1<br/>LogLoss: .1<br/>LogLossReduction: .856</pre>
<p style="padding-left: 60px">请注意扩展后的输出包括了几个度量数据点——我们将在本章的最后讨论每个数据点的含义。</p>
<ol start="2">
<li>训练完模型后，构建一个样本 JSON 文件，并将其保存为<kbd>input.json</kbd>，如下所示:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "Subject":"hello",<br/>    "Body":"how is it?",<br/>    "Sender":"joe@gmail.com"<br/>}</pre>
<ol start="3">
<li>要使用该文件运行模型，只需将文件名传递给构建的应用程序，预测的输出将如下所示:</li>
</ol>
<pre style="padding-left: 60px"><strong>PS chapter04-multiclass\bin\Debug\netcoreapp3.0&gt; .\chapter04-multiclass.exe predict .\input.json</strong><br/>Based on input json:<br/>{<br/>"Subject":"hello",<br/>"Body":"how is it?",<br/>"Sender":"joe@gmail.com"<br/>}<br/>The email is predicted to be a "friend"</pre>
<p style="padding-left: 60px">您可以随意修改这些值，并查看预测如何基于模型所基于的数据集而发生变化。从这一点来看，一些实验领域可能是:</p>
<ul>
<li style="padding-left: 60px">根据您自己的电子邮件添加更多样本和测试数据。</li>
<li style="padding-left: 60px">根据您自己的电子邮件添加更多类别。</li>
<li style="padding-left: 60px">扩展功能，如发送日期和发送者的 IP 地址。</li>
</ul>


            

            
        
    






    
        <title>Evaluating a classification model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">评估分类模型</h1>
                
            
            
                
<p>如前几章所述，评估模型是整个模型构建过程的关键部分。训练不足的模型只会提供不准确的预测。幸运的是，ML.NET 提供了许多流行的属性来计算模型准确性，这些属性基于训练时的测试集，让您了解您的模型在生产环境中的表现。</p>
<p>在 ML.NET 中，正如前面在示例应用程序中提到的，有几个属性组成了<kbd>CalibratedBinaryClassificationMetrics</kbd>类对象。在<a href="b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml">第 2 章</a>、<em>设置 ML.NET 环境</em>中，我们回顾了其中的一些属性。然而，现在我们有了一个更复杂的例子，并了解了如何评估回归模型，让我们深入了解以下属性:</p>
<ul>
<li>准确(性)</li>
<li>ROC 曲线下面积</li>
<li>F1 分数</li>
<li>精确召回曲线下面积</li>
</ul>
<p>此外，我们还将查看由多类分类应用程序中使用的<kbd>MulticlassClassificationMetrics</kbd>对象返回的以下四个指标:</p>
<ul>
<li>微精度</li>
<li>宏观精度</li>
<li>原木损失</li>
<li>减少原木损失</li>
</ul>
<p>在接下来的部分中，我们将分解这些值是如何计算的，并详细说明要寻找的理想值。</p>


            

            
        
    






    
        <title>Accuracy</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">准确(性)</h1>
                
            
            
                
<p>准确性是测试数据集中正确预测与错误预测的比例。</p>
<p>您可能希望接近 100%的值，但不是 100%。正如在我们的二进制分类示例中看到的，我们获得了 88.89%—接近 100%，但并不完全如此。如果你在实验时看到 100%的分数，你很可能看到一个过度拟合的例子。</p>


            

            
        
    






    
        <title>Area Under ROC Curve</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">ROC 曲线下面积</h1>
                
            
            
                
<p>ROC 曲线下面积，通常也称为 AUC，是曲线下面积的度量。</p>
<p>与精确度一样，接近 100%的值是理想的。如果您看到的值小于 50%，则您的模型需要更多的特征和/或更多的训练数据。</p>


            

            
        
    






    
        <title>F1 Score</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">F1 分数</h1>
                
            
            
                
<p>F1 分数是精确度和召回率的调和平均值。</p>
<p>接近或等于 100%的值是优选的。值为 0 表示精度完全不准确。如我们的二元分类示例所示，我们获得了 87.50%。</p>


            

            
        
    






    
        <title>Area Under Precision-Recall Curve</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">精确召回曲线下面积</h1>
                
            
            
                
<p>精确召回曲线下的面积，通常也称为 AUPRC，是成功预测的度量。当数据集不平衡地归入一个分类时，应检查该值。</p>
<p>与 AUC 和准确性一样，接近 100%的值是首选的，因为这表明您的回忆率很高。如我们的二元分类示例所示，我们获得了 100%的 AUPRC 值。</p>


            

            
        
    






    
        <title>Micro Accuracy</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">微精度</h1>
                
            
            
                
<p>微精度评估每个样本类对对精度度量的贡献是否相等。</p>
<p>接近或等于 1 的值是优选的。如我们的样例应用程序和测试数据集所示，值为 1。</p>


            

            
        
    






    
        <title>Macro Accuracy</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">宏观精度</h1>
                
            
            
                
<p>宏精度评估每个类对对精度度量的贡献是否相等。</p>
<p>接近或等于 1 的值是优选的。如我们的样例应用程序和测试数据集所示，值为 1。</p>


            

            
        
    






    
        <title>Log Loss</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">原木损失</h1>
                
            
            
                
<p>对数损失是描述分类器准确性的评估度量。对数损失考虑了模型预测和实际分类之间的差异。</p>
<p>最好使用接近 0 的值，因为 0 值表示模型对测试集的预测是完美的。如我们的样例应用程序和测试数据集所示，获得了 0.1 的值。</p>


            

            
        
    






    
        <title>Log-Loss Reduction</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">减少原木损失</h1>
                
            
            
                
<p>与随机预测相比，对数损失减少只是一种描述分类器准确性的评估指标。</p>
<p>接近或等于 1 的值是首选值，因为随着该值接近 1，模型的相对精度会提高。如我们的示例应用程序和测试数据集所示，获得了 0.856 的值，这意味着猜测正确答案的概率是 85.6%。</p>


            

            
        
    






    
        <title>Summary</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">摘要</h1>
                
            
            
                
<p>在本章的过程中，我们深入研究了分类模型。我们还创建并训练了第一个二元分类应用程序，使用快速树和 ML.NET 来预测汽车的价格。我们还创建了第一个多类分类应用程序，使用 SDCA 训练器对电子邮件进行分类。最后，我们还深入探讨了如何评估一个分类模型，以及 model 揭示的各种属性，以实现对您的分类模型的正确评估。</p>
<p>在下一章，我们将深入研究 ML.NET 聚类算法，并创建一个文件类型的分类器。</p>


            

            
        
    


</body></html>