<html><head/><body>


    
        <title>Using ML.NET with .NET Core and Forecasting</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">利用 ML.NET。净核心和预测</h1>
                
            
            
                
<p>既然我们已经深入研究了 ML.NET 提供的各种算法，我们将在接下来的几章中开始探索如何将 ML.NET 集成到生产应用程序中。在这一章中，我们将深入探讨建立在前几章中定义的结构上的. NET 核心控制台应用程序，重点是强化和错误处理。我们将构建的应用程序使用预测来根据一系列趋势预测股票价格。在本章结束时，你应该已经牢牢掌握了设计和编写产品级的代码。NET 核心应用程序与 ML.NET。</p>
<p>在本章中，我们将讨论以下主题:</p>
<ul>
<li>分解。网络核心应用架构</li>
<li>创建预测应用程序</li>
<li>探索其他生产应用程序增强功能</li>
</ul>


            

            
        
    






    
        <title>Breaking down the .NET Core application architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">分解。网络核心应用架构</h1>
                
            
            
                
<p>如<a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">第一章</a>、【机器学习入门】和【ML.NET】、所述。由于在 3.0 版本中进行了优化，NET Core 3.x 是使用 ML.NET 的首选平台。此外，。NET Core 提供了一个针对 Linux、macOS 和 Windows 的单一编码框架，如下图所示:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-619 image-border" src="img/ea346e36-c0a4-4e3e-9056-f9501455b5e4.png" style="width:17.75em;height:8.75em;"/></p>


            

            
        
    






    
        <title>.NET Core architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">。网络核心架构</h1>
                
            
            
                
<p>自 2016 年成立以来，的基本目标是。NET Core 一直在提供快速更新和与微软(以前只有 Windows)对等的功能。NET 框架。随着时间和版本的推移，通过简单地添加缺失的 API，使用额外的 NuGet 包，差距已经变小。一个这样的例子是<kbd>Microsoft.Windows.Compatibility</kbd>，它提供了 20，000 个核心框架中没有的 API，包括注册表访问、绘图和 Windows 权限模型访问。这种方法保持了框架的轻量级和跨平台性，但是引入了一些设计模式来帮助您开发特定于平台的应用程序。</p>
<p>举个例子，一个 Windows 桌面应用程序使用 ML.NET 来提供一个<strong>入侵检测系统</strong> ( <strong> IDS </strong>)。一个简单的方法是在一个. NET Core<strong>Windows Presentation Foundation</strong>(<strong>WPF</strong>)应用程序中编写所有代码。然而，这只会把你束缚在 Windows 上，而不会进行大的重构。更好的方法是创建一个包含所有平台无关代码的. NET 核心类库，然后创建抽象类或接口来实现平台应用程序中特定于平台的代码。</p>


            

            
        
    






    
        <title>.NET Core targets</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">。净核心目标</h1>
                
            
            
                
<p>如前所述。NET Core 提供了一个针对 Windows、macOS 和 Linux 的单一框架。然而，这不仅仅适用于我们在本书中使用的控制台应用程序。最近的工作。NET Core 3 提供了移植现有内容的能力。NET 框架 WPF 和 Windows 窗体应用程序。NET Core 3，从而使依赖于可能已经过时的框架的应用程序能够使用最新的。净核心进展。此外，以前使用 ASP.NET 的 web 应用程序可以迁移到 ASP.NET 核心(ASP.NET web forms 目前没有迁移路径)。</p>
<p>的另一个好处。NET Core 目标是使用<kbd>--self-contained</kbd>标志进行编译的能力。这个标志编译您的应用程序或库，然后捆绑所有必要的。NET 核心框架文件。这使您可以在安装过程中部署应用程序，而无需具备. NET 先决条件。这确实会使您的总体构建输出更大，但是在客户场景中，大约 100MB 的增加远远超过了先决条件的部署障碍。</p>


            

            
        
    






    
        <title>.NET Core future</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">。净核心期货</h1>
                
            
            
                
<p>你可能想知道未来。NET 框架、Mono 和。网芯是。幸运的是，在撰写本文时，微软已经确认所有现有的框架都将被移植到一个名为。净 5。以前，在决定使用哪种框架时，一定要权衡利弊。因此，利用每个框架的优点并第一次将它们统一起来将完全消除这些权衡。举个例子，Mono 的<strong>超前</strong> ( <strong> AOT </strong>)编译或者 Xamarin 的跨平台 UI 支持，它们可以在现有的。NET Core 3.x 应用基于发布的信息。</p>
<p>的预览。NET 5 预计在 2020 年上半年发布，2020 年 11 月量产发布。</p>


            

            
        
    






    
        <title>Creating the stock price estimator application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">创建股票价格评估应用程序</h1>
                
            
            
                
<p>如前所述，我们将创建的应用程序是一个股票价格估计器。给定一组几天、几周或几年的股票价格，预测算法将在内部识别趋势模式。与前几章不同，该应用程序将被设计为插入到生产管道中。</p>
<p>与前面的章节一样，完整的项目代码、样本数据集和项目文件可以从:<a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter08">https://github . com/packt publishing/Hands-On-Machine-Learning-With-ML 下载。网/树/主/第 08 章</a>。</p>


            

            
        
    






    
        <title>Exploring the project architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索项目架构</h1>
                
            
            
                
<p>基于我们在前几章中创建的项目体系结构和代码，我们将在本章中探索的体系结构进一步增强了体系结构的结构化，从而对最终用户更有用。</p>
<p>与前面的一些章节一样，需要一个额外的 NuGet 包—<kbd>Microsoft.ML.TimeSeries</kbd>—来利用 ML.NET 中的预测功能。1.3.1 版在 GitHub 上的示例和本章的深入探讨中都有使用。</p>
<p>在下面的屏幕截图中，您将找到该项目的 Visual Studio 解决方案资源管理器视图。该解决方案新增了几项功能，以促进我们的目标生产用例。我们将在本章后面详细查看解决方案屏幕截图中显示的每个新文件:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-620 image-border" src="img/fa567181-ad7a-4d3d-b62c-265416c722f1.png" style="width:16.75em;height:32.08em;"/></p>
<p><kbd>sampledata.csv</kbd>文件包含 24 行股票价格。请随意调整数据以适应您自己的观察或调整训练好的模型。以下是数据片段:</p>
<div><pre>33<br/>34<br/>301<br/>33<br/>44<br/>299<br/>40<br/>50<br/>400<br/>60<br/>76<br/>500</pre></div>
<p>这些行中的每一行都包含我们将填充到一个<kbd>StockPrices</kbd>类对象中的股票价格值，我们将在本章的后面回顾这个类对象。</p>
<p>除此之外，我们添加了包含额外数据点的<kbd>testdata.csv</kbd>文件，以测试新训练的模型并对其进行评估。下面是<kbd>testdata.csv</kbd>中的一段数据:</p>
<pre>10<br/>25<br/>444<br/>9<br/>11<br/>333<br/>4<br/>3<br/>500</pre>


            

            
        
    






    
        <title>Diving into the code</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">钻研代码</h1>
                
            
            
                
<p>对于这个应用程序，如前一节所述，我们是在前面章节完成的工作的基础上构建的。但是，对于本章，我们将更改每个文件以支持生产使用情形。对于与前面章节不同的每个文件，我们将回顾所做的更改以及这些更改背后的原因。</p>
<p>更改或添加的类和枚举如下:</p>
<ul>
<li><kbd>ProgramActions</kbd></li>
<li><kbd>CommandLineParser</kbd></li>
<li><kbd>BaseML</kbd></li>
<li><kbd>StockPrediction</kbd></li>
<li><kbd>StockPrices</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>ProgramArguments</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            

            
        
    






    
        <title>The ProgramActions enumeration</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">程序枚举</h1>
                
            
            
                
<p>以下<kbd>ProgramActions</kbd>枚举已添加到解决方案中，以便于使用强类型和结构化路径来处理程序执行的各种操作:</p>
<pre>namespace chapter08.Enums<br/>{<br/>    public enum ProgramActions<br/>    {<br/>        TRAINING,<br/>        PREDICT<br/>    }<br/>}</pre>
<p>在这个应用程序中，我们只有两个动作— <kbd>Training</kbd>和<kbd>Predicting</kbd>。然而，如前几章所示，您可能还需要一个特征提取步骤，或者提供一个评估步骤。这种设计模式提供了灵活性，同时也消除了本章开始时提到的<strong>魔术串</strong>问题。</p>


            

            
        
    






    
        <title>The CommandLineParser class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">CommandLineParser 类</h1>
                
            
            
                
<p><kbd>CommandLineParser</kbd>类提供了一个与程序无关的解析器来处理命令行参数。在前面的章节中，我们手动解析索引并将这些值映射到参数。另一方面，这种方法创建了一个灵活、易于维护的结构化响应对象，将参数直接映射到属性。现在让我们深入课堂:</p>
<ol>
<li>首先，我们定义函数原型:</li>
</ol>
<div><pre style="padding-left: 60px">public static T ParseArguments&lt;T&gt;(string[] args) </pre>
<p style="padding-left: 60px">泛型的使用(即<kbd>T</kbd>)创造了一种灵活的方法，使这个方法不受这个应用程序的限制。</p>
</div>
<ol start="2">
<li>接下来，我们测试<kbd>null</kbd>参数:</li>
</ol>
<div><pre style="padding-left: 60px">if (args == null)<br/>{<br/>    throw new ArgumentNullException(nameof(args));<br/>}</pre></div>
<ol start="3">
<li>然后，我们测试空参数，让用户知道将使用缺省值而不是失败，如前几章所述:</li>
</ol>
<div><pre style="padding-left: 60px">if (args.Length == 0)<br/>{<br/>    Console.WriteLine("No arguments passed in - using defaults");<br/><br/>    return Activator.CreateInstance&lt;T&gt;();<br/>}</pre></div>
<ol start="4">
<li>在执行 null 和 empty 检查之后，我们接着执行两个检查的倍数，因为所有参数都是成对的:</li>
</ol>
<pre style="padding-left: 60px">if (args.Length % 2 != 0)<br/>{<br/>    throw new ArgumentException($"Arguments must be in pairs, there were {args.Length} passed in");<br/>}</pre>
<ol start="5">
<li>接着，我们使用<kbd>Activator.CreateInstance</kbd>方法创建一个<kbd>T</kbd> <strong> </strong>类型的对象:</li>
</ol>
<pre style="padding-left: 60px">var argumentObject = Activator.CreateInstance&lt;T&gt;();</pre>
<p style="padding-left: 60px">确保在创建类对象时，构造函数没有参数，否则该调用将引发异常。如果创建一个带有构造函数参数而没有无参数构造函数的对象，使用重载<kbd>Activator.CreateInstance</kbd>并传入所需的参数。</p>
<ol start="6">
<li>接下来，我们利用反射来获取<kbd>T</kbd>类型的所有属性:</li>
</ol>
<pre style="padding-left: 60px">var properties = argumentObject.GetType().GetProperties();</pre>
<ol start="7">
<li>现在我们已经创建了通用对象和该对象的属性，然后我们循环遍历每个参数键/值对，并在对象中设置属性:</li>
</ol>
<pre style="padding-left: 60px">for (var x = 0; x &lt; args.Length; x += 2)<br/>{<br/>    var property = properties.FirstOrDefault(a =&gt; a.Name.Equals(args[x], StringComparison.CurrentCultureIgnoreCase));<br/><br/>    if (property == null)<br/>    {<br/>        Console.WriteLine($"{args[x]} is an invalid argument");<br/><br/>        continue;<br/>    }<br/><br/>    if (property.PropertyType.IsEnum)<br/>    {<br/>        property.SetValue(argumentObject, Enum.Parse(property.PropertyType, args[x + 1], true));<br/>    }<br/>    else<br/>    {<br/>        property.SetValue(argumentObject, args[x + 1]);<br/>    }<br/>}</pre>
<p>请注意<kbd>IsEnum</kbd>函数处理我们之前提到的<kbd>ProgramActions</kbd>枚举的特殊情况。由于字符串值不能自动转换成枚举，我们需要专门用<kbd>Enum.Parse</kbd>方法处理字符串到枚举的转换。如前所述，如果向<kbd>T</kbd>类型添加更多枚举，枚举处理程序是通用的。</p>


            

            
        
    






    
        <title>The BaseML class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">BaseML 类</h1>
                
            
            
                
<p>这个应用程序的<kbd>BaseML</kbd>类已经简化为简单地实例化<kbd>MLContext</kbd>对象:</p>
<pre>using Microsoft.ML;<br/><br/>namespace chapter08.ML.Base<br/>{<br/>    public class BaseML<br/>    {<br/>        protected readonly MLContext MlContext;<br/><br/>        protected BaseML()<br/>        {<br/>            MlContext = new MLContext(2020);<br/>        }<br/>    }<br/>}</pre>


            

            
        
    






    
        <title>The StockPrediction class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">StockPrediction 类</h1>
                
            
            
                
<p><kbd>StockPrediction</kbd>类是我们预测值的容器，定义如下:</p>
<pre>namespace chapter08.ML.Objects<br/>{<br/>    public class StockPrediction<br/>    {<br/>        public float[] StockForecast { get; set; }<br/><br/>        public float[] LowerBound { get; set; }<br/><br/>        public float[] UpperBound { get; set; }<br/>    }<br/>}</pre>
<p><kbd>StockForecast</kbd>属性将保存我们基于模型训练预测的股票价值和提交给预测引擎的价值。<kbd>LowerBound</kbd>和<kbd>UpperBound</kbd>值分别保存最低和最高估计值。</p>


            

            
        
    






    
        <title>The StockPrices class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">股票价格类</h1>
                
            
            
                
<p><kbd>StockPrices</kbd>类包含我们保存股票价格的单个浮点值。为了在填充值时保持代码的整洁，添加了一个接受股票价格值的构造函数:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter08.ML.Objects<br/>{<br/>    public class StockPrices<br/>    {<br/>        [LoadColumn(0)]<br/>        public float StockPrice;<br/><br/>        public StockPrices(float stockPrice)<br/>        {<br/>            StockPrice = stockPrice;<br/>        }<br/>    }<br/>}</pre>


            

            
        
    






    
        <title>The Predictor class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">预测器类</h1>
                
            
            
                
<p>与前几章相比，<kbd>Predictor</kbd>类已经过简化和调整，以支持预测:</p>
<ol>
<li>首先，我们调整<kbd>Predict</kbd>方法来接受新定义的<kbd>ProgramArguments</kbd>类对象:</li>
</ol>
<div><pre style="padding-left: 60px">public void Predict(ProgramArguments arguments)   </pre></div>
<ol start="2">
<li>接下来，我们更新模型<kbd>file.Exists</kbd>检查以利用<kbd>arguments</kbd>对象:</li>
</ol>
<div><pre style="padding-left: 60px">if (!File.Exists(arguments.ModelFileName))<br/>{<br/>    Console.WriteLine($"Failed to find model at {arguments.ModelFileName}");<br/><br/>    return;<br/>}</pre></div>
<ol start="3">
<li>类似地，我们还将预测文件名引用更新为利用<kbd>arguments</kbd>对象:</li>
</ol>
<div><pre style="padding-left: 60px">if (!File.Exists(arguments.PredictionFileName))<br/>{<br/>    Console.WriteLine($"Failed to find input data at {arguments.PredictionFileName}");<br/><br/>    return;<br/>}</pre></div>
<ol start="4">
<li>接下来，我们还修改了模型打开调用，以利用<kbd>arguments</kbd>对象:</li>
</ol>
<pre style="padding-left: 60px">using (var stream = new FileStream(Path.Combine(AppContext.BaseDirectory, arguments.ModelFileName), FileMode.Open, FileAccess.Read, FileShare.Read))<br/>{<br/>    mlModel = MlContext.Model.Load(stream, out _);<br/>}</pre>
<ol start="5">
<li>然后我们用我们的<kbd>StockPrices</kbd>和<kbd>StockPrediction</kbd>类型创建时序引擎对象:</li>
</ol>
<pre style="padding-left: 60px">var predictionEngine = mlModel.CreateTimeSeriesEngine&lt;StockPrices, StockPrediction&gt;(MlContext);</pre>
<ol start="6">
<li>接下来，我们将股票价格预测文件读入一个字符串数组:</li>
</ol>
<pre style="padding-left: 60px">var stockPrices = File.ReadAllLines(arguments.PredictionFileName);</pre>
<ol start="7">
<li>最后，我们迭代每个输入，调用预测引擎，并显示估计值:</li>
</ol>
<pre style="padding-left: 60px">foreach (var stockPrice in stockPrices)<br/>{<br/>    var prediction = predictionEngine.Predict(new StockPrices(Convert.ToSingle(stockPrice)));<br/><br/>    Console.WriteLine($"Given a stock price of ${stockPrice}, the next 5 values are predicted to be: " +<br/>                      $"{string.Join(", ", prediction.StockForecast.Select(a =&gt; $"${Math.Round(a)}"))}");<br/>}</pre>


            

            
        
    






    
        <title>The Trainer class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">培训师课程</h1>
                
            
            
                
<p>类似于<kbd>Predictor</kbd>类的<kbd>Trainer</kbd>类接受了精简和修改，以考虑 ML.NET 预测算法:</p>
<ol>
<li>首先，更新函数原型以获取<kbd>ProgramArguments</kbd>对象:</li>
</ol>
<div><pre style="padding-left: 60px">public void Train(ProgramArguments arguments)     </pre></div>
<ol start="2">
<li>接下来，我们更新训练文件检查以利用<kbd>argument</kbd>对象:</li>
</ol>
<div><pre style="padding-left: 60px">if (!File.Exists(arguments.TrainingFileName))<br/>{<br/>    Console.WriteLine($"Failed to find training data file ({arguments.TrainingFileName})");<br/><br/>    return;<br/>}</pre></div>
<ol start="3">
<li>类似地，我们然后更新测试文件检查以利用<kbd>argument</kbd>对象:</li>
</ol>
<div><pre style="padding-left: 60px">if (!File.Exists(arguments.TestingFileName))<br/>{<br/>    Console.WriteLine($"Failed to find test data file ({arguments.TestingFileName})");<br/><br/>    return;<br/>}</pre></div>
<ol start="4">
<li>接下来，我们从训练文件中加载<kbd>StockPrices</kbd>值:</li>
</ol>
<pre style="padding-left: 60px">var dataView = MlContext.Data.LoadFromTextFile&lt;StockPrices&gt;(arguments.TrainingFileName);</pre>
<ol start="5">
<li>然后我们创建<kbd>Forecasting</kbd>对象，并利用<kbd>nameof</kbd> <strong> </strong> C#特性来避免神奇的字符串引用:</li>
</ol>
<pre style="padding-left: 60px">var model = MlContext.Forecasting.ForecastBySsa(<br/>    outputColumnName: nameof(StockPrediction.StockForecast),<br/>    inputColumnName: nameof(StockPrices.StockPrice), <br/>    windowSize: 7, <br/>    seriesLength: 30, <br/>    trainSize: 24, <br/>    horizon: 5,<br/>    confidenceLevel: 0.95f,<br/>    confidenceLowerBoundColumn: nameof(StockPrediction.LowerBound),<br/>    confidenceUpperBoundColumn: nameof(StockPrediction.UpperBound));</pre>
<p style="padding-left: 60px">输入和输出列名引用与我们在前面章节中看到的一样。<kbd>windowSize</kbd>属性是训练集中数据点之间的持续时间。对于这个应用程序，我们使用<kbd>7</kbd>来表示一周的持续时间。在这种情况下，<kbd>seriesLength</kbd> <strong> </strong>属性表示数据集的总持续时间。<kbd>horizon</kbd>属性指示当模型运行时应该计算多少预测值。在我们的例子中，我们要求<kbd>5</kbd>预测值。</p>
<ol start="6">
<li>最后，我们用训练数据转换模型，调用<kbd>CreateTimeSeriesEngine</kbd>方法，并将模型写入磁盘:</li>
</ol>
<pre style="padding-left: 60px">var transformer = model.Fit(dataView);<br/><br/>var forecastEngine = transformer.CreateTimeSeriesEngine&lt;StockPrices, StockPrediction&gt;(MlContext);<br/><br/>forecastEngine.CheckPoint(MlContext, arguments.ModelFileName);<br/><br/>Console.WriteLine($"Wrote model to {arguments.ModelFileName}");</pre>


            

            
        
    






    
        <title>The ProgramArguments class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">ProgramArguments 类</h1>
                
            
            
                
<p>如本节前面所述，这个新类提供了整个应用程序中使用的参数到属性的一对一映射:</p>
<ol>
<li>首先，我们定义直接映射到命令行参数的属性:</li>
</ol>
<div><pre style="padding-left: 60px">public ProgramActions Action { get; set; }<br/><br/>public string TrainingFileName { get; set; }<br/><br/>public string TestingFileName { get; set; }<br/><br/>public string PredictionFileName { get; set; }<br/><br/>public string ModelFileName { get; set; }</pre></div>
<ol start="2">
<li>最后，我们填充属性的默认值:</li>
</ol>
<div><pre style="padding-left: 60px">public ProgramArguments()<br/>{<br/>    ModelFileName = "chapter8.mdl";<br/><br/>    PredictionFileName = @"..\..\..\Data\predict.csv";<br/><br/>    TrainingFileName = @"..\..\..\Data\sampledata.csv";<br/><br/>    TestingFileName = @"..\..\..\Data\testdata.csv";<br/>}</pre></div>
<p>与前几章不同，如果有任何属性没有按预期设置，程序就会失败。这对开发人员的体验来说很好；然而，在现实世界中，最终用户更有可能尝试不带任何参数运行应用程序。</p>


            

            
        
    






    
        <title>The Program class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">程序类</h1>
                
            
            
                
<p>在<kbd>Program</kbd>类中，代码已经被简化以利用本章前面讨论的新的<kbd>CommandLineParser</kbd>类。通过使用<kbd>CommandLineParser</kbd>类，所有的动作都被切换到利用强类型枚举:</p>
<ol>
<li>首先，尽管相对简单，清除屏幕上任何以前的运行数据是一种改进的 UX:</li>
</ol>
<div><pre style="padding-left: 60px">Console.Clear();</pre></div>
<ol start="2">
<li>然后我们使用新的<kbd>CommandLineParser</kbd>类和相关的<kbd>ParseArguments</kbd>方法来创建一个强类型参数对象:</li>
</ol>
<div><pre style="padding-left: 60px">var arguments = CommandLineParser.ParseArguments&lt;ProgramArguments&gt;(args);</pre></div>
<ol start="3">
<li>然后，我们可以使用一个简化的强类型开关来处理我们的两个动作:</li>
</ol>
<div><pre style="padding-left: 60px">switch (arguments.Action)<br/>{<br/>    case ProgramActions.PREDICT:<br/>        new Predictor().Predict(arguments);<br/>        break;<br/>    case ProgramActions.TRAINING:<br/>        new Trainer().Train(arguments);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"Unhandled action {arguments.Action}");<br/>        break;<br/>}</pre></div>


            

            
        
    






    
        <title>Running the application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">运行应用程序</h1>
                
            
            
                
<p>要运行该应用程序，流程与第 3 章、<em>回归模型</em>中的示例应用程序几乎相同，只是在训练时传递测试数据集:</p>
<ol>
<li>在没有任何参数的情况下运行应用程序来训练模型，我们使用以下步骤:</li>
</ol>
<div><pre style="padding-left: 60px"><strong>PS chapter08\bin\Debug\netcoreapp3.0&gt; .\chapter08.exe</strong><br/>No arguments passed in - using defaults<br/>Wrote model to chapter8.mdl</pre></div>
<ol start="2">
<li>运行应用程序以根据包含的预测数据进行预测，我们使用以下步骤:</li>
</ol>
<div><pre style="padding-left: 60px"><strong>PS chapter08\bin\Debug\netcoreapp3.0&gt; .\chapter08.exe action predict</strong><br/>Given a stock price of $101, the next 5 values are predicted to be: $128, $925, $140, $145, $1057<br/>Given a stock price of $102, the next 5 values are predicted to be: $924, $138, $136, $1057, $158<br/>Given a stock price of $300, the next 5 values are predicted to be: $136, $134, $852, $156, $150<br/>Given a stock price of $40, the next 5 values are predicted to be: $133, $795, $122, $149, $864<br/>Given a stock price of $30, the next 5 values are predicted to be: $767, $111, $114, $837, $122<br/>Given a stock price of $400, the next 5 values are predicted to be: $105, $102, $676, $116, $108<br/>Given a stock price of $55, the next 5 values are predicted to be: $97, $594, $91, $103, $645<br/>Given a stock price of $69, the next 5 values are predicted to be: $557, $81, $87, $605, $90<br/>Given a stock price of $430, the next 5 values are predicted to be: $76, $78, $515, $84, $85</pre></div>
<p>您可以随意修改这些值，并查看预测如何基于模型所基于的数据集而发生变化。从这一点来看，一些实验领域可能要做以下事情:</p>
<ul>
<li>调整在<kbd>Trainer</kbd>类中检查的超参数，例如<kbd>windowSize</kbd>、<kbd>seriesLength</kbd>或<kbd>horizon</kbd>属性，看看准确性是如何受到影响的。</li>
<li>添加更多的数据点——这可以利用你所关注的你最喜欢的股票的数据。</li>
</ul>


            

            
        
    






    
        <title>Exploring additional production application enhancements</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索其他生产应用程序增强功能</h1>
                
            
            
                
<p>现在我们已经完成了我们的深入研究，有几个额外的元素可以进一步增强应用程序。这里讨论几个想法。</p>


            

            
        
    






    
        <title>Logging</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">记录</h1>
                
            
            
                
<p>随着应用程序复杂性的增加，强烈推荐使用 NLog(<a href="https://nlog-project.org/">https://nlog-project.org/</a>)或类似的开源项目进行日志记录。这将允许您以不同的级别登录到文件、控制台或第三方日志解决方案，如 Loggly。例如，如果您将此应用程序部署给客户，那么在远程调试问题时，将错误级别分解为至少调试、警告和错误将会很有帮助。</p>


            

            
        
    






    
        <title>Utilizing Reflection further</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">进一步利用反射</h1>
                
            
            
                
<p>正如本节前面提到的，为了创造灵活性和适应性，我们利用了<kbd>Reflection</kbd>来解析命令行参数。你可以更进一步，用一种完全基于反射的方法替换<kbd>Program</kbd>类中的 switch case 语句/标准流，这意味着对于应用程序中定义的每个动作，它都可以从一个抽象的<kbd>BaseAction</kbd>类继承，并且在运行时，根据参数调用适当的类。对于每一个新动作，只需向<kbd>ProgramActions</kbd>枚举添加一个新条目，然后用该枚举定义一个类就可以了。</p>


            

            
        
    






    
        <title>Utilizing a database</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">利用数据库</h1>
                
            
            
                
<p>在现实世界中，用于运行预测的数据很可能来自数据库。这个数据库，无论是 Postgres，SQL Server，还是 SQLite 数据库(仅举几个例子)，都可以用微软的 Entity Framework Core 或者 ML 来访问。NET 内置的数据库加载器方法— <kbd>CreateDatabaseLoader</kbd>。这个加载器类似于我们从可枚举或文本文件中加载数据的方式，只不过多了注入 SQL 查询的步骤。</p>
<p>在生产场景中，给定实体框架核心的性能和在 ML 上使用 LINQ 而不是明文的能力。NET 的实现(在撰写本文时)，如果使用数据库资源，我建议使用实体框架。</p>


            

            
        
    






    
        <title>Summary</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">摘要</h1>
                
            
            
                
<p>在这一章中，我们深入探讨了生产就绪的内容。NET 核心应用程序体系结构，以前面章节所做的工作为基础。我们还使用 ML.NET 的预测算法创建了一个全新的股票价格估计器。最后，我们讨论了进一步增强. NET 核心应用程序(以及一般的生产应用程序)的一些方法。</p>
<p>在下一章，我们将深入使用 ML 创建一个生产文件分类 web 应用程序。NET 的二进制分类和 ASP.NET 核心框架。</p>


            

            
        
    


</body></html>