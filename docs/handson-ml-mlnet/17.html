<html><head/><body>


    
        <title>Using ONNX with ML.NET</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">将 ONNX 与 ML.NET 一起使用</h1>
                
            
            
                
<p>既然我们已经完成了使用 TensorFlow 和一个<strong>Windows Presentation Foundation</strong>(<strong>【WPF】</strong>)应用程序和 ML.NET 的深入研究，现在是时候开始使用<strong>和 ML.NET 的开放神经网络交换</strong> ( <strong> ONNX </strong>)了。具体来说，在这最后一章中，我们将回顾 ONNX 是什么，此外还将使用一个名为<strong> YOLO </strong>的预训练 ONNX 模型创建一个新的示例应用程序。这个应用程序将建立在前一章的基础上，并显示模型检测到的对象的边界框。此外，我们将在本章的结尾给出改进示例的建议，使其成为生产级应用程序或集成到生产应用程序中。</p>
<p>在本章中，我们将讨论以下主题:</p>
<ul>
<li>分解 ONNX 和 YOLO</li>
<li>创建 ONNX 对象检测应用程序</li>
<li>探索其他生产应用程序增强功能</li>
</ul>


            

            
        
    






    
        <title>Breaking down ONNX and YOLO</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">分解 ONNX 和 YOLO</h1>
                
            
            
                
<p>正如在<a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">第 1 章</a>、<em>机器学习入门和</em>中提到的，ONNX 标准在业内被广泛认为是跨机器学习框架的真正通用格式。在接下来的两节中，我们将回顾 ONNX 提供了什么，以及将在本章中驱动我们的示例的 YOLO 模型。</p>


            

            
        
    






    
        <title>Introducing ONNX</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">ONNX 简介</h1>
                
            
            
                
<p>创建 ONNX 是为了在使用预训练模型或跨框架训练模型时，减少流程的束缚，实现流程的自由流动。通过为框架提供一个开放的导出格式，ONNX 允许了互操作性，从而促进了实验，否则由于几乎每个框架中使用的专有格式的性质，实验将被禁止。</p>
<p>目前，受支持的框架包括 TensorFlow、XGBoost 和 py torch——当然还有 ML.NET。</p>
<p>如果你想进一步深入 ONNX，请查看他们的网站:<a href="https://onnx.ai/index.html">https://onnx.ai/index.h</a><a href="https://onnx.ai/index.html">tml</a>。</p>


            

            
        
    






    
        <title>The YOLO ONNX model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">YOLO ONNX 模型</h1>
                
            
            
                
<p>在<a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">第 12 章</a>、<em>和 ML.NET</em>所做工作的基础上，我们使用了预训练的初始模型，在本章中，我们将使用预训练的 YOLO 模型。该模型提供了非常快速和准确的对象检测，这意味着它可以以一定的置信度在图像中找到多个对象。这与上一章的模型不同，上一章的模型提供了纯图像分类，例如水或食物。</p>
<p class="CDPAlignLeft CDPAlign">为了帮助形象化这两个模型之间的差异，请将前一章对水进行分类的 TensorFlow 模型与本章对汽车的对象检测进行比较，如下图所示:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-594 image-border" src="img/d1ab6cee-dd3b-4f28-88ee-079e9a8547ff.png" style="width:22.83em;height:9.08em;"/></p>
<p>由于互联网上图像数量的显著增加和对安全性的需要，图像(和视频)中的对象检测的需求一直在增加。想象一个拥挤的环境，如足球场，尤其是前门附近。保安巡逻和监控这个区域；然而，和你一样，他们也只是人类，只能以一定的准确度扫视这么多人。应用实时机器学习的对象检测来拾取武器或大包，然后可以用来提醒保安人员去追捕嫌疑人。</p>
<p>YOLO 模型本身有两种主要形式——微型模型和完整模型。对于这个例子的范围，我们将使用较小的模型(大约 60 MB ),它可以对一个图像中的 20 个对象进行分类。微型模型由九个卷积层和六个最大池层组成。完整的模型可以分类成千上万的物体，如果有合适的硬件(即<strong>图形处理单元</strong>(<strong>GPU</strong>))，可以比实时运行更快。</p>
<p>下图描述了 YOLO 模型的工作原理(在某种程度上，还有神经网络):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-595 image-border" src="img/72db35ce-7a4d-42ef-a52b-8b60d333a7a8.png" style="width:51.17em;height:21.42em;"/></p>
<p>实际上，图像被转换成 3×416×416 的图像。3 分量代表<strong>红绿蓝</strong> ( <strong> RGB </strong>)值。这 416 个值表示调整后的图像的宽度和高度。这个输入层然后被输入到模型的隐藏层。对于我们在本章中使用的微型 YOLO v2 模型，在输出图层之前总共有 15 个图层。</p>
<p>要深入了解 YOLO 模式，请阅读本文:<a href="https://arxiv.org/pdf/1612.08242.pdf">https://arxiv.org/pdf/1612.08242.pdf</a>。</p>


            

            
        
    






    
        <title>Creating the ONNX object detection application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">创建 ONNX 对象检测应用程序</h1>
                
            
            
                
<p>如前所述，我们将创建的应用程序是一个使用预训练 ONNX 模型的对象检测应用程序。使用我们在<a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">第 12 章</a>、<em>中开发的应用程序，使用 TensorFlow 和 ML.NET</em>作为起点，当模型对它知道的对象进行分类时，我们将添加对覆盖在图像顶部的边界框的支持。这对公众的有用之处在于图像对象检测提供的各种应用。想象一下，你正在为警察或情报部门做一个项目，他们有图像或视频，想要检测武器。正如我们将要展示的那样，将 YOLO 模型应用于 ML.NET，将会使这一过程变得非常容易。</p>
<p>与前面的章节一样，完整的项目代码、预先训练的模型和项目文件可以在这里下载:<a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter13">https://github . com/packt publishing/Hands-On-Machine-Learning-With-ML。网/树/主人/第 13 章</a>。</p>


            

            
        
    






    
        <title>Exploring the project architecture</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索项目架构</h1>
                
            
            
                
<p>基于我们在前几章中创建的项目体系结构和代码，我们将审查的体系结构得到了增强，变得更加结构化，更便于最终用户使用。</p>
<p>与前面的一些章节一样，如果您想要利用 ONNX 模型并执行对象检测，则需要以下两个额外的 NuGet 包:</p>
<ul>
<li><kbd>Microsoft.ML.ImageAnalytics</kbd></li>
<li><kbd>Microsoft.ML.OnnxTransformer</kbd></li>
</ul>
<p>这些 NuGet 包已经在包含的示例代码中被引用。这些包的 1.3.1 版本在 GitHub 上的示例和本章的深入探讨中都有使用。</p>
<p>在下面的屏幕截图中，您将找到该项目的 Visual Studio 解决方案资源管理器视图。该解决方案新增了几项功能，以促进我们的目标生产用例。我们将在本章后面的以下解决方案屏幕截图中详细查看每个新文件:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-596 image-border" src="img/bda2449a-5aa4-4ac5-acf2-adb328a47f44.png" style="width:19.67em;height:32.58em;"/></p>
<p>由于撰写本文时的当前 model 限制，ONNX 支持仅针对使用现有模型的评分提供。本例中包含的预训练模型可以在<kbd>assets/model</kbd>文件夹中找到。</p>


            

            
        
    






    
        <title>Diving into the code</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">钻研代码</h1>
                
            
            
                
<p>对于此应用程序，如前一节所述，我们使用 TensorFlow 和 ML.NET 构建在第<a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">章第 12 </a>、<em>中完成的工作的基础上。虽然<strong>用户界面</strong> ( <strong> UI </strong>)没有太大变化，但是运行 ONNX 模型的底层代码发生了变化。对于每个更改过的文件——如前几章所述——我们将回顾所做的更改以及更改背后的原因。</em></p>
<p>更改或添加的类如下:</p>
<ul>
<li><kbd>DimensionsBase</kbd></li>
<li><kbd>BoundingBoxDimensions</kbd></li>
<li><kbd>YoloBoundingBox</kbd></li>
<li><kbd>MainWindow.xaml</kbd></li>
<li><kbd>ImageClassificationPredictor</kbd></li>
<li><kbd>MainWindowViewModel</kbd></li>
</ul>
<p>还有一个附加文件，其中包含了<kbd>YoloOutputParser</kbd>类。这个类来源于<strong>麻省理工学院</strong> ( <strong>麻省理工学院</strong>)为<kbd>TinyYOLO</kbd> ONNX 模型授权的接口。由于这节课时间较长，我们就不复习了；然而，代码读起来确实很容易，如果您希望逐步完成一个预测，流程将很容易理解。</p>


            

            
        
    






    
        <title>The DimensionsBase class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">DimensionsBase 基类</h1>
                
            
            
                
<p><kbd>DimensionsBase</kbd>类包含坐标以及<kbd>Height</kbd>和<kbd>Width</kbd>属性，如下面的代码块所示:</p>
<pre>public class DimensionsBase<br/>{<br/>    public float X { get; set; }<br/><br/>    public float Y { get; set; }<br/>    <br/>    public float Height { get; set; }<br/>    <br/>    public float Width { get; set; }<br/>}</pre>
<p>这个基类被<kbd>YoloOutputParser</kbd>和<kbd>BoundingBoxDimensions</kbd>类用来减少代码重复。</p>


            

            
        
    






    
        <title>The YoloBoundingBox class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">YoloBoundingBox 类</h1>
                
            
            
                
<p><kbd>YoloBoundingBox</kbd>类提供了容器类，用于在为覆盖图生成边界框时填充边界框，如下面的代码块所示:</p>
<pre>public class YoloBoundingBox<br/>{<br/>    public BoundingBoxDimensions Dimensions { get; set; }<br/><br/>    public string Label { get; set; }<br/><br/>    public float Confidence { get; set; }<br/><br/>    public RectangleF Rect =&gt; new RectangleF(Dimensions.X, Dimensions.Y, Dimensions.Width, Dimensions.Height);<br/><br/>    public Color BoxColor { get; set; }<br/>}</pre>
<p>此外，在这个类文件中还定义了我们的<kbd>BoundingBoxDimensions</kbd>类，如下面的代码块所示:</p>
<pre>public class BoundingBoxDimensions : DimensionsBase { }</pre>
<p>同样，这种继承用于减少代码重复。</p>


            

            
        
    






    
        <title>The MainWindow.xaml file</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">MainWindow.xaml 文件</h1>
                
            
            
                
<p>我们的应用程序的<strong>可扩展应用程序标记语言</strong> ( <strong> XAML </strong>)视图已经简化为只有按钮和图像控件，如下面的代码块所示:</p>
<pre>&lt;Grid&gt;<br/>    &lt;Grid.RowDefinitions&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>        &lt;RowDefinition Height="*" /&gt;<br/>    &lt;/Grid.RowDefinitions&gt;<br/><br/>    &lt;Button Grid.Row="0" Margin="0,10,0,0" Width="200" Height="35" Content="Select Image File" HorizontalAlignment="Center" Click="btnSelectFile_Click" /&gt;<br/><br/>    &lt;Image Grid.Row="1" Margin="10,10,10,10" Source="{Binding SelectedImageSource}" /&gt;<br/>&lt;/Grid&gt;</pre>
<p>此外，由于您可能选择的边界框和图像的性质，窗口默认为<kbd>Maximized</kbd>，如以下代码块所示:</p>
<pre>&lt;Window x:Class="chapter13.wpf.MainWindow"<br/>        <br/>        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"<br/>        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"<br/>        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"<br/>        xmlns:local="clr-namespace:chapter13.wpf"<br/>        mc:Ignorable="d"<br/>        ResizeMode="NoResize"<br/>        WindowStyle="SingleBorderWindow"<br/>        WindowState="Maximized"<br/>        WindowStartupLocation="CenterScreen"<br/>        Background="#1e1e1e"<br/>        Title="Chapter 13" Height="450" Width="800"&gt;</pre>
<p>XAML 的变化已经过去，现在让我们进入修改后的<kbd>ImageClassificationPredictor</kbd>类。</p>


            

            
        
    






    
        <title>The ImageClassificationPredictor class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">ImageClassificationPredictor 类</h1>
                
            
            
                
<p><kbd>ImageClassificationPredictor</kbd>类，很像<a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">第 12 章</a>、<em>与 ML.NET</em>一起使用 TensorFlow，包含了运行我们的图像预测的方法。在本章中，我们将需要创建几个额外的类对象来支持 ONNX 模型的运行，如下所示:</p>
<ol>
<li>首先，我们定义了定义网络高度和宽度的<kbd>ImageNetSettings</kbd>结构。YOLO 模型要求使用 416 像素乘 416 像素，如下面的代码块所示:</li>
</ol>
<pre style="padding-left: 60px">public struct ImageNetSettings<br/>{<br/>    public const int imageHeight = 416;<br/>    public const int imageWidth = 416;<br/>}   </pre>
<ol start="2">
<li>接下来，我们定义用于 ONNX 模型的<kbd>TinyYoloModelSettings</kbd>结构，如下所示:</li>
</ol>
<pre style="padding-left: 60px">public struct TinyYoloModelSettings<br/>{<br/>    public const string ModelInput = "image";<br/><br/>    public const string ModelOutput = "grid";<br/>}</pre>
<ol start="3">
<li>与前一章不同，在第一次运行时，TensorFlow 模型被导入，然后作为 ML.NET 模型导出，在撰写本文时，ONNX 不支持这种方式。因此，我们每次都必须在<kbd>Initialize</kbd>方法中加载 ONNX 模型，如下面的代码块所示:</li>
</ol>
<pre style="padding-left: 60px">public (bool Success, string Exception) Initialize()<br/>{<br/>    try<br/>    {<br/>        if (File.Exists(ML_NET_MODEL))<br/>        {<br/>            var data = MlContext.Data.LoadFromEnumerable(new List&lt;ImageDataInputItem&gt;());<br/><br/>            var pipeline = MlContext.Transforms.LoadImages(outputColumnName: "image", imageFolder: "", <br/>                    inputColumnName: nameof(ImageDataInputItem.ImagePath))<br/>                .Append(MlContext.Transforms.ResizeImages(outputColumnName: "image", <br/>                    imageWidth: ImageNetSettings.imageWidth, <br/>                    imageHeight: ImageNetSettings.imageHeight, <br/>                    inputColumnName: "image"))<br/>                .Append(MlContext.Transforms.ExtractPixels(outputColumnName: "image"))<br/>                .Append(MlContext.Transforms.ApplyOnnxModel(modelFile: ML_NET_MODEL, <br/>                    outputColumnNames: new[] { TinyYoloModelSettings.ModelOutput }, <br/>                    inputColumnNames: new[] { TinyYoloModelSettings.ModelInput }));<br/><br/>            _model = pipeline.Fit(data);<br/><br/>            return (true, string.Empty);<br/>        }<br/><br/>        return (false, string.Empty);<br/>    }<br/>    catch (Exception ex)<br/>    {<br/>        return (false, ex.ToString());<br/>    }<br/>}</pre>
<ol start="4">
<li>接下来，我们广泛地修改<kbd>Predict</kbd>方法来支持<kbd>YoloParser</kbd>调用，调用<kbd>DrawBoundingBox</kbd>方法来覆盖边界框，然后返回更新图像的字节，如下所示:</li>
</ol>
<pre style="padding-left: 60px">public byte[] Predict(string fileName)<br/>{<br/>    var imageDataView = MlContext.Data.LoadFromEnumerable(new List&lt;ImageDataInputItem&gt; { new ImageDataInputItem { ImagePath = fileName } });<br/><br/>    var scoredData = _model.Transform(imageDataView);<br/><br/>    var probabilities = scoredData.GetColumn&lt;float[]&gt;(TinyYoloModelSettings.ModelOutput);<br/><br/>    var parser = new YoloOutputParser();<br/><br/>    var boundingBoxes =<br/>        probabilities<br/>            .Select(probability =&gt; parser.ParseOutputs(probability))<br/>            .Select(boxes =&gt; parser.FilterBoundingBoxes(boxes, 5, .5F));<br/><br/>    return DrawBoundingBox(fileName, boundingBoxes.FirstOrDefault());<br/>}</pre>
<p>为了简洁起见，这里没有显示<kbd>DrawBoundingBox</kbd>方法。在高层次上，原始图像被加载到内存中，然后模型的边界框与标签和置信度一起被绘制在图像的顶部。然后，更新后的图像被转换为字节数组并返回。</p>


            

            
        
    






    
        <title>The MainWindowViewModel class</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">MainWindowViewModel 类</h1>
                
            
            
                
<p>在<kbd>MainWindowViewModel</kbd>类中，由于这个例子的性质，需要做一些改变。我们在这里看它们:</p>
<ol>
<li>首先，<kbd>LoadImageBytes</kbd>方法现在简单地将解析后的图像字节转换成一个<kbd>Image</kbd>对象，就像这样:</li>
</ol>
<pre style="padding-left: 60px">private void LoadImageBytes(byte[] parsedImageBytes)<br/>{<br/>    var image = new BitmapImage();<br/><br/>    using (var mem = new MemoryStream(parsedImageBytes))<br/>    {<br/>        mem.Position = 0;<br/><br/>        image.BeginInit();<br/>        <br/>        image.CreateOptions = BitmapCreateOptions.PreservePixelFormat;<br/>        image.CacheOption = BitmapCacheOption.OnLoad;<br/>        image.UriSource = null;<br/>        image.StreamSource = mem;<br/>        <br/>        image.EndInit();<br/>    }<br/><br/>    image.Freeze();<br/><br/>    SelectedImageSource = image;<br/>}</pre>
<ol start="2">
<li>最后，我们修改<kbd>Classify</kbd>方法以在成功运行模型时调用<kbd>LoadImageBytes</kbd>方法，如下所示:</li>
</ol>
<pre style="padding-left: 60px">public void Classify(string imagePath)<br/>{<br/>    var result = _prediction.Predict(imagePath);<br/><br/>    LoadImageBytes(result);<br/>}</pre>
<p>对<kbd>Classify</kbd>方法进行修改后，本章示例所需的代码修改就结束了。现在，让我们运行应用程序！</p>


            

            
        
    






    
        <title>Running the application</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">运行应用程序</h1>
                
            
            
                
<p>要运行该应用程序，流程与第 12 章【ML.NET 使用 TensorFlow】中的示例应用程序相同。要在 Visual Studio 中运行应用程序，只需单击工具栏中的<em>播放</em>图标，如下图所示:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-597 image-border" src="img/5fe7e40a-4da8-4dc1-8700-6fd1782f74bd.png" style="width:22.58em;height:2.33em;"/></p>
<p>启动应用程序后，就像在<a href="049e90c4-05b0-466d-af93-d56df861a843.xhtml">第十二章</a>、【model】使用 TensorFlow】一样，选择一个图像文件，模型就会运行。例如，我选择了一张去德国度假时拍的照片(注意汽车的边框)，如下图所示:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-598 image-border" src="img/be4ac682-f556-4270-a7e6-6dbf82838d48.png" style="width:69.42em;height:33.83em;"/></p>
<p>请随意尝试选择您硬盘上的图像，以查看检测的可信度以及对象周围的边界框形成得如何。</p>


            

            
        
    






    
        <title>Exploring additional production application enhancements</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">探索其他生产应用程序增强功能</h1>
                
            
            
                
<p>现在我们已经完成了我们的深入研究，有几个额外的元素来进一步增强应用程序。在接下来的章节中，我们将讨论一些想法。</p>


            

            
        
    






    
        <title>Logging</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">记录</h1>
                
            
            
                
<p>如前所述，在桌面应用程序中，日志的重要性怎么强调都不为过。随着应用程序复杂性的增加，强烈推荐使用 NLog(<a href="https://nlog-project.org/">https://nlog-project.org/</a>)或类似的开源项目进行日志记录。这将允许您以不同的级别登录到文件、控制台或第三方日志解决方案，如 Loggly。例如，如果您将此应用程序部署给客户，那么在远程调试问题时，将错误级别分解为至少调试、警告和错误将会很有帮助。</p>


            

            
        
    






    
        <title>Image scaling</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">图像缩放</h1>
                
            
            
                
<p>您可能已经注意到，对于非常大的图像(超过屏幕分辨率的图像)，图像预览中边界框的文本标签和大小调整不像 640 x 480 图像那样容易阅读。这里需要改进的一个地方是提供悬停功能，根据窗口大小调整图像大小或者动态增加字体大小。</p>


            

            
        
    






    
        <title>Utilizing the full YOLO model</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">利用完整的 YOLO 模型</h1>
                
            
            
                
<p>此外，此示例的另一个改进之处是在应用程序中使用完整的 YOLO 模型。正如前面提到的示例应用程序中使用的微型 YOLO 模型，只提供了 20 个标签。在生产应用程序或您希望构建的应用程序中，使用更大、更复杂的模型将是一个不错的选择。</p>
<p>你可以在这里下载完整的 YOLO 模型:<a href="https://github.com/onnx/models/tree/master/vision/object_detection_segmentation/yolov3">https://github . com/onnx/models/tree/master/vision/object _ detection _ segmentation/yolo v3</a>。</p>


            

            
        
    






    
        <title>Summary</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    <h1 class="header-title">摘要</h1>
                
            
            
                
<p>在本章的过程中，我们深入探讨了 ONNX 格式的内容以及它为社区提供了什么。此外，我们还创建了一个全新的检测引擎使用预先训练的微小的 ML.NET YOLO 模型。</p>
<p>至此，你对 ML.NET 的深度探索就此结束。在这本书的第一页和这一页之间，你有望理解 ML.NET 在一个非常简单的功能丰富的抽象中提供的能力。随着 ML.NET 的不断发展(很像。NET)，ML 的进化就不会有疑问了。NET 的功能集和部署目标，从嵌入式<strong>物联网</strong> ( <strong>物联网</strong>)设备到移动设备。我希望这本书对你深入研究 ML.NET 和机器学习有所帮助。此外，我希望你们在今后处理问题时，首先考虑利用 ML.NET 来更有效地解决问题是否会对问题有所助益，而且总体上可能会更好。鉴于世界上的数据持续以指数速度增长，使用非暴力/传统方法的必要性只会继续增长，因此从本书中获得的技能应该在未来几年内对你有所帮助。</p>


            

            
        
    


</body></html>