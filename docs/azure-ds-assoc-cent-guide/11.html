<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style>
<div><div><h1 id="_idParaDest-115"><em class="italic"> <a id="_idTextAnchor117"/>第八章</em>:尝试 Python 代码</h1>
			<p>在本章中，你将了解如何训练<code>scikit-learn</code>库，也就是通常所说的<code>sklearn</code>。你会明白如何使用<strong class="bold"> Azure </strong> <strong class="bold">机器学习</strong> ( <strong class="bold"> AzureML </strong> ) <strong class="bold"> SDK </strong>和<strong class="bold"> MLflow </strong>来跟踪训练指标。然后，您将看到如何在计算集群中扩展培训流程。</p>
			<p>在本章中，我们将讨论以下主题:</p>
			<ul>
				<li>在笔记本电脑中训练简单的<code>sklearn</code>模型</li>
				<li>跟踪实验中的指标</li>
				<li>利用计算集群扩展培训流程</li>
			</ul>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>技术要求</h1>
			<p>您需要访问 Azure 订阅。在该订阅中，您将需要一个<code>packt-azureml-rg</code>。你将需要一个<code>Contributor</code>或者<code>Owner</code>T3。如果你按照第二章 、<em class="italic">部署 Azure 机器学习工作区资源</em>中的说明，这些资源应该已经对你可用了。</p>
			<p>您还需要对 Python 语言有一个基本的了解。代码片段面向 Python 3.6 或更新版本。您还应该熟悉在 AzureML Studio 中使用笔记本的体验，这在前一章中已经介绍过了。</p>
			<p>本章假设您已经在 AzureML 工作空间中注册了<code>scikit-learn</code> <code>diabetes</code>数据集，并且已经创建了一个名为<code>cpu-sm-cluster</code>的计算集群，如<a href="B16777_07_Final_VK_ePub.xhtml#_idTextAnchor102"> <em class="italic">第 7 章</em> </a>、<em class="italic">azure ml Python SDK</em>中的<em class="italic">定义数据存储库</em>、<em class="italic">使用数据集</em>和<em class="italic">使用计算目标</em>部分所述。</p>
			<p>你可以在 GitHub 的<a href="http://bit.ly/dp100-ch08">http://bit.ly/dp100-ch08</a>找到这一章的所有笔记本和代码片段。</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>在笔记本电脑中训练简单的 sklearn 模型</h1>
			<p>本节的<a id="_idIndexMarker533"/>目标是创建一个<a id="_idIndexMarker534"/> Python 脚本，该脚本将在<em class="italic">中注册的<code>diabetes</code>数据集的基础上生成一个简单的模型，在<a href="B16777_07_Final_VK_ePub.xhtml#_idTextAnchor102"> <em class="italic">第 7 章</em> </a>、<em class="italic">AzureML Python SDK</em>中使用数据集</em>。该模型将获得数字输入，并预测数字输出。要创建此模型，您需要准备数据，训练模型，评估训练模型的表现，然后存储它，以便您将来能够重用它，如图<em class="italic">图 8.1 </em>所示:</p>
			<div><div><img src="img/B16777_08_001.jpg" alt="Figure 8.1 – Process to produce the diabetes-predicting model&#13;&#10;" width="1650" height="284"/>
				</div>
			</div>
			<p class="figure-caption">图 8.1-产生糖尿病预测模型的过程</p>
			<p>让我们从了解您将使用的数据集开始。<code>diabetes</code>数据集由 442 名<code>diabetes</code>患者的数据组成。每行代表一名患者。每行包含 10 个特征(<code>target</code>，是记录特征后 1 年<code>diabetes</code>疾病进展的定量测量。</p>
			<p>您可以在 AzureML Studio 接口中进一步探索数据集，如<em class="italic">图 8.2 </em>所示:</p>
			<div><div><img src="img/B16777_08_002.jpg" alt="Figure 8.2 – The registered diabetes dataset&#13;&#10;" width="1650" height="401"/>
				</div>
			</div>
			<p class="figure-caption">图 8.2–登记的糖尿病数据集</p>
			<p>通常在<a id="_idIndexMarker535"/>准备阶段，您加载<a id="_idIndexMarker536"/>原始数据，筛选有缺失值的行，归一化特征值，然后将数据集拆分为训练和验证数据。由于数据已经过预处理，您只需加载数据并将其分成两部分:</p>
			<ol>
				<li>Navigate to the <code>chapter08</code> and then create a notebook named <code>chapter08.ipynb</code>:<div><img src="img/B16777_08_003.jpg" alt="Figure 8.3 – Creating the chapter08 notebook you will be working on&#13;&#10;" width="890" height="777"/></div><p class="figure-caption">图 8.3–创建您将要使用的第 08 章笔记本</p></li>
				<li>In the first<a id="_idIndexMarker537"/> cell of the notebook, add<a id="_idIndexMarker538"/> the following code:<pre>from azureml.core import Workspace
ws = Workspace.from_config()
diabetes_ds = ws.datasets['diabetes']
training_data, validation_data =\
diabetes_ds.random_split(percentage = 0.8)
X_train =\
training_data.drop_columns('target').to_pandas_dataframe()
y_train =\
training_data.keep_columns('target').to_pandas_dataframe()
X_validate =\
validation_data.drop_columns('target').to_pandas_dataframe()
y_validate =\
validation_data.keep_columns('target').to_pandas_dataframe()</pre><p>在这个代码片段中，您获得了对工作区的引用，并检索了名为<code>diabetes</code>的数据集。然后你用<code>random_split()</code>方法把它分成两个<code>TabularDataset</code>。第一个数据集是<code>training_data</code>，它包含 80%的数据，而<code>validation_data</code>数据集引用另外 20%的数据。这些数据集包含您想要预测的要素和标注。使用<code>TabularDataset</code>的<code>drop_columns()</code>和<code>keep_columns()</code>方法，您可以从<code>label</code>列中分离出特性。然后用<code>TabularDataset</code>的<code>to_pandas_dataframe()</code>方法将数据加载到内存中。你最终得到了四个熊猫数据帧:</p><ul><li><code>X_train</code>:包含 80%的行。每行有 10 列(<code>0</code>到<code>9</code>)。</li><li><code>y_train</code>:包含 80%的行。每行有 1 列(<code>target</code>)。</li><li><code>X_validate</code>:包含 20%的行。每行有 10 列(<code>0</code>到<code> 9</code>)。</li><li><code>y_validate</code>:包含 20%的行。每行有 1 列(<code>target</code>)。</li></ul><p><code>diabetes</code>数据集在科学文献中非常流行。它被用作<a id="_idIndexMarker539"/>训练<em class="italic">回归</em>模型的例子。<code>scikit-learn</code>库提供了一个名为<code>sklearn.linear_model</code>的专用<a id="_idIndexMarker540"/>模块，其中包含许多我们可以使用的线性回归模型。现在您已经准备好了数据，您的下一个任务是训练模型。</p></li>
				<li>In this step, you are going to train a <code>LassoLars</code> model, which is an abbreviation <a id="_idIndexMarker541"/>for <code>LassoLars</code> class accepts a float parameter named <code>alpha</code>, which is known as a <em class="italic">regularization parameter</em> or <em class="italic">penalty term</em>. Its primary purpose is to protect the model from overfitting to the training dataset. Since this parameter controls the training process, it is referred to as being a <em class="italic">hyperparameter</em>. This parameter cannot be changed once the model has been trained. In this code block, you are instantiating an untrained model, setting <code>0.1</code> for the <code>alpha</code> parameter. In the next chapter, <a href="B16777_09_Final_VK_ePub.xhtml#_idTextAnchor136"><em class="italic">Chapter 9</em></a>, <em class="italic">Optimizing the ML Model</em>, you will tune this parameter and try to locate the best value for your dataset.<p>然后，<a id="_idIndexMarker544"/>使用<code>X_train</code>和<code>y_train</code>数据帧来拟合()模型，这意味着您正在根据<a id="_idIndexMarker545"/>训练数据集来训练模型。在这个过程之后，<code>model</code>变量引用了一个经过训练的模型，您可以用它来进行预测。</p></li>
				<li>下一个任务是根据一个度量标准评估您生成的模型。评估回归模型的最常见指标如下:<ul><li>平均或中位数绝对误差。</li><li>Mean squared error or log error. Another common variation of this metric is the <code>mean_squared_error</code> method of the <code>sklearn.metrics</code> package. A common issue with this metric is that a model trained on data with a larger range of values has a higher rate of error than the same model trained on data with a smaller range. You are going to use a technique called <em class="italic">metric normalization</em> that basically divides the metric by the range of the data. The resulting metric is known <a id="_idIndexMarker547"/>as the <code>X_validate</code> DataFrame. You calculate the RMSE, comparing the predictions with the ground truth stored in the <code>y_validate</code> DataFrame. Then, you calculate the range of values (maximum minus minimum) using the <code>ptp()</code> method of <code>0.2</code>.<p>最后一步是存储训练好的模型，以便能够在将来重用它。您将创建一个名为<code>outputs</code>的文件夹，并将模型保存到一个文件中。Python 对象到文件的持久化是使用<code>joblib</code>库的<code>dump()</code>方法完成的。</p><p>在新的笔记本单元格中，输入以下源代码:</p><pre>import os
import joblib
os.makedirs('./outputs', exist_ok=True)
model_file_n<a id="_idTextAnchor120"/>ame = f'model_{nrmse:.4f}_{alpha:.4f}.pkl'
joblib.dump(value=model,
        filename=os.path.join('./outputs/',model_file_name))</pre><p>如果<code>outputs</code>文件夹不存在，则创建它。然后，您将模型存储在一个文件名<a id="_idIndexMarker551"/>中，该文件名包含前缀<code>model_</code>，后跟在<em class="italic">步骤 4 </em>中计算的 NRMSE 度量<a id="_idIndexMarker552"/>，再跟一个<code>_</code>，然后是用于实例化模型的<code>alpha</code>参数。您应该能够在文件浏览器中看到序列化的模型，如<em class="italic">图 8.4 </em>所示:</p></li>
			</ul></li></ol>
			<div><div><img src="img/B16777_08_004.jpg" alt="Figure 8.4 – Serialized model stored in the outputs folder&#13;&#10;" width="742" height="593"/>
				</div>
			</div>
			<p class="figure-caption">图 8.4–存储在输出文件夹中的序列化模型</p>
			<p>您在<em class="italic">步骤 5 </em>中使用的<a id="_idIndexMarker553"/>命名约定有助于您<a id="_idIndexMarker554"/>跟踪模型的执行情况，并跟踪您在本次运行中使用的参数。AzureML SDK 提供了各种方法来监控、组织和管理您的训练运行，这将在下一节中探讨。</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor121"/>跟踪实验中的指标</h1>
			<p>当您<a id="_idIndexMarker555"/>训练一个模型时，您正在执行一个试验<a id="_idIndexMarker556"/>，您正在记录该过程的各个方面，包括诸如您需要用来比较模型性能的 NRMSE 之类的指标。AzureML 工作空间提供了<strong class="bold">实验</strong>的概念——也就是说，一个容器将这样的试验/运行组合在一起。</p>
			<p>要创建一个新的实验，您只需要指定您将使用的工作空间，并提供一个最多包含 36 个字母、数字、下划线和破折号的名称。如果实验已经存在，您将获得对它的引用。在您的<code>chapter08.ipynb</code>笔记本中添加一个单元格，并添加以下代码:</p>
			<pre>from azureml.core import Workspace, Experiment
ws = Workspace.from_config()
exp = Experiment(workspace=ws, name="chapter08")</pre>
			<p>首先获取对现有 AzureML 工作空间的引用，然后创建<code>chapter08</code>实验(如果它还不存在的话)。如果您导航到 Studio 界面的<strong class="bold">资产</strong> | <strong class="bold">实验</strong>部分，您会注意到列表中出现一个空实验，如图 8.5 中的<em class="italic">所示:</em></p>
			<div><div><img src="img/B16777_08_005.jpg" alt="Figure 8.5 – Empty Experiment created with the SDK&#13;&#10;" width="1650" height="653"/>
				</div>
			</div>
			<p class="figure-caption">图 8.5–用 SDK 创建的空实验</p>
			<p>要在<code>chapter08</code>实验下创建一个<a id="_idIndexMarker557"/>运行，您<a id="_idIndexMarker558"/>可以在一个新的单元格中添加以下代码:</p>
			<pre>run = exp.start_logging()
print(run.get_details())</pre>
			<p><code>run</code>变量让您可以访问 AzureML SDK 的<code>Run</code>类的一个实例，它代表一个实验的一次试验。每个<code>run</code>实例都有一个惟一的 ID，标识工作区中的特定运行。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">在<em class="italic">用计算集群</em>扩展训练过程一节中，您将使用<code>Run</code>类的<code>get_context</code>方法来获取对正在执行 Python 脚本的<code>run</code>实例的引用。<code>run</code>通常是在您提交一个脚本以在实验中执行时自动创建的。<code>start_logging</code>方法很少使用，只有当您想要手动创建一个<code>run</code>并记录度量时才使用。最常见的情况是当您使用笔记本单元训练模型时，或者当您在远程计算机(如本地计算机或<strong class="bold"> Databricks </strong>工作空间)上训练模型时。</p>
			<p><code>run</code>类提供了丰富的日志 API。最常用的方法是通用的<code>log()</code>方法，它允许您使用以下代码记录指标:</p>
			<pre>run.log("nrmse", 0.01)
run.log(name="nrmse", value=0.015, description="2nd measure")</pre>
			<p>在这段代码中，<a id="_idIndexMarker559"/>为<code>nrmse</code>度量记录值<code>0.01</code>，然后<a id="_idIndexMarker560"/>为相同的度量记录值<code>0.015</code>，传递可选的<code>description</code>参数。</p>
			<p>如果您导航到<code>chapter08</code>实验，您会注意到有一个<code>run</code>当前处于<code>run</code>状态，导航到<strong class="bold">指标</strong>选项卡，您将能够注意到<strong class="bold"> nrmse </strong>指标的两个测量值，以图表或表格的形式显示，如<em class="italic">图 8.6 </em>所示:</p>
			<div><div><img src="img/B16777_08_006.jpg" alt="Figure 8.6 – The two measurements of nrmse as seen in the Studio experience&#13;&#10;" width="1650" height="1032"/>
				</div>
			</div>
			<p class="figure-caption">图 8.6–在工作室体验中看到的 nrmse 的两个测量值</p>
			<p><code>Run</code>类为<a id="_idIndexMarker561"/>提供了一个丰富的日志记录方法列表，包括下面的<a id="_idIndexMarker562"/>:</p>
			<ul>
				<li>The <code>log_list</code> method allows you to log a list of values for the specific metric. An example of this method is the following code:<pre>run.log_list("accuracies", [0.5, 0.57, 0.62])</pre><p>该代码将在运行的<em class="italic">指标</em>部分产生<em class="italic">图 8.7 </em>:</p></li>
			</ul>
			<div><div><img src="img/B16777_08_007.jpg" alt="Figure 8.7 – Graph representing three values logged with the log_list method&#13;&#10;" width="912" height="697"/>
				</div>
			</div>
			<p class="figure-caption">图 8.7-表示使用 log_list 方法记录的三个值的图表</p>
			<ul>
				<li>The <code>log_table</code> and <code>log_row</code> methods allow you to log tabular data. Note that, with this <a id="_idIndexMarker563"/>method, you can specify the labels in<a id="_idIndexMarker564"/> the <em class="italic">x</em> axis in contrast to the <code>log_list</code> method:<pre>run.log_table("table", {"x":[1, 2], "y":[0.1, 0.2]})
run.log_row("table", x=3, y=0.3)</pre><p>该代码片段将在运行的<em class="italic">指标</em>部分产生<em class="italic">图 8.8 </em>:</p></li>
			</ul>
			<div><div><img src="img/B16777_08_008.jpg" alt="Figure 8.8 – Tabular metric logged using the log_table and log_row methods&#13;&#10;" width="909" height="683"/>
				</div>
			</div>
			<p class="figure-caption">图 8.8–使用 log_table 和 log_row 方法记录的表格度量</p>
			<ul>
				<li>专门的<a id="_idIndexMarker565"/>方法，如<code>log_accuracy_table</code>、<code>log_confusion_matrix</code>、<code>log_predictions</code>和<code>log_residuals</code>提供了记录数据的自定义呈现。</li>
				<li><code>log_image</code>方法<a id="_idIndexMarker566"/>允许你从众所周知的<code>matplotlib</code> Python 库或其他绘图库中记录图形或图像。</li>
				<li><code>upload_file</code>、<code>upload_files</code>和<code>upload_folder</code>方法允许您上传实验残差并将它们与当前运行相关联。这些方法通常用于上传在<code>run</code>执行期间产生的各种二进制工件，例如由<code>plotly</code>等开源库创建的交互式 HTML 图形。</li>
			</ul>
			<p>您可以选择创建子运行来隔离试验的子部分。子运行记录它们自己的指标，您也可以选择登录父运行。例如，下面的代码片段创建了一个子运行，记录了一个名为<code>child_metric</code>的指标(仅在该运行中可见)，然后记录了父运行的指标<code>metric_from_child</code>:</p>
			<pre>child_run = run.child_run()
child_run.log("child_metric", 0.01)
child_run.parent.log("metric_from_child", 0.02)</pre>
			<p>一旦你完成了运行，你需要改变它的<strong class="bold">运行</strong>状态。您可以使用以下方法之一:</p>
			<ul>
				<li><code>complete</code>方法表示运行已成功完成。该方法还将<code>outputs</code>文件夹(如果存在的话)上传到<code>runs</code>工件，而不需要<a id="_idIndexMarker568"/>显式调用<code>Run</code>类的<code>upload_folder</code>方法。</li>
				<li><code>cancel</code>方法表示作业被取消。您会注意到在 AutoML 实验中运行被取消，因为已达到超时期限。</li>
				<li>不推荐使用的<code>fail</code>方法表示发生了错误。</li>
			</ul>
			<p>下面的代码片段取消子运行并完成根运行，打印状态，应该显示为<strong class="bold"> Completed </strong>:</p>
			<pre>child_run.cancel()
run.complete()
print(run.get_status())</pre>
			<p>在本节中，您了解了 AzureML 的日志功能。在下一节中，您将重构您在<em class="italic">在笔记本</em>中训练简单 sklearn 模型一节中创建的代码，并添加日志记录功能。</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor122"/>追踪模式演变</h2>
			<p>在前面的<a id="_idIndexMarker569"/>部分中，您可能已经注意到，您在本章的<em class="italic">在笔记本</em>部分中训练一个简单的 sklearn 模型中创建的<code>outputs</code>文件夹在您执行<code>complete</code>方法时被自动上传到运行中。为了避免上传那些过时的工件，你需要删除<code>outputs</code>文件夹:</p>
			<ol>
				<li value="1">在您的<code>chapter08.ipynb</code>笔记本中添加一个单元格，并使用<a id="_idIndexMarker570"/>下面的代码片段删除<code>outputs</code>文件夹:<pre>import shutil
try:
  shutil.rmtree("./outputs")
except FileNotFoundError: 
  pass</pre></li>
				<li>As a next step, you will refactor the training and evaluation code to a single method, passing in the <code>alpha</code> parameter and the <code>training</code> and <code>validation</code> datasets:<pre>from sklearn.linear_model import LassoLars
from sklearn.metrics import mean_squared_error
def train_and_evaluate(alpha, X_t, y_t, X_v, y_v):
  model = LassoLars(alpha=alpha)
  model.fit(X_t, y_t)
  predictions = model.predict(X_v)
  rmse = mean_squared_error(predictions, y_v, squared = False)
  range_y_validate = y_v.to_numpy().ptp()
  nrmse = rmse/range_y_validate
  print(f"NRMSE: {nrmse}")
  return model, nrmse
trained_model, model_nrmse = train_and_evaluate(0.1, 
                        X_train, y_train,
                        X_validate, y_validate) </pre><p>这段代码与您在<em class="italic">笔记本</em>部分中编写的代码完全相同。现在，您可以使用<code>train_and_evaluate</code>并为<code>alpha</code>参数传递不同的值来训练多个模型，这个过程被称为<em class="italic">超参数调整</em>。在该代码片段的最后一行，您可以获得对最终训练模型及其 NRMSE 度量的引用。</p><p class="callout-heading">重要说明</p><p class="callout">如果您得到如下错误:<code>NameError: name 'X_train' is not defined</code>，您将需要重新运行笔记本中定义了<code>X_train</code>、<code>y_train</code>、<code>X_validate</code>和<code>y_validate</code>变量的单元格。这表明 Python 内核已经重新启动，并且所有变量都已经从内存中丢失。</p><p>到目前为止，您已经重构了现有代码，并保持了相同的功能。要通过您在上一节中探索的<code>Run</code>类启用日志记录，您需要将对当前运行实例的引用传递给<code>train_and_evaluate</code>方法。</p></li>
				<li>在新的单元格中，添加<a id="_idIndexMarker571"/>下面的代码片段，它将覆盖现有的<code>train_and_evaluate</code>方法声明:<pre>def train_and_evaluate(<code>log</code> and <code>log_row</code> methods to log the NRMSE metric of the trained model.<p class="callout-heading">重要说明</p><p class="callout">如果您不能键入前面示例中显示的字母<em class="italic"> α </em>，您可以使用<em class="italic"> a </em>字符来代替。</p></pre></li>
				<li>Having this <code>train_and_evaluate</code> method, you can do a hyperparameter tuning and train<a id="_idIndexMarker572"/> multiple models for multiple values of the <code>α</code> (<code>alpha</code>) parameter, using the following code:<pre>from azureml.core import Workspace, Experiment
ws = Workspace.from_config()
exp = Experiment(workspace=ws, name="chapter08")
with exp.start_logging() as run:
    print(run.get_portal_url())
    for a in [0.001, 0.01, 0.1, 0.25, 0.5]:
        train_and_evaluate(run, a, 
                            X_train, y_train,
                            X_validate, y_validate)</pre><p>注意，我们没有调用<code>complete</code>方法，而是使用了<code>with .. as</code> Python 设计模式。随着<code>run</code>变量移出范围，它会自动标记为完成。</p></li>
				<li>使用<em class="italic">步骤 4 </em>中的<code>get_portal_url</code>，您打印了工作室的<code>log</code>方法调用的链接，而<code>α</code> ( <code>alpha</code>)参数是您使用<code>log_row</code>方法记录的。您应该会看到类似于<em class="italic">图 8.9 </em>所示的图表:</li>
			</ol>
			<div><div><img src="img/B16777_08_009.jpg" alt="Figure 8.9 – Evolution of the nrmse metric for the diabetes model&#13;&#10;" width="1650" height="635"/>
				</div>
			</div>
			<p class="figure-caption">图 8.9–糖尿病模型的 nrmse 指标的演变</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">在本节中，您只是在<code>Run</code>实例上存储指标，而不是实际训练的模型。您可以通过生成<code>.pkl</code>文件来存储生成的模型，然后使用<code>upload_file</code>方法将它上传到运行的工件中。在<a href="B16777_12_Final_VK_ePub.xhtml#_idTextAnchor171"> <em class="italic">第 12 章</em> </a>，<em class="italic">用代码</em>操作化模型中，您将了解 AzureML SDK 的模型注册功能，它提供了跟踪实际模型的卓越体验。</p>
			<p>在本节中，您<a id="_idIndexMarker573"/>看到了如何使用 AzureML SDK 启用度量日志记录。说到跟踪实验指标，数据科学界正在使用一个流行的开源框架 MLflow。在下一节中，您将了解如何使用该库来跟踪 AzureML 工作空间中的指标。</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor123"/>使用 MLflow 跟踪实验</h2>
			<p>MLflow 库是一个受欢迎的开源库，用于管理数据科学实验的生命周期。这个库允许您在本地或服务器上存储工件和度量。AzureML 工作区提供了一个 MLflow 服务器，您可以使用它来执行以下操作:</p>
			<ul>
				<li>通过<strong class="bold"> MLflow </strong> <strong class="bold">跟踪</strong>组件跟踪和记录实验指标。</li>
				<li>通过<strong class="bold"> MLflow </strong> <strong class="bold">项目</strong>组件在 AzureML 计算集群上编排代码执行(类似于你将在<a href="B16777_11_Final_VK_ePub.xhtml#_idTextAnchor160"> <em class="italic">第 11 章</em> </a>、<em class="italic">中看到的管道使用管道</em>)。</li>
				<li>管理 AzureML 模型注册中心的模型，你会在第十二章<a href="B16777_12_Final_VK_ePub.xhtml#_idTextAnchor171"><em class="italic"><em class="italic">中看到用代码</em>操作化模型。</em></a></li>
			</ul>
			<p>在本节中，您将重点关注用于跟踪指标的 MLflow 跟踪组件。下面的代码片段使用<code>MLflow</code>库来跟踪您在前一节中在名为<code>chapter08-mlflow</code>的实验下创建的<code>diabetes</code>模型的参数和指标:</p>
			<pre>import mlflow
def train_and_evaluate(alpha, X_t, y_t, X_v, y_v):
  model = LassoLars(alpha=alpha)
  model.fit(X_t, y_t)
  predictions = model.predict(X_v)
  rmse = mean_squared_error(predictions, y_v, squared = False)
  range_y_validate = y_v.to_numpy().ptp()
  nrmse = rmse/range_y_validate
  mlflow.log_metric("nrmse", nrmse)
  return model, nrmse
mlflow.set_experiment("chapter08-mlflow")
with mlflow.start_run():
    mlflow.sklearn.autolog()
    trained_model, model_nrmse = train_and_evaluate(0.1, 
                                    X_train, y_train,
                                    X_validate, y_validate)</pre>
			<p>MLflow Tracking <a id="_idIndexMarker577"/>组件的<a id="_idIndexMarker576"/>最广为人知的特性之一是它提供的自动记录功能。在您的训练代码之前调用<code>mlflow.sklearn.autolog()</code>方法能够自动记录<code>sklearn</code>度量、参数和生成的模型。类似于针对<code>sklearn</code>的<code>autolog</code>方法，有针对大多数常见训练框架的包，比如 PyTorch、fast.ai、Spark 等等。</p>
			<p>使用<code>log_metric</code>方法，您显式地要求 MLflow 库记录一个指标。在这种情况下，您将记录 NRMSE 度量，自动记录功能不会自动捕获该度量。</p>
			<p>正如您在<em class="italic">图 8.10 </em>中看到的，MLflow 跟踪组件在笔记本旁边的<code>mlruns</code>文件夹下的文件夹结构中记录所有工件和训练模型:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16777_08_010.jpg" alt="Figure 8.10 – Tracking metrics using the local FileStore mode of the MLflow Tracking component&#13;&#10;" width="1506" height="1125"/>
				</div>
			</div>
			<p class="figure-caption">图 8.10–使用 MLflow 跟踪组件的本地文件存储模式跟踪指标</p>
			<p>这是<a id="_idIndexMarker578"/>的默认设置，简称<code>local FileStore</code>。您可以将 AzureML workspace 用作<em class="italic">远程跟踪服务器</em>。为此<a id="_idIndexMarker579"/>，你需要使用<code>mlflow.set_tracking_uri()</code>方法连接到一个跟踪 URI。</p>
			<p>要启用 MLflow 到 AzureML 的集成，您需要确保您的环境具有<code>azureml-mlflow</code> Python 库。此包已经存在于 AzureML 计算实例中。如果您在 Databricks 工作空间上工作，您将需要使用<code>pip install azureml-mlflow</code>命令手动安装它。</p>
			<p>要获得跟踪 URI 并使用 AzureML 作为远程跟踪服务器运行相同的实验，请使用以下代码片段:</p>
			<pre>import mlflow
from azureml.core import Workspace
ws = Workspace.from_config()
<strong class="bold">mlflow.set_tracking_uri(ws.get_mlflow_tracking_uri())</strong>
mlflow.set_experiment("chapter08-mlflow")
with mlflow.start_run():
    mlflow.sklearn.autolog()
    trained_model, model_nrmse = train_and_evaluate(0.1, 
                                    X_train, y_train,
                                    X_validate, y_validate)</pre>
			<p><code>Workspace</code>类的<code>get_mlflow_tracking_uri</code>方法返回一个 1 小时内<a id="_idIndexMarker580"/>有效的 URL。如果您的实验花费了<a id="_idIndexMarker581"/>一个多小时来完成，您将需要生成一个新的 URI，并使用<code>set_tracking_uri</code>方法对其赋值，如前面的代码片段所示。</p>
			<p>您应该能够在 Studio 体验中看到运行和跟踪的指标，如<em class="italic">图 8.11 </em>所示:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16777_08_011.jpg" alt="Figure 8.11 – Metrics logged using the MLflow library with AzureML as the remote tracking server&#13;&#10;" width="1650" height="785"/>
				</div>
			</div>
			<p class="figure-caption">图 8.11–使用 MLflow 库和 AzureML 作为远程跟踪服务器记录的指标</p>
			<p>到目前为止，您已经在<a id="_idIndexMarker583"/> AzureML 工作空间中使用了<a id="_idIndexMarker582"/>计算实例，并且在<strong class="bold">笔记本</strong>内核中训练了 ML 模型。这种方法适用于小模型或基于<a id="_idIndexMarker584"/>样本数据的快速原型。在某些情况下，您将需要处理要求更高的工作负载，要么需要更大的内存，要么甚至需要在多个计算机节点上进行分布式培训。这可以通过将培训流程委托给您在第 4 章 、<em class="italic">配置工作空间</em>中创建的计算集群来实现。在下一节中，您将学习如何在 AzureML 计算集群中执行 Python 的<a id="_idTextAnchor124"/>脚本。</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor125"/>利用计算集群扩展培训流程</h1>
			<p>在<a href="B16777_07_Final_VK_ePub.xhtml#_idTextAnchor102"> <em class="italic">第七章</em> </a>，<em class="italic">AzureML Python SDK</em>中，你创建了一个名为<code>cpu-sm-cluster</code>的计算集群。在这个<a id="_idIndexMarker585"/>部分，您将<a id="_idIndexMarker586"/>提交一个要在该集群上执行的培训作业。为此，您需要创建一个将在远程计算目标上执行的 Python 脚本。</p>
			<p>导航到目前为止您一直使用的<code>chapter08</code>文件夹下的<code>greeter-job</code>。添加一个名为<code>greeter.py</code>的 Python 文件:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16777_08_012.jpg" alt="Figure 8.12 – Adding a simple Python script to execute on a remote compute cluster&#13;&#10;" width="659" height="563"/>
				</div>
			</div>
			<p class="figure-caption">图 8.12–添加要在远程计算集群上执行的简单 Python 脚本</p>
			<p>打开文件<a id="_idIndexMarker588"/>并在其中添加以下代码:</p>
			<pre>import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--greet-name', type=str, 
                    dest='name', help='The name to greet')
args = parser.parse_args()
name = args.name
print(f"Hello {name}!")</pre>
			<p>这个脚本使用来自<code>argparse</code>模块的<code>ArgumentParser</code>类来解析传递给脚本的参数。它试图定位一个<code>--greet-name</code>参数，并将发现的值赋给它返回的对象的<code>name</code>属性(<code>args.name</code>)。然后，它为给定的名字打印一条问候消息。要尝试该脚本，请打开终端并键入以下内容:</p>
			<pre>python greeter.py --greet-name packt</pre>
			<p>该命令将产生如图 8.13 所示的输出:</p>
			<div><div><img src="img/B16777_08_013.jpg" alt="Figure 8.13 – Testing the simple script you will execute on a remote compute&#13;&#10;" width="1286" height="456"/>
				</div>
			</div>
			<p class="figure-caption">图 8.13–测试您将在远程计算上执行的简单脚本</p>
			<p>为了<a id="_idIndexMarker589"/>在远程<a id="_idIndexMarker590"/>计算集群上执行这个简单的 Python 脚本，返回到<code>chapter08.ipynb</code>笔记本，添加一个新的单元格，并键入以下代码:</p>
			<pre>from azureml.core import Workspace, Experiment
from azureml.core import ScriptRunConfig
ws = Workspace.from_config()
target = ws.compute_targets['cpu-sm-cluster']
script = ScriptRunConfig(
    source_directory='greeter-job',
    script='greeter.py',
    compute_target=target,
    arguments=['--greet-name', 'packt']
)
exp = Experiment(ws, 'greet-packt')
run = exp.submit(script)
print(run.get_portal_url())
run.wait_for_completion(show_output=True)</pre>
			<p>在这段代码中，您正在<a id="_idIndexMarker591"/>执行以下操作:</p>
			<ol>
				<li value="1">获取一个对工作空间的引用<a id="_idIndexMarker592"/>,然后将一个对<code>cpu-sm-cluster</code>集群的引用赋给<code>target</code>变量。</li>
				<li>创建一个<code>ScriptRunConfig</code>来执行位于<code>greeter-job</code>文件夹中的<code>greeter.py</code>脚本。这个脚本将在传递了<code>--greet-name</code>和<code>packt</code>参数的<code>target</code>计算中执行，这两个参数将被连接起来，中间有一个空格。</li>
				<li>创建一个名为<code>greet-packt</code>的实验，您提交脚本配置以在这个实验下执行。方法<code>submit</code>创建了一个新的<code>Run</code>实例。</li>
				<li>You use the <code>get_portal_url</code> method to get the portal URL for the specific <code>Run</code> instance. You then call the <code>wait_for_completion</code> method, setting the <code>show_output</code> parameter to <code>True</code>. To wait for the run to complete, turn on verbose logging and print the logs in the output of the cell.<p class="callout-heading">重要说明</p><p class="callout">在 AzureML SDK 的第一个版本中，您应该使用<code>Estimator</code>类，而不是<code>ScriptRunConfig</code>，这是不推荐的。此外，对于特定的框架，有一些不推荐使用的专门的<code>Estimator</code>类，比如提供运行 TensorFlow 特定代码的方法的<code>TensorFlow</code>类。这种方法已经被弃用，取而代之的是您将在接下来的<em class="italic">理解执行环境</em>部分中读到的环境。尽管如此，这些被否决的类的语法和参数与<code>ScriptRunConfig</code>非常相似。您应该能够毫无问题地阅读不推荐使用的代码。如果你在认证考试中看到一个老问题提到了这些被否决的类，请记住这一点。</p></li>
			</ol>
			<p>您已经成功地<a id="_idIndexMarker593"/>完成了一次运行的远程<a id="_idIndexMarker594"/>执行。在下一节中，您将探索刚刚完成的运行的日志，并更好地理解 AzureML 的机制。</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>探索运行的输出和日志</h2>
			<p>在<a id="_idIndexMarker595"/>这一部分，您将探索在<em class="italic">使用计算集群</em>部分执行的<a id="_idIndexMarker596"/>远程执行的输出。这将让您深入了解 AzureML 平台是如何工作的，并帮助您解决在开发培训脚本时可能会遇到的错误。</p>
			<p>使用<code>get_portal_url</code>方法打开您在前面部分打印的链接，或者导航到<code>greet-packt</code>实验，并打开<strong class="bold">运行 1 </strong>。导航到运行的<strong class="bold">输出+日志</strong>选项卡:</p>
			<div><div><img src="img/B16777_08_014.jpg" alt="Figure 8.14 – Outputs + logs tab of an Experiment's run&#13;&#10;" width="1619" height="924"/>
				</div>
			</div>
			<p class="figure-caption">图 8.14–实验运行的输出+日志选项卡</p>
			<p>这些<a id="_idIndexMarker597"/>输出对于排除潜在的<a id="_idIndexMarker598"/>脚本错误非常有帮助。<code>azureml-logs</code>文件夹包含平台日志。这些文件中的大部分是来自底层引擎的日志。包含脚本标准输出的日志是<code>70_driver_log.txt</code>。这是您需要首先查看的日志文件，以便对潜在的脚本执行失败进行故障排除。如果你有多个进程，你会看到多个带有数字后缀的文件，比如<code>70_driver_log_x.txt</code>。</p>
			<p><code>logs</code>文件夹是一个特殊的文件夹，您可以在脚本中使用它来输出日志。脚本在该文件夹中写入的所有内容都将自动上传到您在<em class="italic">跟踪实验中的指标</em>部分看到的运行的<code>outputs</code>文件夹中。AzureML 还输出你在图 8.14 中看到的<code>azureml</code>文件夹下的系统日志。</p>
			<p>导航到<code>ScriptRunConfig</code>。该目录最多可包含 300 MB 和 2，000 个文件。如果需要更多脚本文件，可以使用数据存储。如果您编辑了<code>.py</code>脚本中的脚本文件和一个<code>.amltmp</code>文件，该文件是笔记本编辑器使用的临时文件:</p>
			<div><div><img src="img/B16777_08_015.jpg" alt="Figure 8.15 – Temporary file uploaded in the snapshot&#13;&#10;" width="925" height="452"/>
				</div>
			</div>
			<p class="figure-caption">图 8.15–快照中上传的临时文件</p>
			<p>为了避免<a id="_idIndexMarker599"/>创建不想要的文件的快照，您可以在脚本旁边的文件夹中添加一个<code>.gitignore</code>或<code>.amlignore</code>文件，并排除那些<a id="_idIndexMarker600"/>遵循特定模式的文件。导航到<code>greeter-job</code>文件夹中的<code>.amlignore</code>文件，如果创建文件夹时该文件尚未添加，如图<em class="italic">图 8.16 </em>所示:</p>
			<div><div><img src="img/B16777_08_016.jpg" alt="Figure 8.16 – Adding the .amlignore file to exclude temp files from being added to the snapshot&#13;&#10;" width="585" height="512"/>
				</div>
			</div>
			<p class="figure-caption">图 8.16–添加。用于排除临时文件添加到快照的 amlignore 文件</p>
			<p>打开<code>.amlignore</code>文件，在其中添加以下行，以排除所有扩展名为. a <code>mltmp</code>文件<a id="_idIndexMarker601"/>的文件和您<a id="_idIndexMarker602"/>正在编辑的<code>.amlignore</code>文件:</p>
			<pre>*.amltmp
.amlignore</pre>
			<p>打开<code>chapter08.ipynb</code>笔记本，添加一个单元格，并添加以下代码以重新提交脚本:</p>
			<pre>from azureml.widgets import RunDetails
run = exp.submit(script)
RunDetails(run).show()</pre>
			<p>您正在重新提交您在上一步中创建的<code>ScriptRunConfig</code>的现有实例。如果你再次重启<a id="_idIndexMarker603"/><code>exp</code>和<code>script</code>变量。</p>
			<p>这一次，您将使用 AzureML SDK 提供的<code>RunDetails</code>小部件。这是一个<strong class="bold">Jupyter</strong>T3】笔记本 widget <a id="_idIndexMarker604"/>用来查看一个脚本执行的进度。这个小部件是异步的，在运行结束之前一直提供更新。</p>
			<p>如果要打印运行状态，包括日志文件的内容，可以使用下面的代码片段:</p>
			<pre>run.get_details_with_logs()</pre>
			<p>运行完成后，导航到该运行的<strong class="bold">快照</strong>选项卡。您会注意到临时文件不见了。</p>
			<p>请注意，这次运行的<a id="_idIndexMarker605"/>执行花费的时间要少得多。导航<a id="_idIndexMarker606"/>到运行日志。注意这次日志中没有出现<code>20_image_build_log.txt</code>文件，如图<em class="italic">图 8.17 </em>所示:</p>
			<div><div><img src="img/B16777_08_017.jpg" alt="Figure 8.17 – Faster run execution and missing the 20_image_build_log.txt file&#13;&#10;" width="1650" height="766"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">图 8.17–更快的运行执行和缺少 20_image_build_log.txt 文件</p>
			<p>这是用于执行脚本的环境的<strong class="bold"> Docker </strong>映像构建日志。这是一个非常耗时的过程。这些图像被构建并存储在与 AzureML 工作空间一起部署的容器<a id="_idIndexMarker607"/>注册表中。由于<a id="_idIndexMarker608"/>您没有修改执行环境，AzureML 在后续运行中重用了之前创建的映像。在下一节中，您将更好地理解什么是环境以及如何修改它。</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor127"/>了解执行环境</h2>
			<p>在 AzureML <a id="_idIndexMarker609"/>工作空间术语中，<strong class="bold">环境</strong>意味着执行脚本所需的软件需求的<a id="_idIndexMarker610"/>列表。这些软件要求包括以下内容:</p>
			<ul>
				<li>您的代码需要安装的 Python 包</li>
				<li>代码中可能需要的环境变量</li>
				<li>各种辅助软件，如 GPU 驱动程序或<strong class="bold"> Spark </strong>引擎，它们可能是代码正常运行所必需的</li>
			</ul>
			<p>环境是由<em class="italic">管理的</em>和<em class="italic">版本化的</em>实体，支持跨不同计算目标的可复制、可审计和可移植的 ML 工作流。</p>
			<p>AzureML 提供了一个由<code>AzureML-Minimal</code>管理的环境列表，其中包含了最小的 Python 包需求，以支持您在<em class="italic">跟踪模型演化</em>部分看到的运行跟踪。另一方面，<code>AzureML-AutoML</code>环境是一个更大的管理环境，为您的脚本提供了运行 AutoML 实验所需的 Python 包。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">AzureML 服务不断更新，旧的环境被弃用，取而代之的是新的环境。即使在 AzureML Studio 的 web 界面中看不到<code>AzureML-Minimal</code>和<code>AzureML-AutoML</code>环境，它们也应该可供您使用。如果遇到任何错误，请从本章的 GitHub 库下载最新代码。</p>
			<p>在<em class="italic">图 8.18 </em>中，您可以看到<code>AzureML-AutoML</code>环境与极简<code>AzureML-Minimal</code>环境相比有多少额外的软件包可用:</p>
			<div><div><img src="img/B16777_08_018.jpg" alt="Figure 8.18 – Python package difference between the AzureML-Minimal and &#13;&#10;AzureML-AutoML environments&#13;&#10;" width="1641" height="1004"/>
				</div>
			</div>
			<p class="figure-caption">图 8.18–azure ml-Minimal 和 AzureML-AutoML 环境之间的 Python 包差异</p>
			<p><em class="italic">图 8.18 </em>显示了<code>AzureML-Minimal</code>环境<em class="italic">版本 46 </em>与<code>AzureML-AutoML</code>环境<em class="italic">版本 61 </em>的<code>Conda</code> <a id="_idIndexMarker612"/>环境定义。<code>Conda</code>获取这个 YAML <a id="_idIndexMarker614"/>文件并安装 Python <em class="italic">版本 3.6.2 </em>和<code>- pip:</code>符号下面列出的<code>pip</code>需求。正如您所注意到的，所有的<code>pip</code>包都有使用<code>==x.x.x</code>符号定义的特定版本。这意味着，每次使用这个 YAML 文件时，都会安装相同的 Python 包，这有助于为实验的可重复性保持一个稳定的环境。</p>
			<p>创建环境时安装软件包是一个耗时的过程。这就是您在上一节中看到的 Docker 技术派上用场的地方。Docker 是一个开源项目，用于将应用程序自动部署为可移植的、自给自足的容器。这意味着不用在每次运行脚本时都创建一个新的环境，而是可以创建一个 Docker 容器映像，也称为 Docker 映像，其中所有 Python 依赖项都在映像的中<em class="italic">烘焙一次。您可以从那时起重用该映像来启动一个容器并执行您的脚本。事实上，所有 AzureML 管理的环境都可以作为 Docker 映像在<code>viennaglobal.azurecr.io</code>容器注册表中获得。</em></p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">尽管为您的环境创建 Docker 映像很常见，但这并不总是必需的。如果在本地计算机或 AzureML 计算实例上运行实验，可以使用现有的<code>Conda</code>环境，避免使用 Docker 映像。如果您计划使用一个远程计算，例如一个 AzureML 计算集群，那么 Docker 映像是必需的，因为否则，您无法确保所提供的机器将拥有代码执行所需的所有软件组件。</p>
			<p>为了更好地理解你<a id="_idIndexMarker615"/>到目前为止读到的内容，你将使用<code>AzureML-Minimal</code>环境重新运行前面的<code>greeter.py</code>脚本:。</p>
			<ol>
				<li value="1">In your notebook, add a new cell and add the following code:<pre>from azureml.core import Environment
minimal_env =\
Environment.get(ws, name="AzureML-Minimal")
print(minimal_env.name, minimal_env.version)
print(minimal_env.Python.conda_dependencies.serialize_to_string())</pre><p>这段代码检索由<code>ws</code>变量引用的 AzureML 工作空间中定义的<code>AzureML-Minimal</code>环境，该环境在笔记本中的前面被初始化。然后，它打印环境的名称和版本以及您在<em class="italic">图 8.18 </em>中看到的<code>Conda</code>环境 YAML 定义。</p></li>
				<li>添加一个新的<a id="_idIndexMarker616"/>单元格，并键入以下内容:<pre>from azureml.core import Experiment, ScriptRunConfig
target = ws.compute_targets['cpu-sm-cluster']
script = ScriptRunConfig(
    source_directory='greeter-job',
    script='greeter.py',
    <code>environment</code> argument in the <code>ScriptRunConfig</code> constructor.</pre></li>
			</ol>
			<p>观察运行执行的输出。如果你仔细看，你会看到下面一行:</p>
			<pre>Status: Downloaded newer image for viennaglobal.azurecr.io/azureml/azureml_&lt;something&gt;:latest</pre>
			<p>这一行是<code>azureml-logs</code>中<code>55_azureml-execution-something.txt</code>文件的一部分。这一行通知您它正在从<code>viennaglobal</code>容器注册中心提取一个 Docker 映像，该注册中心属于<strong class="bold">微软</strong>。与此相反，在前面的部分中，在没有指定管理环境的运行中，图像是从您自己的容器注册表中提取的——与您的 AzureML 工作空间一起提供的那个，如图 8.19 中的<em class="italic">所示:</em></p>
			<div><div><img src="img/B16777_08_019.jpg" alt="Figure 8.19 – Image pulled from your own container registry &#13;&#10;in the execution without using a curated environment&#13;&#10;" width="1650" height="218"/>
				</div>
			</div>
			<p class="figure-caption">图 8.19–在执行过程中从您自己的容器注册表中提取的图像，没有使用管理环境</p>
			<p>这一观察将我们带到了下一种 AzureML 支持的环境，即系统管理的环境——这将在下一节中探讨。</p>
			<h3>定义系统管理的环境</h3>
			<p>S <code>Conda</code>环境定义或者一个简单的<code>pip</code> <code>requirements.txt</code>文件。在上一节中，您没有在<code>ScriptRunConfig</code>构造函数中定义<code>environment</code>参数，而是使用一个默认的<code>Conda</code>环境定义文件来创建系统管理的环境，该环境存储在与 AzureML 工作空间相关联的<strong class="bold"> Azure </strong> <strong class="bold">容器注册表</strong>中。让我们明确地创建一个系统管理的环境来使用您的代码:</p>
			<ol>
				<li value="1">导航到 AzureML 工作区的<strong class="bold">笔记本</strong>部分和<strong class="bold">文件</strong>树形视图。</li>
				<li>Click on the three dots of the <code>greeter-job</code> folder to open the context menu (or just right-click on the name) and select the <code>greeter-banner-job</code>, as seen in the following screenshot: <div><img src="img/B16777_08_020.jpg" alt="" width="1246" height="558"/></div><p class="figure-caption">图 8.20–将迎宾-工作文件夹复制为一个名为迎宾-横幅-工作的新文件夹</p></li>
				<li>打开<a id="_idIndexMarker618"/>新文件夹中的<code>greeter.py</code>文件，将代码改为:<pre>import argparse
<code>Banner</code> method from the <code>asciistuff</code> open source Python package. This method is used in the last print. This will output a fancy <code>os</code> module, which allows you to read the environment variables using the <code>os.environ.get()</code> method. The <a id="_idIndexMarker619"/>code tries to read the environment variable named <code>GREET_HEADER</code>, and if it is not defined, the default value, <code>Message:</code>, is assigned to the <code>greet_header</code> variable, which is printed before the banner message.<p class="callout-heading">重要说明</p><p class="callout">如果您试图在 AzureML <em class="italic">计算实例</em>的终端中执行修改后的<code>greeter.py</code>，它将会失败，因为您没有安装<code>asciistuff</code>包。要在您的计算实例中安装它，您可以使用<code>pip install asciistuff</code>命令。</p></pre></li>
				<li>The <code>asciistuff</code> package is a pip package that you will need to install in your executing environment for your code to work. To define that code dependency, you are going to create a <code>Conda</code> environment definition file. In the <code>chapter08</code> folder, add a new file named <code>greeter-banner-job.yml</code>. Add the following content to it:<pre>name: banner-env
dependencies:
- python=3.6.2
- pip:
  - asciistuff==1.2.1 </pre><p>这个 YAML 文件定义了一个新的<code>Conda</code>环境，命名为<code>banner-env</code>，基于 Python <em class="italic">版本 3.6.2 </em>，安装了<code>pip</code>包<code>asciistuff</code>的<em class="italic"> 1.2.1 </em>版本。</p></li>
				<li>To create an AzureML environment based on the <code>Conda</code> environment you just defined, you need to go to the <code>chapter08.ipynb</code> notebook, add a cell, and type the following code:<pre>from azureml.core import Environment
banner_env = Environment.from_conda_specification(
                 name = "banner-env",
                 file_path = "greeter-banner-job.yml")
banner_env.environme<a id="_idTextAnchor128"/>nt_variables["GREET_HEADER"] = \
                                 "Env. var. header:"</pre><p>这段代码使用<code>Environment</code>类的<code>from_conda_specification()</code>方法创建了一个名为<code>banner-env</code>的 AzureML 环境。<code>banner_env</code>变量包含新定义的环境。在后续行中，您定义了<code>GREET_HEADER</code>环境变量，并分配了<code>Env. var. header:</code>值。这个环境没有在工作区中注册，它<a id="_idIndexMarker620"/>不需要注册就可以使用。如果您确实希望将它保存在工作区中，以便能够以引用管理的环境的相同方式引用它，并且您希望保留它的版本，那么您可以使用<code>register()</code>方法，使用<code>banner_env.register(ws)</code>代码，其中您作为参数传递一个变量，该变量指向将注册环境的工作区。</p><p class="callout-heading">重要说明</p><p class="callout">如果您计划在本地计算机上开始工作，然后在更强大的计算集群上扩展，那么您应该考虑创建并注册一个系统管理的环境，其中包含您所需的所有 Python 包。这将允许您在本地和远程执行中重用它。</p></li>
				<li>要使用这个新定义的环境，在笔记本中添加一个新的单元格，并键入以下代码:<pre>script = ScriptRunConfig(
    source_directory='<code>ScriptRunConfig:</code>:</pre><ul><li>源目录<a id="_idIndexMarker621"/>已经更改为指向<code>greeter-banner-job</code>文件夹，其中包含更新后的脚本。</li><li>环境参数被指定，传递您自己定义的<code>banner_env</code>环境。</li></ul></li>
			</ol>
			<p>该实验的输出应该类似于<em class="italic">图 8.21 </em>中所示:</p>
			<div><div><img src="img/B16777_08_021.jpg" alt="Figure 8.21 – Header text read from an environment variable and banner-based hello greeting&#13;&#10;" width="1206" height="688"/>
				</div>
			</div>
			<p class="figure-caption">图 8.21–从环境变量中读取的标题文本和基于横幅的问候</p>
			<p>正如您注意到的，在您刚刚创建的<a id="_idIndexMarker622"/>系统管理的环境中，您没有指定任何关于基本操作系统的内容(例如，它的<code>Conda</code>是否已经安装在基本系统中。您只是指定了安装的<code>Conda</code>依赖项。如果您想要更大的灵活性，您可以显式地配置环境并手动安装所有的软件需求。这些环境被称为<a id="_idIndexMarker623"/>用户管理的环境<strong class="bold">。通常，这些用户管理的环境是定制的 Docker 映像，封装了所有必需的依赖项。例如，您可能需要 PyTorch 框架的定制版本，甚至是 Python 的定制版本。在这些情况下，您负责安装 Python 包并配置整个环境。出于本书的目的，您将使用管理的或系统管理的环境。</strong></p>
			<p>到目前为止，您已经探索了如何在远程计算机上执行简单的 greeter Python 应用程序。在下一节中，您将继续您的<code>diabetes</code>模型训练<a id="_idTextAnchor129"/>并了解如何在远程计算集群上训练该模型。</p>
			<h2 id="_idParaDest-124">在计算集群上训练糖尿病模型</h2>
			<p>在前面的<a id="_idIndexMarker624"/>部分中，您学习了如何通过从笔记本中调用<code>exp.submit(script)</code>方法在远程计算集群上运行脚本，如图<em class="italic">图 8.22 </em>所示:</p>
			<div><div><img src="img/B16777_08_022.jpg" alt="Figure 8.22 – Executing a script on a compute cluster&#13;&#10;" width="1650" height="1228"/>
				</div>
			</div>
			<p class="figure-caption">图 8.22–在计算集群上执行脚本</p>
			<p>当您调用<code>submit</code>方法时，以下动作在幕后发生:</p>
			<ol>
				<li value="1">AzureML SDK 进行了一次<code>ScriptRunConfig</code>执行。</li>
				<li>AzureML 工作区检查了<code>Environment</code>的 Docker 图像是否已经存在。如果它不存在，它是在 Azure Container Registry 中创建的。</li>
				<li>该作业被提交给计算集群，该集群可以扩展以分配一个计算节点。在新分配的计算节点中执行以下操作:</li>
			</ol>
			<ol>
				<li value="1">带有环境的 Docker 映像被拉至计算节点。</li>
				<li><code>ScriptRunConfig</code>引用的脚本加载在正在运行的 Docker 实例中。</li>
				<li>指标和元数据存储在 AzureML 工作空间中。</li>
				<li>输出存储在存储帐户中。</li>
			</ol>
			<p>在<em class="italic">使用笔记本</em>培训简单的 sklearn 模型部分，您在<code>chapter08.ipynb</code>笔记本中创建了一个培训<a id="_idIndexMarker625"/>脚本。培训发生在 Jupyter 服务器的进程中，在您的计算实例中。要在计算集群中运行相同的培训，您需要执行以下操作:</p>
			<ol>
				<li value="1">将代码移动到 Python 脚本文件中。</li>
				<li>创建一个 AzureML 环境来运行培训。</li>
				<li>在实验中提交。</li>
			</ol>
			<p>在接下来的小节中，您将看到如何转换您在<em class="italic">跟踪模型演进</em>小节中使用的脚本，以便能够在远程计算集群上执行它。</p>
			<h3>将代码移动到 Python 脚本文件中</h3>
			<p>如果您查看您在<em class="italic">跟踪模型演进</em>部分创建的<a id="_idIndexMarker626"/>脚本，在进行培训的代码中，您使用了<code>run</code>变量来记录指标。这个变量引用了您在调用<code>exp.start_logging()</code>时得到的<code>Run</code>对象。在上一节中，您了解了在实验中提交的<code>ScriptRunConfig</code>，并返回了<code>Run</code>类的一个实例。该实例是在计算实例的笔记本中创建的。在远程集群上执行的脚本文件如何访问同一个<code>Run</code>对象？</p>
			<p>AzureML 的<code>Run</code>类提供了一个名为<code>get_context()</code>的方法，返回当前的服务执行上下文。在<code>ScriptRunConfig</code>的例子中，这个执行上下文与您调用<code>exp.submit(script)</code>时创建的<code>Run</code>相同:</p>
			<pre>from azureml.core.run import Run
run = Run.get_context()</pre>
			<p>除了<code>run</code>变量之外，在训练脚本中，还有<code>ws</code>变量，它是对 AzureML 工作空间的引用。您使用该变量来访问<code>diabetes</code>数据集。您通过调用<code>from_config</code>方法获得了对工作区的引用。这种方法的问题是，第一次调用该方法时，您需要手动验证并授权计算机代表您访问工作区。这在远程计算上是不可行的。</p>
			<p>通过在实验属性中导航，然后导航到该实验的工作区属性，<code>run</code>变量使您能够访问相应的工作区:</p>
			<pre>ws = run.experiment.workspace</pre>
			<p>不过，对于这些代码行，有一个<a id="_idIndexMarker627"/>警告。您的代码假设 Python 脚本通过<code>ScriptRunConfig</code>提交。如果您在终端中本地运行 Python 脚本，使用以下命令行，您将得到一个错误:</p>
			<pre>python training.py --alpha 0.1</pre>
			<p><code>get_context()</code>方法将返回一个<code>_OfflineRun</code>类的对象，它继承自<code>Run</code>类。这个类提供了您在实验中的<em class="italic">跟踪度量</em>部分看到的所有日志记录功能，但是它没有将度量或者工件上传到工作区，而是在终端中打印出尝试。显然，没有与该运行相关的实验，这将导致脚本抛出一个错误。因此，您需要使用到目前为止一直使用的<code>from_config()</code>方法来检索工作空间引用。由于终端是计算实例的一部分，脚本将执行传递您的凭证，而不会提示您进行身份验证，您将在本节的后面看到这一点。如果您在本地计算机上运行这段代码，您将需要对您的设备进行身份验证，正如您在第 7 章 、<em class="italic">AzureML Python SDK</em>的<a href="B16777_07_Final_VK_ePub.xhtml#_idTextAnchor102"> <em class="italic">部分的<em class="italic">从您的设备进行身份验证中所看到的。</em></em></a></p>
			<p>允许您在终端中脱机运行和在计算集群中提交的完整代码如下:</p>
			<pre>from azureml.core import Workspace
from azureml.core.run import Run, _OfflineRun
run = Run.get_context()
ws = None
if type(run) == _OfflineRun:
    ws = Workspace.from_config()
else:
    ws = run.experiment.workspace</pre>
			<p>这些是您需要对您的脚本进行的唯一的<a id="_idIndexMarker628"/>更改，以提交它用于远程执行并利用 AzureML SDK 功能。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">Python 开发人员通常使用一个<code>_</code>作为他们想要标记为内部的类、属性或方法的前缀。这意味着标记的代码是供<code>SDK</code>库中的类使用的，不应该被外部开发人员使用。标记的代码将来可能会在没有任何警告的情况下更改。使用以<code>_</code>前缀开头的类被认为是一种不好的做法。尽管如此，<code>_OfflineRun</code>类在 AzureML SDK 的公共示例中被广泛使用，并且可以安全使用。</p>
			<p>让我们在您的工作区中进行这些更改。在文件树中，在<code>chapter08</code>下创建一个名为<code>diabetes-training</code>的文件夹，并在其中添加一个<code>training.py</code>文件，如图<em class="italic">图 8.23 </em>所示:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16777_08_023.jpg" alt="Figure 8.23 – Creating the training script for the remote diabetes model training&#13;&#10;" width="561" height="494"/>
				</div>
			</div>
			<p class="figure-caption">图 8.23–为远程糖尿病模型培训创建培训脚本</p>
			<p>在<code>training.py</code>脚本中添加以下<a id="_idIndexMarker629"/>代码块。您可以直接从本章的<em class="italic">技术需求</em>一节中提到的 GitHub 库下载这些代码，而不是键入所有这些代码:</p>
			<pre>from sklearn.linear_model import LassoLars
from sklearn.metrics import mean_squared_error
from azureml.core import Workspace
from azureml.core.run import Run, _OfflineRun
import argparse
import os
import joblib</pre>
			<p>这些是脚本文件中需要的所有导入。将所有的<code>import</code>语句放在脚本文件的顶部是一个很好的做法，这样可以很容易地发现代码正确执行所需的模块。如果您使用<code>flake8</code>来 lint 您的代码库，如果您不遵循这个最佳实践，它将会抱怨:</p>
			<pre>parser = argparse.ArgumentParser()
parser.add_argument('--alpha', type=float, 
                  dest='<strong class="bold">alpha</strong>', help='The alpha parameter')
args = parser.parse_args()</pre>
			<p>这个脚本文件需要一个<code>--alpha</code>参数传递给它。在这个代码块中，使用您在<em class="italic">使用计算集群</em>部分看到的<code>argparse</code>模块解析这个参数，并且将<code>float</code>值赋给<code>args.alpha</code>变量，因为它是在<code>dest</code>参数中指定的。如果您向脚本传递未定义的参数，<code>parse_args</code>方法将抛出<a id="_idIndexMarker630"/>错误。有些人更喜欢使用<code>args, unknown_args = parser.parse_known_args()</code>而不是这个代码块的第四行，这允许脚本执行，即使它收到的参数比预期的多，在<code>unknown_args</code>变量中分配未知的参数:</p>
			<pre>run = Run.get_context()
ws = None
if type(run) == _OfflineRun:
    ws = Workspace.from_config()
else:
    ws = run.experiment.workspace</pre>
			<p>在这个代码块中，您使用在本节开始时看到的代码片段获得了对<code>Run</code>对象和<code>Workspace</code>的引用。一旦获得了对<code>Workspace</code>的引用，就可以加载<code>diabetes</code>数据集，如下一个脚本块所示:</p>
			<pre>diabetes_ds = ws.datasets['diabetes']
training_data, validation_data = \
               diabetes_ds.random_split(
                            percentage = 0.8, <strong class="bold">seed</strong>=1337)
X_train = training_data.drop_columns('target') \
                       .to_pandas_dataframe()
y_train = training_data.keep_columns('target') \
                       .to_pandas_dataframe()
X_validate = validation_data.drop_columns('target') \
                            .to_pandas_dataframe()
y_validate = validation_data.keep_columns('target') \
                            .to_pandas_dataframe()</pre>
			<p>在这个模块中，您将获得一个对<code>diabetes</code>数据集的引用，并将其拆分为所需的<code>X_train</code>、<code>y_train</code>、<code>X_validate</code>和<code>y_validate</code>熊猫数据帧，您在本章的<em class="italic">在笔记本</em>部分中培训一个简单的 sklearn 模型时看到了这些数据帧。注意，您在<code>random_split</code>方法中指定了<code>seed</code>参数。这个<code>seed</code>参数用于初始化由<code>split</code>方法使用的底层随机函数的状态，以便<a id="_idIndexMarker631"/>从数据集中随机选择行。通过这样做，随机函数将在每次被调用时生成相同的随机数。这意味着每次运行脚本时,<code>training_data</code>和<code>validation_data</code>都是相同的。拥有相同的训练和验证数据集将有助于正确比较具有不同<code>alpha</code>参数的相同脚本的多次执行:</p>
			<pre>def train_and_evaluate(run, alpha, X_t, y_t, X_v, y_v):
  model = LassoLars(alpha=alpha)
  model.fit(X_t, y_t)
  predictions = model.predict(X_v)
  rmse = mean_squared_error(predictions,y_v,squared=False)
  range_y_validate = y_v.to_numpy().ptp()
  nrmse = rmse/range_y_validate
  run.log("nrmse", nrmse)
  run.log_row("nrmse over α", α=alpha, nrmse=nrmse)
  return model, nrmse</pre>
			<p>在这个代码块中，您定义了<code>train_and_evaluate</code>方法，这与本章的<em class="italic">跟踪模型演化</em>部分中使用的方法相同:</p>
			<pre>model, nrmse = train_and_evaluate(run, args.alpha,
                  X_train, y_train, X_validate, y_validate)</pre>
			<p>在方法<a id="_idIndexMarker632"/>定义之后，您调用训练过程，传递所有必需的参数:</p>
			<pre>os.makedirs('./outputs', exist_ok=True)
model_file_name = 'model.pkl'
joblib.dump(value=model, filename=
           os.path.join('./outputs/',model_file_name))</pre>
			<p>最后一个代码块将模型存储在脚本位置旁边的<code>outputs</code>文件夹中。</p>
			<p>您可以在本地计算实例上运行该脚本，您会注意到模型按照预期进行了训练，并且指标被记录在终端中，如图 8.24 中的<em class="italic">所示。这是您之前读到的<code>_OfflineRun</code>类的预期行为:</em></p>
			<div><div><img src="img/B16777_08_024.jpg" alt="Figure 8.24 – Running the training script locally&#13;&#10;" width="1650" height="120"/>
				</div>
			</div>
			<p class="figure-caption">图 8.24–在本地运行训练脚本</p>
			<p>到目前为止，您已经创建了培训脚本。在下一节中，您将创建 AzureML 环境，该环境将包含在远程计算上执行该脚本所需的所有依赖项。</p>
			<h3>创建 AzureML 环境来运行培训脚本</h3>
			<p>您在<em class="italic">跟踪模型演化</em>部分创建的训练脚本<a id="_idIndexMarker633"/>使用了<code>scikit-learn</code>库，也称为<code>sklearn</code>。你在笔记本体验中使用的 Jupyter 内核已经安装了<code>sklearn</code>库。要查看当前安装在内核中的版本，请转到<code>chapter08.ipynb</code>笔记本，并在新的单元格中添加以下代码片段:</p>
			<pre>!pip show scikit-learn</pre>
			<p>该命令将使用 Python 的<code>pip</code>包管理器来显示当前安装的<code>scikit-learn</code>包的详细信息，如图<em class="italic">图 8.25 </em>所示:</p>
			<div><div><img src="img/B16777_08_025.jpg" alt="Figure 8.25 – Package information for the installed scikit-learn library&#13;&#10;" width="1089" height="464"/>
				</div>
			</div>
			<p class="figure-caption">图 8.25–已安装的 scikit-learn 库的包信息</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">如果不确定库名，可以使用<code>pip freeze</code>命令获得当前 Python 环境中已安装的包的完整列表。</p>
			<p>您还可以使用<code>sklearn.__version__</code>属性在 Python 脚本中找到已安装库的<a id="_idIndexMarker634"/>版本(注意两个下划线)。在新的笔记本单元格中，添加以下几行 Python 代码:</p>
			<pre>import sklearn
print(sklearn.__version__)</pre>
			<p>您应该能够在输出中看到完全相同的版本。大多数 Python SDKs 和库都有这个<code>__version__</code>属性，比如 PyTorch 和 TensorFlow 框架。</p>
			<p>有两种方法安装<code>scikit-learn</code>包；作为<code>Conda</code>套装或<code>pip</code>套装。<code>Conda</code>提供了 Python 包的精选列表，这是推荐的方法。在<em class="italic">理解执行环境</em>部分，您看到了如何使用<code>Conda</code>规范文件创建环境。在本节中，您将学习一种不同的<a id="_idIndexMarker635"/>方法，在 Python 代码中创建环境。在<code>chapter08.ipynb</code>笔记本中添加一个新单元格，并键入以下内容:</p>
			<pre>from azureml.core import Environment
from azureml.core.conda_dependencies import CondaDependencies 
import sklearn
diabetes_env = Environment(name="diabetes-training-env")
diabetes_env.Python.conda_dependencies = CondaDependencies()
diabetes_env.Python.conda_dependencies.add_conda_package(
                   f"scikit-learn=={sklearn.__version__}")
diabetes_env.python.conda_dependencies.add_pip_package("azureml-dataprep[pandas]")</pre>
			<p>在前面的代码片段中，您创建了一个新的系统管理的环境，然后使用<code>add_conda_package</code>添加特定版本的<code>scikit-learn</code>。您还可以使用<code>add_pip_package</code>来添加<code>azureml-dataprep[pandas]</code>包，这是在<code>training.py</code>脚本中使用<code>to_pandas_dataframe</code>方法所必需的。您可以添加额外的 pip 包，比如之前安装的<code>asciistuff</code>包。您可以使用<code>CondaDependencies</code>类的<code>create</code>方法，而不是使用<code>add_pip_package</code>方法一次添加一个包，如下面的代码片段所示:</p>
			<pre>diabetes_env.Python.conda_dependencies = \
CondaDependencies.create(
      conda_packages=[
                   f"scikit-learn=={sklearn.__version__}"],
      pip_packages=["azureml-defaults", "azureml-dataprep[pandas]"])</pre>
			<p>您可以通过将多个包添加到<code>conda_packages</code>和<code>pip_packages</code>阵列中来请求它们出现在环境中。注意，因为您没有将包添加到默认的<code>CondaDependencies</code>中，所以您需要手动包含<code>training.py</code>脚本访问<code>azureml.core</code>模块所需的<code>azureml-defaults</code>包。</p>
			<p>你可能想知道<a id="_idIndexMarker636"/>为什么我们没有在 Python 依赖中定义<code>joblib</code>。<code>scikit-learn</code>包依赖于<code>joblib</code>包，它会自动安装到环境中。如果需要，可以使用以下代码在依赖项列表中显式指定它:</p>
			<pre>import joblib
diabetes_env.Python.conda_dependencies.add_pip_package(f"joblib=={joblib.__version__}")</pre>
			<p class="callout-heading">重要说明</p>
			<p class="callout">尽管指定要添加到环境中的包的版本不是强制性的，但这是一个好的做法。如果你写了<code>add_conda_package("scikit-learn")</code>，跳过指定包的版本，AzureML 会认为你指的是最新的版本。第一次使用 AzureML 中的环境时，会创建 Docker 映像，安装 Docker 映像创建时最新版本的<code>scikit-learn</code>包。该版本可能比您用来创建脚本的版本更新，并且可能与您编写的代码不兼容。尽管较小的版本差异可能不会影响您的代码，但主要版本可能会引入重大变化，正如 TensorFlow 从<em class="italic">版本 1 </em>迁移到<em class="italic">版本 2 </em>时所做的那样。</p>
			<p>如果你不想用你的代码依赖创建一个新的环境，你可以使用 AzureML 管理的环境。您可以选择高度专业化的基于 GPU 的<code>AzureML-Scikit-learn0.24-Cuda11-OpenMpi4.1.0-py36</code>环境，也可以使用更通用的<code>AzureML-Tutorial</code>管理的<a id="_idIndexMarker637"/>环境，其中包含最常用的数据科学库，如<code>scikit-learn</code>、<code>MLflow</code>和<code>matplotlib</code>。</p>
			<p>到目前为止，您已经编写了训练脚本，并且使用所需的<code>sklearn</code>库定义了 AzureML 环境。在下一部分中，您将开始关于计算集群的培训。</p>
			<h3>在实验中提交 ScriptRunConfig</h3>
			<p>一旦有了<a id="_idIndexMarker638"/>脚本和 AzureML 环境定义，就可以提交<code>ScriptRunConfig</code>在远程计算集群上执行。在<code>chapter08.ipynb</code>笔记本的新单元格中，添加以下代码:</p>
			<pre>from azureml.core import Workspace, Experiment
from azureml.core import ScriptRunConfig
ws <a id="_idTextAnchor131"/>= Workspace.from_config()
target = ws.compute_targets['cpu-sm-cluster']
script = ScriptRunConfig(
    source_directory='diabetes-training',
    script='training.py',
    environment=diabetes_env,
    compute_target=target,
    arguments=['--alpha', 0.01]
)
exp = Experiment(ws, 'chapter08-diabetes')
run = exp.submit(script)
run.wait_for_completion(show_output=True)</pre>
			<p>这段代码与前面几节中用于提交<code>greeter.py</code>脚本的代码相同。您将获得对 AzureML 工作区和计算集群的引用，您将在那里执行作业。您定义了一个<code>ScriptRunConfig</code>对象，在这里您定义了要执行的脚本的位置、您在上一节中定义的环境以及目标计算。您还可以将<code>alpha</code>参数传递给脚本。在最后一段代码中，您创建了一个实验并提交<code>ScriptRunConfig</code>来执行。</p>
			<p>使用这段代码，您触发了您在本章前面的<em class="italic">在计算集群</em>上训练糖尿病模型部分的<em class="italic">图 8.22 </em>中看到的流程。</p>
			<p>一旦<a id="_idIndexMarker639"/>训练完成，您将能够导航到实验，选择运行<code>,</code>并观察从训练过程中收集的指标，如图<em class="italic">图 8.26 </em>所示:</p>
			<div><div><img src="img/B16777_08_026.jpg" alt="Figure 8.26 – Logged metrics from a script running on a remote compute cluster&#13;&#10;" width="1650" height="1126"/>
				</div>
			</div>
			<p class="figure-caption">图 8.26–远程计算集群上运行的脚本记录的指标</p>
			<p>到目前为止，您已经成功地在远程计算集群上的单个节点中执行了<code>diabetes</code>模型训练脚本，并且您已经在<a id="_idIndexMarker640"/> AzureML 实验的运行中记录了指标和经过训练的模型。</p>
			<p>在下一节中，您将发现不同的方法来扩展您的计算工作，并利用计算集群上的多个节点。</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor132"/>在模型训练期间使用多个计算节点</h2>
			<p>正如您在第 4 章 、<em class="italic">配置工作空间</em>的<em class="italic">计算集群</em>部分中所看到的，集群<a id="_idIndexMarker641"/>可以从 0 个计算节点扩展到任意多个。在模型训练阶段，集群中需要多个节点有几个原因。它们如下:</p>
			<ul>
				<li><strong class="bold">并行执行不相关的模型训练实例</strong>:当你在一个团队中工作时，有多个实验并行运行是很常见的。每个作业都可以在单个节点上运行，就像您在上一节中所做的那样。</li>
				<li><strong class="bold">单一模型的并行训练，也称为分布式训练</strong>:这是一个高级场景，您使用的框架是 PyTorch 和 TensorFlow 使用的<strong class="bold"> Apache </strong> <strong class="bold"> Horovod </strong>分布式<a id="_idIndexMarker642"/>深度学习训练框架。有两种类型的分布式培训选项:<ul><li>哇</li><li><strong class="bold">模型并行</strong>:你<a id="_idIndexMarker644"/>在不同的计算节点上训练模型的比特。每个节点只负责训练整个模型的一小部分，每次需要传播步骤时，节点之间都会进行同步。</li></ul></li>
				<li>您在上一部分中训练的<code>LassoLars</code>模型的<code>alpha</code>参数。您可能希望探索这些参数<a id="_idIndexMarker645"/>的多个值，以选择在训练数据集上表现最佳的模型。这是一个叫做超参数调优的过程，你会在<a href="B16777_09_Final_VK_ePub.xhtml#_idTextAnchor136"> <em class="italic">第九章</em> </a>、<em class="italic">优化 ML 模型</em>中了解到更多。</li>
				<li><strong class="bold">并行训练多个模型以选择最佳方案</strong>:这是你在<a href="B16777_05_Final_VK_ePub.xhtml#_idTextAnchor072"> <em class="italic">第五章</em></a><em class="italic">中已经发现的 AutoML 过程，让机器做模型训练</em>。在<a href="B16777_09_Final_VK_ePub.xhtml#_idTextAnchor136"> <em class="italic">第 9 章</em> </a>、<em class="italic">优化 ML 模型、</em>使用代码运行 AutoML 实验章节中，您也会再次看到这种方法。</li>
			</ul>
			<p>在本节中，您了解了在计算集群中利用多个节点的不同方法。您将在第九章 、<em class="italic">优化 ML 模型</em>中深入探讨后两种方法。</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor133"/>总结</h1>
			<p>在本章中，您了解了在 AzureML 工作空间中创建 ML 模型的各种方法。您从一个简单的回归模型开始，这个模型是在 Jupyter 笔记本的内核进程中训练的。您学习了如何从您训练的模型中跟踪指标。然后，您将培训流程扩展到您在<a href="B16777_07_Final_VK_ePub.xhtml#_idTextAnchor102"> <em class="italic">第 7 章</em> </a>，<em class="italic">AzureML Python SDK</em>中创建的<code>cpu-sm-cluster</code>计算集群中。在向外扩展到远程计算集群时，您了解了什么是 AzureML 环境，以及如何通过查看日志来对远程执行进行故障排除。</p>
			<p>在下一章中，您将基于这些知识，使用多个计算机节点来执行并行化的<em class="italic">超参数调整</em>过程，该过程将为您的模型定位最佳参数。您还将了解如何使用 AzureML SDK 的 AutoML 功能完全自动化模型选择、训练和调优。</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor134"/>问题</h1>
			<p>在每一章中，你会发现几个问题来检查你对所讨论主题的理解:。</p>
			<ol>
				<li value="1">You want to log the number of validation rows you will use within a script. Which method of the <code>Run</code> class will you use?<p>a.<code>log_table</code></p><p>b.<code>log_row</code></p><p>c.<code>log</code></p></li>
				<li>You want to run a Python script that utilizes <code>scikit-learn</code>. How would you configure the AzureML environment?<p>a.添加<code>scikit-learn Conda dependency.</code></p><p>b.添加<code>sklearn Conda dependency.</code></p><p>c.使用 AzureML <code>Azure-Minimal</code>环境，它已经包含了所需的依赖项。</p></li>
				<li>You need to use <code>MLflow</code> to track the metrics generated in an Experiment and store them in your AzureML workspace. Which two pip packages do you need to have in your Conda environment?<p>a.<code>mlflow</code></p><p>b.<code>azureml-mlflow</code></p><p>c.<code>sklearn</code></p><p>d.<code>logger</code></p></li>
				<li>You need to use <code>MLflow</code> to track the value <code>0.1</code> for the <code>training_rate</code> metric. Which of the following code achieves this requirement? Assume all classes are correctly imported at the top of the script:<p>a.<code>mlflow.log_metric('training_rate', 0.1)</code></p><p>b.<code>run.log('training_rate', 0.1)</code></p><p>c.<code>logger.log('training_rate', 0.1)</code></p></li>
			</ol>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor135"/>延伸阅读</h1>
			<p>本节提供了一个 web 资源列表，帮助您扩展 AzureML SDK 和本章中使用的各种代码片段的知识:</p>
			<ul>
				<li>糖尿病数据集的来源:<a href="https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html">https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html</a></li>
				<li><em class="italic">套索</em>模型文档在<em class="italic"> scikit-learn </em>网站:<a href="https://scikit-learn.org/stable/modules/linear_model.html#lars-lasso">https://sci kit-learn . org/stable/modules/linear _ model . html # Lars-lasso</a></li>
				<li><em class="italic"> plotly </em>开源图形库:【https://github.com/plotly/plotly.py T2】</li>
				<li>MLflow 跟踪 API 参考:<a href="https://mlflow.org/docs/latest/quickstart.html#using-the-tracking-api">https://ml flow . org/docs/latest/quick start . html # using-the-Tracking-API</a></li>
				<li><code>.amlignore</code>和的语法。<code>gitignore</code>文件:【https://git-scm.com/docs/gitignore】T2</li>
				<li>https://flake8.pycqa.org<a href="https://flake8.pycqa.org">代码林挺</a></li>
			</ul>
		</div>
	</div>
</body></html>