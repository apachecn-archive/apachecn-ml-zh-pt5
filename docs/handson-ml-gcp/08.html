<html><head/><body><html xmlns:epub="http://www.idpf.org/2007/ops">

    <head>

        <title>Creating ML Applications with Firebase</title>

        

        <meta charset="utf-8"/>

<meta content="urn:uuid:c0dc9385-c68c-47e3-9ef8-4abf6976fdcb" name="Adept.expected.resource"/>

    </head>



    <body>

        



                            

                    <h1 class="header-title">用 Firebase 创建 ML 应用程序</h1>

                

            

            

                

<p>在前一章中，我们学习了使用一些不同的谷歌机器学习 API 来预测/分类一个事件。然而，我们在 Datalab 中完成了所有的工作。在现实世界中，我们可能希望将机器学习 API 集成到我们构建的 web 应用程序或移动应用程序中。在这种情况下，Firebase 就派上了用场。Firebase 是一个允许我们在没有服务器端编程的情况下构建 web 和移动应用程序的平台。Firebase 提供了多种特性，确保开发人员专注于构建应用程序，而后端则由他们负责。Firebase 提供的一些功能包括:</p>

<ul>

<li>实时数据库</li>

<li>文件存储器</li>

<li>云函数</li>

<li>主办；主持</li>

<li>性能监控</li>

<li>分析学</li>

<li>证明</li>

</ul>

<p>在这一章中，我们将更多地了解 Firebase 提供的各种功能。此外，为了了解 Firebase 如何帮助构建具有机器学习功能的应用程序，我们将构建一个 web 应用程序和一个移动应用程序，使用 Google Translate API 将任何给定语言的文本翻译成英语，并提供最多的翻译文本。</p>





            



            

        

    </body>



</html>
<html xmlns:epub="http://www.idpf.org/2007/ops">

    <head>

        <title>Features of Firebase</title>

        

        <meta charset="utf-8"/>

<meta content="urn:uuid:c0dc9385-c68c-47e3-9ef8-4abf6976fdcb" name="Adept.expected.resource"/>

    </head>



    <body>

        



                            

                    <h1 class="header-title">火碱的特性</h1>

                

            

            

                

<p>Firebase 提供的一些功能如下:</p>

<ul>

<li><strong>实时数据库</strong>:使我们能够在几毫秒内存储和同步应用数据</li>

<li><strong> Cloud firestore </strong>:使我们能够在全球范围内存储和同步数据</li>

<li><strong>云功能</strong>:使我们能够在不管理服务器的情况下运行后端代码</li>

<li><strong>托管</strong>:快速安全地交付 web 应用资产</li>

<li><strong>性能监控</strong>:帮助深入了解应用的性能</li>

<li><strong> Crashlytics </strong>:通过强大的实时崩溃报告，使我们能够确定问题的优先级并解决问题</li>

<li><strong>认证</strong>:帮助我们简单安全地认证用户</li>

<li>云存储:使我们能够以谷歌的规模存储和提供文件</li>

<li><strong>预测</strong>:使我们能够根据预测的行为定义动态用户组</li>

<li><strong>远程配置</strong>:使我们能够修改我们的应用，而无需部署新版本</li>

<li><strong>应用索引</strong>:使我们能够推动移动应用的搜索流量</li>

<li><strong>云消息</strong>:使我们能够发送有针对性的消息和通知</li>

<li><strong>动态链接</strong>:使我们能够通过使用具有属性的深层链接来推动增长</li>

<li><strong>邀请</strong>:使我们能够通过使用深层归因链接来推动增长</li>

</ul>

<p>在这一章中，我们将构建一个应用程序，它接受输入文本并将其翻译成英语——首先是一个 web 应用程序，然后是一个移动应用程序。</p>





            



            

        

    </body>



</html>
<html xmlns:epub="http://www.idpf.org/2007/ops">

    <head>

        <title>Building a web application</title>

        

        <meta charset="utf-8"/>

<meta content="urn:uuid:c0dc9385-c68c-47e3-9ef8-4abf6976fdcb" name="Adept.expected.resource"/>

    </head>



    <body>

        



                            

                    <h1 class="header-title">构建 web 应用程序</h1>

                

            

            

                

<p>为了构建 web 应用程序，我们使用 Node.js。</p>

<p>下载并安装 Node.js:</p>

<ol>

<li><kbd>node.js</kbd>可以从这里的链接下载:<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>。<br/>对于我们现在正在构建的版本，我们将在 Windows 64 位机器上使用 Node.js 的 8.11.1 LTS 版本。</li>

<li>一旦你从<a href="https://nodejs.org/dist/v8.11.1/node-v8.11.1-x64.msi">https://nodejs.org/dist/v8.11.1/node-v8.11.1-x64.msi</a>下载了可执行文件，确保使用默认参数安装 Node.js。</li>

</ol>

<p>创建 Firebase 项目:</p>

<ol>

<li>登陆 Firebase 控制台可以创建一个 Firebase 项目:<a href="https://console.firebase.google.com/">https://console.firebase.google.com</a></li>

<li>在控制台中，单击添加项目:</li>

</ol>

<div><img src="img/d0e73c87-b687-41ba-aa70-3257a4b986d5.png" style=""/></div>

<ol start="3">

<li>输入项目名称(以红色突出显示)并获取项目 ID(以黑色突出显示)，如下所示:</li>

</ol>

<div><img src="img/289a67db-84a6-4ffd-80a7-9cbd8141346c.png" style=""/></div>

<ol start="4">

<li>使用 Node.js 包管理器安装 Firebase 工具，如下所示:<ul style="padding-left: 1px">

<li>将目录切换到需要存储<kbd>firebase</kbd>功能文件的文件夹。在下面的截图中，我们在<kbd>E</kbd>驱动器中创建了一个名为<kbd>firebase</kbd>的文件夹:</li>

</ul>

</li>

</ol>

<div><img src="img/a07da3ae-5716-4fd7-9109-0f80980dd6c7.png" style=""/></div>

<ol start="5">

<li>我们使用以下代码片段安装 Firebase 工具:</li>

</ol>

<div><img src="img/c90d5a0e-51f7-45fc-83e6-4b99ee707fff.png" style=""/></div>

<p>登录并初始化 Firebase:</p>

<ol>

<li>我们通过指定以下内容登录 Firebase:</li>

</ol>

<pre style="padding-left: 60px"><strong>firebase login --reauth</strong></pre>

<ol start="2">

<li>前面的代码片段允许我们使用凭据登录。确保允许 Firebase CLI 访问您的 Google 帐户。</li>

<li>一旦我们登录到 Firebase，我们初始化<kbd>firebase</kbd>如下:</li>

</ol>

<pre style="padding-left: 60px"><strong>firebase init</strong></pre>

<ol start="4">

<li>您将看到以下屏幕:</li>

</ol>

<div><img src="img/c1fdcdf4-af7d-489c-b9c7-8b7507a85b0a.png" style=""/></div>

<ol start="5">

<li>按下<em> Y </em>初始化 Firebase。</li>

</ol>

<ol start="6">

<li>通过按空格键选择当前应用所需的功能，选择完成后，按<em> Enter </em>:</li>

</ol>

<div><img src="img/334ae5fc-9f99-486f-84c9-35710568d815.png" style=""/></div>

<ol start="7">

<li>一旦选定，对于我们在这里使用的版本，让我们指定我们的函数使用 JavaScript 部署，如下所示:</li>

</ol>

<div><img src="img/129cda59-384c-4302-98c5-c23a4903fef1.png" style=""/></div>

<ol start="8">

<li>选中后，我们用项目目录设置项目:</li>

</ol>

<div><img src="img/bd43fce2-8e09-4523-b36d-32ab9b2c5579.png"/></div>

<p class="mce-root CDPAlignLeft CDPAlign" style="padding-left: 60px">请注意，<kbd>mytranslator</kbd>是我们在<em>步骤 2 </em>中创建的项目。另请注意，一旦我们初始化了 Firebase，文件夹结构如下所示:</p>

<div><img src="img/56d7a5b4-af7c-49de-9e35-0c2e03efdc5f.png" style=""/></div>

<ol start="9">

<li>在命令提示符下，初始化 Firebase 后，按<em>键输入</em>出现各种提示。在初始化结束时，您应该会收到完成初始化的确认，如下所示:</li>

</ol>

<div><img src="img/0d9a7645-2078-4cb3-9b29-9c7d17519931.png" style=""/></div>

<p>滚动到<kbd>functions</kbd>文件夹后，使用 Node.js 包管理器安装 Google Translate:</p>

<div><img src="img/75d1e6f5-2658-4050-9c64-5e0735f6d8c2.png" style=""/></div>

<p>我们指定了用例所需的所有功能(公共 API 方法)。这些函数处理所有的服务器编程:</p>

<ol>

<li>为了指定这些，让我们用下面的代码片段覆盖位于<kbd>functions</kbd>文件夹中的<kbd>index.js</kbd>文件。</li>

</ol>

<pre style="padding-left: 60px">const functions = require('firebase-functions');<br/>const Translate = require('@google-cloud/translate');<br/>const admin = require("firebase-admin")<br/><br/>//setting connection to db<br/>admin.initializeApp();<br/><br/>const translate = new Translate({<br/>    projectId: 'mytranslator-c656d'<br/>});<br/>//Extract the most searched term<br/><br/>exports.getMessageStats=functions.https.onRequest((req,res) =&gt;<br/> {<br/> var output;<br/> var db = admin.database();<br/> var ref = db.ref("/translateMessageStats");<br/><br/>// Attach an asynchronous callback to read the data at our posts reference<br/> ref.orderByChild("count").limitToLast(1).on("value", function(snapshot) {<br/><br/>console.log(snapshot.forEach(element =&gt; {<br/> output=element.key+" : "+element.val().count + 'times'<br/> }))<br/> res.header("Access-Control-Allow-Origin", "*");<br/> return res.send(JSON.stringify(output));<br/> }, function (errorObject) {<br/> console.log("The read failed: " + errorObject.code);<br/> });<br/>})<br/><br/>// create a public API method of name "translateMessage"<br/><br/>exports.translateMessage=functions.https.onRequest((req,res) =&gt;<br/> {<br/> const input = req.query.text;<br/><br/>translate.translate(input,'en').then(results =&gt;<br/> {<br/> const output = results[0];<br/> console.log(output);<br/><br/>const db = admin.database();<br/>var ref = db.ref("/translateMessageStats");<br/><br/>//update database<br/> var dataRef= ref.child(input);<br/><br/>dataRef.once('value', function(snapshot) {<br/> if (snapshot.exists()) {<br/> dataRef.update({"count":snapshot.val().count+1});<br/> console.log("data exists")<br/> }<br/> else<br/> {<br/> console.log("data does not exist")<br/> dataRef.update({"count":1});<br/> }<br/> });<br/><br/>res.header("Access-Control-Allow-Origin", "*");<br/> return res.send(JSON.stringify(output));<br/> })<br/>});</pre>

<ol start="2">

<li>在这段代码中，我们使用以下代码导入所需的 Node.js 包:</li>

</ol>

<pre style="padding-left: 60px">const functions = require('firebase-functions');<br/>const Translate = require('@google-cloud/translate');<br/>const admin = require("firebase-admin")</pre>

<ol start="3">

<li class="mce-root">我们通过指定以下内容来初始化与数据库的连接:</li>

</ol>

<pre style="padding-left: 60px">admin.initializeApp();</pre>

<ol start="4">

<li>我们创建<kbd>translate</kbd>对象，并将项目 ID 作为参数传递给它，如下所示:</li>

</ol>

<pre style="padding-left: 60px">const translate = new Translate({<br/>    projectId: 'mytranslator-c656d'<br/>});</pre>

<ol start="5">

<li>然后我们创建一个名为<kbd>translateMessage</kbd>的面向公众的 API，如下所示:</li>

</ol>

<pre style="padding-left: 60px">exports.translateMessage=functions.https.onRequest((req,res) =&gt;</pre>

<ol start="6">

<li>用户给出的输入通过以下行获取:</li>

</ol>

<pre style="padding-left: 60px">const input = req.query.text;</pre>

<ol start="7">

<li>输入文本的翻译和相应的翻译文本在输出中的存储由以下代码完成:</li>

</ol>

<pre style="padding-left: 60px">translate.translate(input,'en').then(results =&gt;<br/>{<br/>    const output = results[0];</pre>

<ol start="8">

<li class="mce-root">我们创建一个数据库实例，如下所示:</li>

</ol>

<pre style="padding-left: 60px">const db = admin.database();<br/> var ref = db.ref("/translateMessageStats");</pre>

<ol start="9">

<li class="mce-root">数据库中的输入被更新:</li>

</ol>

<pre style="padding-left: 60px">var dataRef= ref.child(input);</pre>

<ol start="10">

<li class="mce-root">如果给出新的输入，<kbd>count</kbd>被初始化为<kbd>1</kbd>；否则，<kbd>count</kbd>增加<kbd>1</kbd>:</li>

</ol>

<pre style="padding-left: 60px">dataRef.once('value', function(snapshot) {<br/>    if (snapshot.exists()) {<br/>        dataRef.update({"count":snapshot.val().count+1});<br/>        console.log("data exists")<br/>    }<br/>    else<br/>    {<br/>        console.log("data does not exist")<br/>        dataRef.update({"count":1});<br/>    }<br/>  });</pre>

<p>启用<strong>谷歌云翻译 API </strong>，如下所示:</p>

<div><img src="img/f8fc2986-fcf9-4097-bd42-0bc8c46c6e36.png" style=""/></div>

<p>展开<kbd>firebase</kbd>功能:</p>

<ol>

<li>我们可以部署<kbd>firebase</kbd>函数，如下图所示:</li>

</ol>

<div><img src="img/660f97c0-73eb-49b9-9a61-296816558bac.png" style=""/></div>

<ol start="2">

<li>一旦部署了该功能，请查看项目概述的开发部分中的功能:</li>

</ol>

<div><img src="img/fdde39b3-a99a-4cea-9cb1-343b53f3fb7b.png" style=""/></div>

<ol start="3">

<li>单击 Functions 后，我们应该能够看到一个包含我们刚刚创建的功能的仪表板— <kbd>translateMessage</kbd>:</li>

</ol>

<div><img src="img/4d25db6d-843c-4d0a-968f-bc9f4d3be734.png"/></div>

<p>请注意，前面的事件为我们提供了一个 URL，使用它我们应该能够翻译输入文本，如下所示:</p>

<div><img src="img/9057d9c3-0cd8-4eb7-a33f-60022317a938.png"/></div>

<p>注意 URL 中<kbd>?text=</kbd>的用法，它是输入。</p>

<p>如果执行中出现问题，我们应该能够在 Logs 选项卡(Functions dashboard 的)中了解它们。</p>

<p>此外，我们搜索的所有输入都存储在数据库中:</p>

<div><img src="img/caab7455-583e-43c8-bd50-de5a115b83b5.png" style=""/></div>

<p>注意，当搜索术语<kbd>hola</kbd>时，计数值被初始化。</p>

<p>用下面的代码片段替换<kbd>public</kbd>文件夹中<kbd>index.html</kbd>文件的内容。以下代码片段的输出将是创建一个文本框，让我们给出一个输入文本，翻译文本，并产生翻译后的输出。</p>

<ol>

<li>在执行过程中，用您自己的项目 ID 替换项目 ID <kbd>mytranslator-c656d</kbd>:</li>

</ol>

<pre style="padding-left: 60px">&lt;html&gt;<br/>  &lt;script src="img/jquery.min.js"&gt;  &lt;/script&gt;<br/>  &lt;script&gt;<br/> <br/>    $(document).ready(<br/>      getMessageStats()<br/>    );<br/>&lt;!-- The following code extracts the most searched term from the database that we create in the next function --&gt;<br/><br/>    function getMessageStats(){<br/>      var xhr = new XMLHttpRequest();<br/>      xhr.open('GET', "https://us-central1-mytranslator-c656d.cloudfunctions.net/getMessageStats", true);<br/>      xhr.send();<br/>  <br/>      xhr.onreadystatechange = processRequest;<br/> <br/>      function processRequest(e) {<br/>        if (xhr.readyState == 4) {<br/>          var response = JSON.parse(xhr.responseText);<br/>          document.getElementById("mostSearched").innerHTML=response;<br/>        }<br/>      }<br/>    }<br/>&lt;!-- the following function translates the input value into english --&gt;<br/>    function translateText()<br/>    {<br/>      var textInput= document.getElementById("input").value;<br/>      var xhr = new XMLHttpRequest();<br/>      xhr.open('GET', "https://us-central1-mytranslator-c656d.cloudfunctions.net/translateMessage?text="+textInput, true);<br/>      xhr.send();<br/> <br/>      xhr.onreadystatechange = processRequest;<br/>      function processRequest(e) {<br/><br/>        if (xhr.readyState == 4) {<br/>          var response = JSON.parse(xhr.responseText);<br/>          document.getElementById("output").innerHTML=response;<br/>          getMessageStats();<br/>        }<br/>      }<br/>    }<br/>  &lt;/script&gt;<br/>&lt;!-- the following code creates the layout of web application, with input text box and output--&gt;<br/>  &lt;body&gt;<br/>    &lt;label&gt;Enter Input Text&lt;/label&gt;<br/>    &lt;input id="input" type="text-area"&gt;&lt;/input&gt;<br/>    &lt;button onclick="translateText()" id="btnTrans"&gt;Translate&lt;/button&gt;<br/>    &lt;label id="output"&gt;&lt;/label&gt;<br/>    &lt;br/&gt;<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Most Searched element&lt;/h1&gt;<br/>      &lt;label id="mostSearched"&gt;&lt;/label&gt;<br/>    &lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>

<p>我们部署 Firebase，以便上传 HTML 文件，该文件指定我们将处理的最终 URL 的结构:</p>

<div><img src="img/96024a9e-a6c8-4f00-9b49-0d5a2190a058.png" style=""/></div>

<p>我们现在应该能够访问所示的链接，该链接有助于我们翻译文本，如下所示:</p>

<div><img src="img/beb2f050-23fb-48fa-8f0a-a0443a9f3d88.png" style=""/></div>

<p>由此可见，我们能够创建一个翻译任何给定输入文本的 web 应用程序。请注意，web 应用程序使用了由函数创建的 API 端点，前端代码只会因我们使用的框架而异——当我们在 HTML 上使用 Angular 时，它可能会有所不同，但服务器端代码将保持不变。</p>





            



            

        

    </body>



</html>
<html xmlns:epub="http://www.idpf.org/2007/ops">

    <head>

        <title>Building a mobile application</title>

        

        <meta charset="utf-8"/>

<meta content="urn:uuid:c0dc9385-c68c-47e3-9ef8-4abf6976fdcb" name="Adept.expected.resource"/>

    </head>



    <body>

        



                            

                    <h1 class="header-title">构建移动应用程序</h1>

                

            

            

                

<p>在上一节中，我们了解了为我们翻译输入的 HTML 页面的前端。在本节中，我们将构建一个 Android 应用程序的前端，它利用我们为函数生成的端点来为我们返回翻译后的文本。</p>

<p>我们创建应用程序的布局如下:</p>

<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/> &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>     xmlns:app="http://schemas.android.com/apk/res-auto"<br/>     xmlns:tools="http://schemas.android.com/tools"<br/>     android:layout_width="match_parent"<br/>     android:layout_height="match_parent"<br/>     tools:context=".MainActivity"&gt;<br/> <br/>     &lt;Button<br/>         android:id="@+id/button"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:layout_marginStart="148dp"<br/>         android:layout_marginTop="56dp"<br/>         android:text="Translate"<br/>         app:layout_constraintStart_toStartOf="parent"<br/>         app:layout_constraintTop_toBottomOf="@+id/input" /&gt;<br/> <br/>     &lt;EditText<br/>         android:id="@+id/input"<br/>         android:layout_width="wrap_content"<br/>         android:layout_height="wrap_content"<br/>         android:layout_marginStart="84dp"<br/>         android:layout_marginTop="84dp"<br/>         android:ems="10"<br/>         android:inputType="textPersonName"<br/>         app:layout_constraintStart_toStartOf="parent"<br/>         app:layout_constraintTop_toTopOf="parent" /&gt;<br/> <br/>     &lt;TextView<br/>         android:id="@+id/out"<br/>         android:layout_width="197dp"<br/>         android:layout_height="80dp"<br/>         android:layout_marginStart="92dp"<br/>         android:layout_marginTop="56dp"<br/>         app:layout_constraintStart_toStartOf="parent"<br/>         app:layout_constraintTop_toBottomOf="@+id/button" /&gt;<br/> <br/> &lt;/android.support.constraint.ConstraintLayout&gt;</pre>

<p>前面的代码会输出应用程序的布局:</p>

<div><img src="img/394b75ab-8707-4b3c-93cd-188b37613337.png" style=""/></div>

<p>注意，我们有一个接受输入的 EditText 视图。</p>

<p>按钮用于执行翻译，out 是显示输出的文本视图。</p>

<p>还要注意，在前面的代码中，我们已经确保组件与屏幕对齐。</p>

<p>在 main activity 中，我们执行以下代码:</p>

<pre><strong>package</strong> com.example.admin.translateapp;<br/> <br/> <strong>import</strong> android.os.AsyncTask;<br/> <strong>import</strong> android.support.v7.app.AppCompatActivity;<br/> <strong>import</strong> android.os.Bundle;<br/> <strong>import</strong> android.view.View;<br/> <strong>import</strong> android.widget.Button;<br/> <strong>import</strong> android.widget.EditText;<br/> <strong>import</strong> android.widget.TextView;<br/> <br/> <strong>import</strong> java.io.BufferedReader;<br/> <strong>import</strong> java.io.IOException;<br/> <strong>import</strong> java.io.InputStreamReader;<br/> <strong>import</strong> java.net.HttpURLConnection;<br/> <strong>import</strong> java.net.URL;<br/> <br/> <strong>import</strong> javax.net.ssl.HttpsURLConnection;<br/> <br/> <strong>public class</strong> MainActivity <strong>extends</strong> AppCompatActivity {<br/>     <strong>public</strong> String <strong>myurl</strong>;<br/>     <strong>public</strong> String <strong>result</strong>;<br/>     <strong>public</strong> String <strong>response</strong>;<br/>     <strong>public</strong> EditText <strong>inp</strong>;<br/>     <strong>public</strong> TextView <strong>out</strong>;<br/>     <strong>public</strong> Button <strong>btn</strong>;<br/> <br/>     @Override<br/>     <strong>protected void</strong> onCreate(Bundle savedInstanceState) {<br/>         <strong>super</strong>.onCreate(savedInstanceState);<br/>         setContentView(R.layout.<strong>activity_main</strong>);<br/>         <strong>inp</strong> = (EditText) findViewById(R.id.<strong>input</strong>);<br/>         <strong>out</strong> = (TextView) findViewById(R.id.<strong>out</strong>);<br/>         <strong>btn</strong> = (Button) findViewById(R.id.<strong>button</strong>);<br/>         <strong>myurl</strong> = <strong>"</strong><strong>http://us-central1-mytranslator-c656d.cloudfunctions.net/translateMessage?text=</strong><strong>"</strong>;<br/> <br/>         <strong>btn</strong>.setOnClickListener(<strong>new</strong> View.OnClickListener() {<br/>             <strong>public void</strong> onClick(View v) {<br/>                 RequestTask task = <strong>new</strong> RequestTask();<br/>                 task.execute(<strong>inp</strong>.getText().toString());<br/>             }<br/>         });<br/>     }<br/> <br/>     <strong>private class</strong> RequestTask <strong>extends</strong> AsyncTask&lt;String, String, String&gt; {<br/> <br/>         @Override<br/>         <strong>protected</strong> String doInBackground(String... uri) {<br/>             <strong>try</strong> {<br/>                 URL url = <strong>new</strong> URL(<strong>myurl</strong>+uri[0].toString());<br/>                 HttpURLConnection conn = (HttpURLConnection) url.openConnection();<br/>                 conn.setRequestMethod(<strong>"GET"</strong>);<br/>                 conn.connect();<br/>                 <strong>if</strong> (conn.getResponseCode() == HttpURLConnection.<strong>HTTP_OK</strong>) {<br/>                     InputStreamReader streamReader = <strong>new<br/>                            </strong> InputStreamReader(conn.getInputStream());<br/>                     //Create a new buffered reader and String Builder<br/>                     BufferedReader reader = <strong>new</strong> BufferedReader(streamReader);<br/>                     StringBuilder stringBuilder = <strong>new</strong> StringBuilder();<br/>                     //Check if the line we are reading is not null<br/>                     String inputLine;<br/>                     <strong>while</strong>((inputLine = reader.readLine()) != <strong>null</strong>){<br/>                         stringBuilder.append(inputLine);<br/>                     }<br/>                     //Close our InputStream and Buffered reader<br/>                     reader.close();<br/>                     streamReader.close();<br/>                     //Set our result equal to our stringBuilder<br/>                     <strong>result</strong> = stringBuilder.toString();<br/>                     //result = conn.getResponseMessage();<br/>                 } <strong>else</strong> {<br/>                 }<br/>             } <strong>catch</strong> (IOException e) {<br/>                 //<strong>TODO Handle problems..<br/>            </strong> }<br/>             <strong>return</strong> <strong>result</strong>;<br/>         }<br/> <br/>         @Override<br/>         <strong>protected void</strong> onPostExecute(String result1) {<br/>             <strong>super</strong>.onPostExecute(result1);<br/>             <strong>out</strong>.setText(result1);<em><br/>        </em> }<br/>     }<br/> }</pre>

<p>让我们理解前面的代码。</p>

<p>导入相关包:</p>

<pre><strong>import</strong> android.os.AsyncTask;<br/> <strong>import</strong> android.support.v7.app.AppCompatActivity;<br/> <strong>import</strong> android.os.Bundle;<br/> <strong>import</strong> android.view.View;<br/> <strong>import</strong> android.widget.Button;<br/> <strong>import</strong> android.widget.EditText;<br/> <strong>import</strong> android.widget.TextView;<br/> <br/> <strong>import</strong> java.io.BufferedReader;<br/> <strong>import</strong> java.io.IOException;<br/> <strong>import</strong> java.io.InputStreamReader;<br/> <strong>import</strong> java.net.HttpURLConnection;<br/> <strong>import</strong> java.net.URL;</pre>

<p>初始化我们在<kbd>MainActivity</kbd>类中使用的对象:</p>

<pre><strong>public</strong> String <strong>myurl</strong>;<br/> <strong>public</strong> String <strong>result</strong>;<br/> <strong>public</strong> String <strong>response</strong>;<br/> <strong>public</strong> EditText <strong>inp</strong>;<br/> <strong>public</strong> TextView <strong>out</strong>;<br/> <strong>public</strong> Button <strong>btn</strong>;</pre>

<p>此外，使用以下代码初始化视图:</p>

<pre><strong>inp</strong> = (EditText) findViewById(R.id.<strong><em>input</em></strong>);<br/> <strong>out</strong> = (TextView) findViewById(R.id.<strong><em>out</em></strong>);<br/> <strong>btn</strong> = (Button) findViewById(R.id.<strong><em>button</em></strong>);</pre>

<p>设置点击监听器:</p>

<pre><strong>btn</strong>.setOnClickListener(<strong>new</strong> View.OnClickListener() {<br/>     <strong>public void</strong> onClick(View v) {<br/>         RequestTask task = <strong>new</strong> RequestTask();<br/>         task.execute(<strong>inp</strong>.getText().toString());</pre>

<p>指定单击按钮时需要执行的任务:</p>

<pre>URL url = <strong>new</strong> URL(<strong>myurl</strong>+uri[0].toString());<br/> HttpURLConnection conn = (HttpURLConnection) url.openConnection();<br/> conn.setRequestMethod(<strong>"GET"</strong>);<br/> conn.connect();<br/> <strong>if</strong> (conn.getResponseCode() == HttpURLConnection.<strong><em>HTTP_OK</em></strong>) {<br/>     InputStreamReader streamReader = <strong>new<br/>            </strong> InputStreamReader(conn.getInputStream());<br/>     //Create a new buffered reader and String Builder<br/>     BufferedReader reader = <strong>new</strong> BufferedReader(streamReader);<br/>     StringBuilder stringBuilder = <strong>new</strong> StringBuilder();<br/>     //Check if the line we are reading is not null<br/>     String inputLine;<br/>     <strong>while</strong>((inputLine = reader.readLine()) != <strong>null</strong>){<br/>         stringBuilder.append(inputLine);<br/>     }<br/>     //Close our InputStream and Buffered reader<br/>     reader.close();<br/>     streamReader.close();<br/>     //Set our result equal to our stringBuilder<br/>     <strong>result</strong> = stringBuilder.toString();</pre>

<p>在前面的代码中，URL 被评估为我们在前面的 web 应用程序部分中看到的 URL。</p>

<p>上述代码的输出如下:</p>

<div><img src="img/374bfb06-bb99-46b7-8632-189359cb0a99.png" style=""/></div>

<p>请注意，点击按钮，我们应该能够翻译我们的文本。</p>





            



            

        

    </body>



</html>
<html xmlns:epub="http://www.idpf.org/2007/ops">

    <head>

        <title>Summary</title>

        

        <meta charset="utf-8"/>

<meta content="urn:uuid:c0dc9385-c68c-47e3-9ef8-4abf6976fdcb" name="Adept.expected.resource"/>

    </head>



    <body>

        



                            

                    <h1 class="header-title">摘要</h1>

                

            

            

                

<p>在本章中，我们了解了 Firebase 的各种特性，以及如何使用<kbd>firebase</kbd>函数来构建 web 和移动应用程序的后端。我们还使用了<kbd>firebase</kbd>函数来实时更新数据库，并从数据库中检索历史上搜索次数最多的术语。</p>





            



            

        

    </body>



</html></body></html>