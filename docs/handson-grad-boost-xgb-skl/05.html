<html><head/><body>





	

		<title>B15551_04_Final_NM_ePUB</title>

		

	

	

		<div><h1 id="_idParaDest-87"><em class="italic"> <a id="_idTextAnchor093"/>第四章</em>:从渐变 Boosting 到 XGBoost</h1>

			<p>XGBoost 是一种独特的梯度增强形式，具有几个明显的优势，这将在第五章<em class="italic">中解释。为了理解 XGBoost 相对于传统梯度增强的优势，您必须首先了解传统梯度增强的工作原理。XGBoost 结合了传统梯度增强的一般结构和超参数。在这一章中，你将发现渐变增强背后的力量，这是 XGBoost 的核心。</em></p>

			<p>在本章中，您将从头构建梯度增强模型，然后将梯度增强模型和误差与以前的结果进行比较。特别是，您将关注于<strong class="bold">学习率</strong>超参数，以构建包含 XGBoost 的强大梯度增强模型。最后，您将预览一个关于系外行星的案例研究，强调对更快算法的需求，这是大数据世界的一个关键需求，XGBoost 满足了这一需求。</p>

			<p>在本章中，我们将讨论以下主要话题:</p>

			<ul>

				<li><p>从装袋到助推</p></li>

				<li><p>梯度增强的工作原理</p></li>

				<li><p>修改梯度增强超参数</p></li>

				<li><p>接近大数据—梯度提升与 XGBoost</p></li>

			</ul>

			<h1 id="_idParaDest-88"><a id="_idTextAnchor094"/>技术要求</h1>

			<p>本章的代码可从 https://github . com/packt publishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/chapter 04 获得。</p>

			<h1 id="_idParaDest-89"><a id="_idTextAnchor095"/>从装袋到增压</h1>

			<p>在<a href="B15551_03_Final_NM_ePUB.xhtml#_idTextAnchor070"> <em class="italic">第三章</em> </a>、<em class="italic">用随机森林装袋</em>中，你了解了为什么<a id="_idIndexMarker224"/>随机森林等集成机器学习算法通过将许多机器学习模型组合成一个模型来做出更好的预测。随机森林被归类为 bagging 算法，因为它们采用自举样本(决策树)的集合。</p>

			<p>相比之下，Boosting 从单个树的错误中学习。总的思想是基于先前树的误差来调整新的树。</p>

			<p>在 boosting 中，纠正每个新树的错误是一种不同于 bagging 的方法。在套袋模型中，新的树不会注意以前的树。此外，新的树是使用 bootstrapping 从零开始构建的<a id="_idTextAnchor096"/>，最终的模型聚集了所有的单个树。然而，在 boosting 中，每个新树都是从以前的树构建的。树木不是孤立存在的；相反，它们是建立在彼此之上的。</p>

			<h2 id="_idParaDest-90">【AdaBoost 简介</h2>

			<p><strong class="bold"> AdaBoost </strong>是最早也是最受欢迎的助推模型之一。在 AdaBoost 中，每棵新树都会根据先前树的误差调整其<a id="_idIndexMarker225"/>权重。通过调整以更高百分比影响这些样本的权重，更多地关注出错的预测。通过从错误中学习，AdaBoost 可以将弱学习者转变为强学习者。弱学习者是一种机器学习算法，其表现几乎不比机会好。相比之下，更强的学习者从数据中学到了相当多的东西，并且表现得相当好。</p>

			<p>boosting 算法背后的一般思想是将弱学习者转化为强学习者。学习能力差的人比随机猜测好不了多少。但在这个疲软的开端背后有一个目的。基于这一总体思路，boosting 通过关注迭代误差修正来工作，<em class="italic">而不是</em>通过建立一个强大的基线模型。如果基础模型过于强大，学习过程必然会受到限制，从而破坏增强模型背后的总体策略。</p>

			<p>弱学习者通过数百次迭代转化为强学习者。从这个意义上说，一个小优势可以走很长的路。事实上，在过去几十年里，就产生最佳结果而言，boosting 一直是最好的通用机器学习策略之一。</p>

			<p>对 AdaBoost 的详细研究超出了本书的范围。像许多 scikit-learn 模型一样，在实践中实现 AdaBoost 很简单。<code>AdaBoostRegressor</code>和<code>AdaBoostClassifier</code>算法可以从<code>sklearn.ensemble</code>库下载，适合任何训练集。最重要的 AdaBoost 超参数是<code>n_estimators</code>，创建一个强学习器所需的树(迭代)数。</p>

			<p class="callout-heading">注意</p>

			<p class="callout">有关 AdaBoost 的更多信息，请查看官方文档:https://sci kit-learn . org/stable/modules/generated/sk learn . ensemble . adaboostclassifier . html 分类器和<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostRegressor.html">https://sci kit-learn . org/stable/modules/generated/sk learn . ensemble . adaboostregressor . html</a></p>

			<p>我们现在将转向<a id="_idIndexMarker226"/>梯度增强，它是 AdaBoost 的强大替代方案，在性能上略有优势。</p>

			<h2 id="_idParaDest-91"><a id="_idTextAnchor098"/>区分梯度推进</h2>

			<p>梯度增强使用不同于 AdaBoost 的方法。虽然梯度提升也基于<a id="_idIndexMarker227"/>错误的预测进行调整，但它将这一想法向前推进了一步:梯度提升完全基于前一棵树的预测误差来适应每一棵新树。也就是说，对于每个新的树，梯度推进查看错误，然后完全围绕这些错误构建新的树。新树不关心已经正确的预测。</p>

			<p>建立一个只关注误差的机器学习算法需要一个综合的方法，对误差求和，以做出准确的最终预测。这种方法利用残差，即模型预测值和实际值之间的差异。大致的想法是这样的:</p>

			<p><em class="italic">梯度增强计算每棵树预测的残差，并对所有残差求和以对模型进行评分。</em></p>

			<p>理解<strong class="bold">计算</strong>和<strong class="bold">求和残差</strong>是很重要的，因为这个想法是 XGBoost 的核心，是梯度增强的高级版本。当您构建自己版本的梯度增强时，计算和求和残差的过程将变得清晰。在下一节中，您将构建自己版本的渐变增强模型。首先，我们来详细了解一下梯度提升的工作原理。</p>

			<h1 id="_idParaDest-92"><a id="_idTextAnchor099"/>渐变增强的工作原理</h1>

			<p>在这一节中，我们将<a id="_idIndexMarker228"/>看看梯度推进的内幕，并通过在先前树的错误上训练新树来从头构建梯度推进模型。这里的关键数学概念是残差。接下来，我们将使用 scikit-learn 的梯度增强算法获得相同的结果。</p>

			<h2 id="_idParaDest-93"><a id="_idTextAnchor100"/>残差</h2>

			<p>残差是给定模型的误差和预测值<a id="_idIndexMarker230"/>之间的<a id="_idIndexMarker229"/>差。在统计学中，通常分析残差来确定给定的线性回归模型与数据的拟合程度。</p>

			<p>考虑下面的例子:</p>

			<ol>

				<li><p>自行车租赁</p><p>a) <em class="italic">预测</em> : 759</p><p>b) <em class="italic">结果</em> : 799</p><p>c) <em class="italic">残差</em> : 799 - 759 = 40</p></li>

				<li><p>收入</p><p>a) <em class="italic">预测</em> : 10 万</p><p>b) <em class="italic">结果</em>:88000</p><p>c) <em class="italic">剩余</em>:88000–100000 =-12000</p></li>

			</ol>

			<p>如您所见，残差告诉您模型的预测与现实有多远，它们可能是正的，也可能是负的。</p>

			<p>以下是一个显示<strong class="bold">线性回归</strong>线残差的直观示例:</p>

			<div><div><img src="img/B15551_04_01.jpg" alt="Figure 4.1 – Residuals of a linear regression line"/>

				</div>

			</div>

			<p class="figure-caption">图 4.1-线性回归线的残差</p>

			<p>线性回归的目标是最小化残差的平方。如图所示，<a id="_idIndexMarker231"/>残差直观地显示了直线与数据的拟合程度。在<a id="_idIndexMarker232"/>统计中，通常通过绘制残差来进行线性回归分析，以便更深入地了解数据。</p>

			<p>为了从头开始构建梯度推进算法，我们将计算每棵树的残差，并为残差拟合新的模型。我们现在就开始吧。</p>

			<h2 id="_idParaDest-94"><a id="_idTextAnchor101"/>学习如何从头开始构建梯度推进模型</h2>

			<p>从头构建一个渐变增强模型会让你更深入地理解渐变增强在代码中是如何工作的。在建立模型之前，我们需要访问数据，并为机器学习做准备。</p>

			<h3>处理自行车租赁数据集</h3>

			<p>我们继续使用自行车<a id="_idIndexMarker234"/>租赁数据集来比较新款与旧款:</p>

			<ol>

				<li value="1"><p>我们将从导入<code>pandas</code>和<code>numpy</code>开始。我们还将添加一行来隐藏任何警告:</p><pre>import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings('ignore')</pre></li>

				<li><p>现在，加载<code>bike_rentals_cleaned</code>数据集并查看前五行:</p><pre>df_bikes = pd.read_csv('bike_rentals_cleaned.csv')
df_bikes.head()</pre><p>您的输出应该如下所示:</p><div><img src="img/B15551_04_02.jpg" alt="Figure 4.2 – First five rows of Bike Rental Dataset"/></div><p class="figure-caption">图 4.2-自行车租赁数据集的前五行</p></li>

				<li><p>现在，将数据分成<code>X</code>和<code>y</code>。然后，将<code>X</code>和<code>y</code>分成训练集和测试集:</p><pre>X_bikes = df_bikes.iloc[:,:-1]
y_bikes = df_bikes.iloc[:,-1]
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X_bikes, y_bikes, random_state=2)</pre></li>

			</ol>

			<p>是时候从零开始构建一个梯度提升模型了！</p>

			<h3>从头开始构建梯度增强模型</h3>

			<p>下面是从头开始构建<a id="_idIndexMarker235"/>梯度推进机器学习模型的步骤:</p>

			<ol>

				<li value="1"><p>将数据拟合到决策树:您可以使用一个决策树树桩，它的<code>max_depth</code>值为<code>1</code>，或者使用一个<code>max_depth</code>值为<code>2</code>或<code>3</code>的决策树。最初的<a id="_idIndexMarker236"/>决策树，称为<code>max_depth=2</code>，将其作为<code>tree_1</code>放在训练集上，因为它是我们集合中的第一棵树:</p><pre>from sklearn.tree import DecisionTreeRegressor
tree_1 = DecisionTreeRegressor(max_depth=2, random_state=2)
tree_1.fit(X_train, y_train)</pre></li>

				<li><p>使用训练集进行预测:梯度增强中的预测最初是使用训练集进行的，而不是使用测试集进行预测。为什么？为了计算残差，我们需要在训练阶段比较预测。模型构建的测试阶段在所有的树构建完成之后结束。第一轮训练集的预测是通过将<code>predict</code>方法添加到<code>tree_1</code>并以<code>X_train</code>作为输入获得的:</p><pre>y_train_pred = tree_1.predict(X_train)</pre></li>

				<li><p>计算残差:残差是预测和目标列之间的差。从目标列<code>y_train</code>中减去<code>X_train</code>的预测，这里定义为<code>y_train_pred</code>，以计算残差:</p><pre>y2_train = y_train - y_train_pred</pre><p class="callout-heading">注意</p><p class="callout">残差被定义为<code>y2_train</code>，因为它们是下一棵树的新目标列。</p></li>

				<li><p>在残差上拟合新树:在残差上拟合新树不同于在训练集上拟合模型。主要的区别在于预测。在自行车租赁数据集中，当在残差上拟合新树时，我们应该逐渐得到更小的数字。</p><p>初始化一个新树，并将其拟合到<code>X_train</code>和残差<code>y2_train</code>:</p><pre>tree_2 = DecisionTreeRegressor(max_depth=2, random_state=2)
tree_2.fit(X_train, y2_train)</pre></li>

				<li><p>重复步骤 2-4:随着<a id="_idIndexMarker237"/>过程的继续，残差应该从正负方向逐渐接近<code>0</code>。针对估计器的数量<code>n_estimators</code>继续迭代。</p><p>让我们对第三棵树重复这个过程，如下所示:</p><pre>y2_train_pred = tree_2.predict(X_train)
y3_train = y2_train - y2_train_pred
tree_3 = DecisionTreeRegressor(max_depth=2, random_state=2)
tree_3.fit(X_train, y3_train)</pre><p>这个过程可能会持续几十、几百或几千棵树。在正常情况下，你肯定会坚持下去。要把一个弱学习者转变成强学习者，需要的不仅仅是几棵树。因为我们的目标是理解梯度增强是如何在幕后工作的，然而，我们现在将继续讨论这个基本概念。</p></li>

				<li><p>对结果求和:对结果求和需要使用测试集对每棵树进行预测，如下所示:</p><pre>y1_pred = tree_1.predict(X_test)
y2_pred = tree_2.predict(X_test)
y3_pred = tree_3.predict(X_test)</pre><p>由于预测是正负差，因此对预测求和应该会得到更接近目标列的预测，如下所示:</p><pre>y_pred = y1_pred + y2_pred + y3_pred</pre></li>

				<li><p>最后，让我们计算<strong class="bold">均方误差</strong> ( <strong class="bold"> MSE </strong>)以获得如下结果:</p><pre>from sklearn.metrics import mean_squared_error as MSE
MSE(y_test, y_pred)**0.5</pre><p>以下是预期的输出:</p><pre>911.0479538776444</pre></li>

			</ol>

			<p>对于一个还不够强的弱学习者来说，这还不错！现在让我们尝试使用 scikit-learn 获得相同的结果。</p>

			<h2 id="_idParaDest-95"><a id="_idTextAnchor102"/>在 scikit-learn 中构建梯度增强模型</h2>

			<p>让我们看看<a id="_idIndexMarker239"/>我们是否能使用 scikit-learn 的<code>GradientBoostingRegressor</code>获得与上一节相同的结果。这个<a id="_idIndexMarker240"/>可以通过一些超参数调整来完成。使用<code>GradientBoostingRegressor</code>的优点是构建更快，实现更容易:</p>

			<ol>

				<li value="1"><p>首先，从<code>sklearn.ensemble</code>库中导入回归量:</p><pre>from sklearn.ensemble import GradientBoostingRegressor</pre></li>

				<li><p>初始化<code>GradientBoostingRegressor</code>时，有几个重要的超参数。为了获得相同的结果，必须匹配<code>max_depth=2</code>和<code>random_state=2</code>。再者，既然只有三棵树，就要有<code>n_estimators=3</code>。最后，我们必须设置<code>learning_rate=1.0</code>超参数。我们很快就会对<code>learning_rate</code>有更多的了解:</p><pre>gbr = GradientBoostingRegressor(max_depth=2, n_estimators=3, random_state=2, learning_rate=1.0)</pre></li>

				<li><p>既然已经初始化了<a id="_idIndexMarker241"/>模型，那么就可以根据训练数据对其进行拟合，并根据测试数据对<a id="_idIndexMarker242"/>进行评分:</p><pre>gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
MSE(y_test, y_pred)**0.5</pre><p>结果如下:</p><pre>911.0479538776439</pre><p>结果都一样到小数点后 11 位！</p><p>回想一下，梯度推进的要点是建立一个具有足够多的树的模型，以将弱学习者转化为强学习者。这很容易通过将迭代次数<code>n_estimators</code>改为一个更大的数来实现。</p></li>

				<li><p>让我们用 30 个估计量构建一个梯度推进回归方程并进行评分:</p><pre>gbr = GradientBoostingRegressor(max_depth=2, n_estimators=30, random_state=2, learning_rate=1.0)
gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
MSE(y_test, y_pred)**0.5</pre><p>结果如下:</p><pre>857.1072323426944</pre><p>分数是一个进步。现在让我们来看看 300 个评估者:</p><pre>gbr = GradientBoostingRegressor(max_depth=2, n_estimators=300, random_state=2, learning_rate=1.0)
gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
MSE(y_test, y_pred)**0.5</pre><p>结果是这样的:</p><pre>936.3617413678853</pre></li>

			</ol>

			<p>这是一个惊喜！分数变差了！我们被误导了吗？梯度推进并不像它所宣传的那样好吗？</p>

			<p>每当你得到一个<a id="_idIndexMarker243"/>惊喜的结果，值得<a id="_idIndexMarker244"/>仔细检查代码。现在，我们没有多说什么就改变了<code>learning_rate</code>。那么，如果我们删除<code>learning_rate=1.0</code>并使用 scikit-learn 默认值，会发生什么呢？</p>

			<p>让我们来看看:</p>

			<pre>gbr = GradientBoostingRegressor(max_depth=2, n_estimators=300, random_state=2)
gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
MSE(y_test, y_pred)**0.5</pre>

			<p>结果是这样的:</p>

			<pre>653.7456840231495</pre>

			<p>难以置信！通过对<code>learning_rate</code>超参数使用 scikit-learn 默认值，分数从<code>936</code>变为<code>654</code>。</p>

			<p>在下一节中，我们将详细了解不同的梯度增强超参数，重点是<code>learning_rate</code>超参数。</p>

			<h1 id="_idParaDest-96"><a id="_idTextAnchor103"/>修改梯度增强超参数</h1>

			<p>在本节中，我们将重点关注<code>learning_rate</code>，最重要的梯度增强<a id="_idIndexMarker245"/>超参数，除了<code>n_estimators</code>，模型中迭代或树的数量。我们还将调查一些树超参数和<code>subsample</code>，这导致了<code>RandomizedSearchCV</code>，并将结果与 XGBoost 进行比较。</p>

			<h2 id="_idParaDest-97"><a id="_idTextAnchor104"/>学习 _ 速率</h2>

			<p>在最后的<a id="_idIndexMarker246"/>部分，将<code>GradientBoostingRegressor</code>的<code>learning_rate</code>值从<code>1.0</code>改为 scikit-learn 的默认值<code>0.1</code>，获得了巨大的收益。</p>

			<p><code>learning_rate</code>，也被称为<em class="italic">收缩</em>的<a id="_idIndexMarker247"/>，收缩<a id="_idIndexMarker248"/>个体树的贡献，以便在建立模型时没有树有太大的影响。如果整个集成是根据一个基础学习者的错误构建的，而没有仔细调整超参数，则模型中的早期树会对后续发展产生太大影响。<code>learning_rate</code>限制个别树木的影响。一般来说，随着<code>n_estimators</code>，树木的数量上升，<code>learning_rate</code>应该会下降。</p>

			<p>确定最佳的<code>learning_rate</code>值需要改变<code>n_estimators</code>。首先，让我们保持<code>n_estimators</code>不变，看看<code>learning_rate</code>自己做了什么。<code>learning_rate</code>范围从<code>0</code>到<code>1</code>。<code>learning_rate</code>值为<code>1</code>意味着不进行调整。<code>0.1</code>的默认值表示树的影响权重为 10%。</p>

			<p>以下是一个合理的范围:</p>

			<p><code>learning_rate_values = [0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.3, 0.5, 1.0]</code></p>

			<p>接下来，我们将通过构建一个新的<code>GradientBoostingRegressor</code>并对其进行评分来遍历这些值，以查看分数的比较情况:</p>

			<pre>for value in learning_rate_values:
    gbr = GradientBoostingRegressor(max_depth=2,   n_estimators=300, random_state=2, learning_rate=value)
    gbr.fit(X_train, y_train)
    y_pred = gbr.predict(X_test)
    rmse = MSE(y_test, y_pred)**0.5
    print('Learning Rate:', value, ', Score:', rmse)</pre>

			<p>学习率值和分数如下:</p>

			<pre>Learning Rate: 0.001 , Score: 1633.0261400367258
Learning Rate: 0.01 , Score: 831.5430182728547
Learning Rate: 0.05 , Score: 685.0192988749717
Learning Rate: 0.1 , Score: 653.7456840231495
Learning Rate: 0.15 , Score: 687.666134269379
Learning Rate: 0.2 , Score: 664.312804425697
Learning Rate: 0.3 , Score: 689.4190385930236
Learning Rate: 0.5 , Score: 693.8856905068778
Learning Rate: 1.0 , Score: 936.3617413678853</pre>

			<p>正如<a id="_idIndexMarker249"/>从输出中看到的，<code>0.1</code>的<a id="_idIndexMarker250"/>缺省值<code>learning_rate</code>给出了 300 棵树的最佳分数。</p>

			<p>现在让我们改变一下<code>n_estimators</code>。使用前面的代码，我们可以生成包含 30、300 和 3000 棵树的<code>n_estimators</code>的<code>learning_rate</code>图，如下图所示:</p>

			<div><div><img src="img/B15551_04_03.jpg" alt="Figure 4.3 – learning_rate plot for 30 trees"/>

				</div>

			</div>

			<p class="figure-caption">图 4.3–30 棵树的学习率图</p>

			<p>正如你<a id="_idIndexMarker251"/>所见，有 30 棵树时，<code>learning_rate</code>值<a id="_idIndexMarker252"/>在<code>0.3</code>左右达到峰值。</p>

			<p>现在，让我们来看看 3000 棵树的<code>learning_rate</code>图:</p>

			<div><div><img src="img/B15551_04_04.jpg" alt="Fig 4.4 -- learning_rate plot for 3,000 trees"/>

				</div>

			</div>

			<p class="figure-caption">图 4.4-3000 棵树的学习率图</p>

			<p>对于 3000 棵树，<code>learning_rate</code>值在第二个值处达到峰值，该值被给定为<code>0.05</code>。</p>

			<p>这些图表强调了一起调整<code>learning_rate</code>和<code>n_estimators</code>的重要性。</p>

			<h2 id="_idParaDest-98"><a id="_idTextAnchor105"/>基础学员</h2>

			<p>梯度推进回归器中的初始决策树<a id="_idIndexMarker253"/>被称为<strong class="bold">基学习器</strong>，因为它位于集成的基础。它是这个过程中的第一个<a id="_idIndexMarker254"/>学习者。术语<em class="italic">学习者</em>在这里表示<em class="italic">弱学习者</em>转变为<em class="italic">强学习者</em>。</p>

			<p>虽然基础学习者不需要为了准确性而进行微调，如第二章 、<em class="italic">决策树</em>中所述，但是调整基础学习者来提高准确性是完全可能的。</p>

			<p>例如，我们可以选择<code>1</code>、<code>2</code>、<code>3</code>或<code>4</code>的<code>max_depth</code>值，并按如下方式比较结果:</p>

			<pre>depths = [None, 1, 2, 3, 4]
for depth in depths:
    gbr = GradientBoostingRegressor(max_depth=depth, n_estimators=300, random_state=2)
    gbr.fit(X_train, y_train)
    y_pred = gbr.predict(X_test)
    rmse = MSE(y_test, y_pred)**0.5
    print('Max Depth:', depth, ', Score:', rmse) </pre>

			<p>结果如下:</p>

			<pre>Max Depth: None , Score: 867.9366621617327
Max Depth: 1 , Score: 707.8261886858736
Max Depth: 2 , Score: 653.7456840231495
Max Depth: 3 , Score: 646.4045923317708
Max Depth: 4 , Score: 663.048387855927</pre>

			<p><code>3</code>的<code>max_depth</code>值给出最佳结果。</p>

			<p>其他基础学习者超参数，如<a href="B15551_02_Final_NM_ePUB.xhtml#_idTextAnchor047"> <em class="italic">第 2 章</em> </a>、<em class="italic">决策树深度</em>中所述，可以以类似的方式进行调整。</p>

			<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>子样本</h2>

			<p><code>subsample</code>是样本的子集。因为样本是行，所以行的子集意味着在构建每棵树时，所有的行可能都没有被<a id="_idIndexMarker255"/>包括在内。通过将<code>subsample</code>从<code>1.0</code>更改为更小的小数，树在构建阶段只选择该<a id="_idIndexMarker256"/>百分比的样本。例如，<code>subsample=0.8</code>将为每棵树选择 80%的样本。</p>

			<p>继续<code>max_depth=3</code>，我们尝试一系列子样本百分比来改善结果:</p>

			<pre>samples = [1, 0.9, 0.8, 0.7, 0.6, 0.5]
for sample in samples:
    gbr = GradientBoostingRegressor(max_depth=3, n_estimators=300, subsample=sample, random_state=2)
    gbr.fit(X_train, y_train)
    y_pred = gbr.predict(X_test)
    rmse = MSE(y_test, y_pred)**0.5
    print('Subsample:', sample, ', Score:', rmse)</pre>

			<p>结果如下:</p>

			<pre>Subsample: 1 , Score: 646.4045923317708
Subsample: 0.9 , Score: 620.1819001443569
Subsample: 0.8 , Score: 617.2355650565677
Subsample: 0.7 , Score: 612.9879156983139
Subsample: 0.6 , Score: 622.6385116402317
Subsample: 0.5 , Score: 626.9974073227554</pre>

			<p>拥有 300 棵树的<code>0.7</code>的<code>subsample</code>值<a id="_idIndexMarker257"/>和<code>3</code>的<code>max_depth</code>产生了迄今为止最好的分数。</p>

			<p>当<code>subsample</code>不等于<code>1.0</code>时，模型被归类为<strong class="bold">随机梯度下降</strong>，其中<em class="italic">随机</em>表示模型中固有一些随机性。</p>

			<h2 id="_idParaDest-100"><a id="_idTextAnchor107"/>随机试验</h2>

			<p>我们有一个<a id="_idIndexMarker258"/>好的工作模型，但是我们还没有执行网格搜索，如<a href="B15551_02_Final_NM_ePUB.xhtml#_idTextAnchor047"> <em class="italic">第 2 章</em> </a>、<em class="italic">决策树深度</em>所述。我们的<a id="_idIndexMarker259"/>初步分析表明，以<code>max_depth=3</code>、<code>subsample=0.7</code>、<code>n_estimators=300</code>和<code>learning_rate = 0.1</code>为中心的网格搜索是一个很好的起点。我们已经表明，随着<code>n_estimators</code>上升，<code>learning_rate</code>应该下降:</p>

			<ol>

				<li value="1"><p>这里是一个可能的起点:</p><pre>params={'subsample':[0.65, 0.7, 0.75],
        'n_estimators':[300, 500, 1000],
         'learning_rate':[0.05, 0.075, 0.1]}</pre><p>由于<code>n_estimators</code>从起始值 300 开始上升，<code>learning_rate</code>从<code>0.1</code>的起始值开始下降。让我们保留<code>max_depth=3</code>来限制方差。</p><p>对于 27 种可能的超参数组合，我们使用<code>RandomizedSearchCV</code>来尝试其中的 10 种组合，希望找到一个好的模型。</p><p class="callout-heading">注意</p><p class="callout">虽然<code>GridSearchCV</code>有 27 种组合是可行的，但在某种程度上，你会有太多的可能性，而<code>RandomizedSearchCV</code>将变得必不可少。我们在这里使用<code>RandomizedSearchCV</code>来练习和加速计算。</p></li>

				<li><p>让我们导入<code>RandomizedSearchCV</code>并初始化一个梯度推进模型:</p><pre>from sklearn.model_selection import RandomizedSearchCV
gbr = GradientBoostingRegressor(max_depth=3, random_state=2)</pre></li>

				<li><p>接下来，用<code>gbr</code>和<code>params</code>初始化<code>RandomizedSearchCV</code>，除了迭代次数、得分和折叠次数。回想一下，<code>n_jobs=-1</code>可以加速计算，<code>random_state=2</code>可以保证结果的<a id="_idIndexMarker260"/>一致性；</p><pre>rand_reg = RandomizedSearchCV(gbr, params, n_iter=10, scoring='neg_mean_squared_error', cv=5, n_jobs=-1, random_state=2)</pre></li>

				<li><p>现在，在训练集上拟合模型<a id="_idIndexMarker261"/>,并获得最佳参数和分数:</p><pre>rand_reg.fit(X_train, y_train)
best_model = rand_reg.best_estimator_
best_params = rand_reg.best_params_
print("Best params:", best_params)
best_score = np.sqrt(-rand_reg.best_score_)
print("Training score: {:.3f}".format(best_score))
y_pred = best_model.predict(X_test)
rmse_test = MSE(y_test, y_pred)**0.5
print('Test set score: {:.3f}'.format(rmse_test))</pre><p>结果如下:</p><pre>Best params: {'learning_rate': 0.05, 'n_estimators': 300, 'subsample': 0.65}
Training score: 636.200
Test set score: 625.985</pre><p>从这里开始，单独或成对地改变参数是值得尝试的。尽管目前最好的模型有<code>n_estimators=300</code>，但是通过仔细调整<code>learning_rate</code>值，提高这个超参数肯定会获得更好的结果。<code>subsample</code>也许可以拿来做实验。</p></li>

				<li><p>经过<a id="_idIndexMarker262"/>几轮实验，我们<a id="_idIndexMarker263"/>获得了以下模型:</p><pre>gbr = GradientBoostingRegressor(max_depth=3, n_estimators=1600, subsample=0.75, learning_rate=0.02, random_state=2)
gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
MSE(y_test, y_pred)**0.5 </pre><p>结果如下:</p><pre>596.9544588974487</pre></li>

			</ol>

			<p>在<code>1600</code>的<code>n_estimators</code>值较大，在<code>0.02</code>的<code>learning_rate</code>值较小，在<code>0.75</code>的<a id="_idIndexMarker264"/>值与<code>subsample</code>值相当，在<code>3</code>的<code>max_depth</code>值相同的情况下，我们得到了最佳的<code>597</code>。</p>

			<p>也许可以做得更好。我们鼓励你去尝试！</p>

			<p>现在，让我们看看 XGBoost 与梯度增强有什么不同，它使用的是到目前为止介绍过的相同超参数。</p>

			<h2 id="_idParaDest-101"><a id="_idTextAnchor108"/> XGBoost</h2>

			<p>XGBoost 是<a id="_idIndexMarker265"/>梯度提升的高级版本，具有相同的一般结构，这意味着它通过对树的残差求和，将弱学习器转换为强学习器。</p>

			<p>超参数与上一节的唯一区别是 XGBoost 将<code>learning_rate</code>称为<code>eta</code>。</p>

			<p>让我们用相同的超参数构建一个 XGBoost 回归器来比较结果。</p>

			<p>从<code>xgboost</code>导入<code>XGBRegressor</code>，然后对模型进行如下初始化和评分:</p>

			<pre>from xgboost import XGBRegressor
xg_reg = XGBRegressor(max_depth=3, n_estimators=1600, eta=0.02, subsample=0.75, random_state=2)
xg_reg.fit(X_train, y_train)
y_pred = xg_reg.predict(X_test)
MSE(y_test, y_pred)**0.5</pre>

			<p>结果是这样的:</p>

			<pre>584.339544309016</pre>

			<p>分数更好。至于分数为什么更好的原因将在下一章揭晓，<a href="B15551_05_Final_NM_ePUB.xhtml#_idTextAnchor117"> <em class="italic">第五章</em> </a>，<em class="italic"> XGBoost 揭开</em>。</p>

			<p>准确性和速度是建立机器学习模型时最重要的两个概念，我们已经多次证明 XGBoost 非常准确。XGBoost 通常优于梯度增强，因为它始终能提供更好的结果，而且速度更快，如下面的案例研究所示。</p>

			<h1 id="_idParaDest-102"><a id="_idTextAnchor109"/>走近大数据——梯度推进与 XGBoost</h1>

			<p>在<a id="_idIndexMarker266"/>现实世界中，数据集<a id="_idIndexMarker267"/>可能非常庞大，有数万亿个数据点。由于一台机器的资源有限，将工作限制在一台计算机上可能是不利的<a id="_idIndexMarker268"/>。在处理大数据时，云通常用于利用并行计算机。</p>

			<p>当数据集突破计算极限时，它就变得很大。到目前为止，在本书中，通过将数据集限制为具有一百或更少列的数万行，应该没有显著的时间延迟，除非您遇到错误(每个人都会遇到)。</p>

			<p>在这一节中，我们将考察<strong class="bold">系外行星</strong>随时间的变化。该数据集有 5087 行和 3189 列，记录了恒星生命周期不同时间的光通量。将列和行相乘得到 150 万个数据点。使用 100 棵树的基线，我们需要 1.5 亿个数据点来建立一个模型。</p>

			<p>在这一部分，我的 2013 款 MacBook Air 的等待时间约为 5 分钟。新电脑应该更快。我选择了系外行星数据集，这样等待时间在不占用你的电脑很长时间的情况下发挥了重要作用。</p>

			<h2 id="_idParaDest-103"><a id="_idTextAnchor110"/>介绍系外行星数据集</h2>

			<p><a id="_idIndexMarker269"/>系外行星数据集取自 Kaggle，日期大约在 2017 年:<a href="https://www.kaggle.com/keplersmachines/kepler-labelled-time-series-data">https://www . ka ggle . com/keplers machines/Kepler-labelled-time-series-data</a>。数据集<a id="_idIndexMarker270"/>包含关于恒星光线的信息。每一行都是一颗独立的星星，每一列都显示出不同的光线模式。除了光线模式，如果恒星拥有一颗系外行星，一颗系外行星列也被标记为<code>2</code>；否则贴上<code>1</code>的标签。</p>

			<p>数据集记录了来自数千颗恒星的光通量<a id="_idIndexMarker271"/>。<strong class="bold">光通量</strong>，通常被称为<strong class="bold">光通量</strong>，是恒星被感知的<a id="_idIndexMarker272"/>亮度。</p>

			<p class="callout-heading">注意</p>

			<p class="callout">感知亮度不同于实际亮度。例如，非常远的非常亮的恒星可能光通量很小(看起来很暗)，而非常近的中等亮度的恒星，如太阳，可能光通量很大(看起来很亮)。</p>

			<p>当一颗恒星的光通量周期性变化时，这颗恒星可能正在被一颗系外行星围绕<a id="_idIndexMarker273"/>旋转。假设是，当一颗系外行星在一颗恒星前面运行时，它会阻挡一小部分光线，使感知到的<a id="_idIndexMarker274"/>亮度略微降低。</p>

			<p class="callout-heading">小费</p>

			<p class="callout">发现系外行星是罕见的。关于一颗恒星是否拥有系外行星的预测栏很少有正面的案例，这导致了不平衡的数据集。不平衡的数据集需要额外的预防措施。我们将在<a href="B15551_07_Final_NM_ePUB.xhtml#_idTextAnchor161"> <em class="italic">第七章</em> </a>、<em class="italic">用 XGBoost </em>发现系外行星中涉及不平衡数据集，在那里我们将更详细地讨论这个数据集。</p>

			<p>接下来，让我们访问系外行星数据集，并为机器学习做准备。</p>

			<h2 id="_idParaDest-104"><a id="_idTextAnchor111"/>预处理系外行星数据集</h2>

			<p>系外行星<a id="_idIndexMarker275"/>数据集已经上传到我们的 GitHub 页面，网址为<a href="https://github.com/PacktPublishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/Chapter04">https://GitHub . com/packt publishing/Hands-On-Gradient-Boosting-with-XG boost-and-Scikit-learn/tree/master/chapter 04</a>。</p>

			<p>以下是为机器学习加载和预处理系外行星数据集的步骤:</p>

			<ol>

				<li value="1"><p>将<code>exoplanets.csv</code>下载到 Jupyter 笔记本所在的文件夹中。然后，打开文件看一看:</p><pre>df = pd.read_csv('exoplanets.csv')
df.head() </pre><p>数据帧将如下图所示:</p><div><img src="img/B15551_04_05.jpg" alt="Fig 4.5 – Exoplanet DataFrame"/></div><p class="figure-caption">图 4.5-系外行星数据帧</p><p>由于篇幅限制，没有显示所有列。通量列是浮动的，而<code>Label</code>列是系外行星恒星的<code>2</code>和非系外行星恒星的<code>1</code>。</p></li>

				<li><p>让我们确认所有的<a id="_idIndexMarker276"/>列都是带有<code>df.info()</code>的数字:</p><pre>df.info()</pre><p>结果如下:</p><pre>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 5087 entries, 0 to 5086
Columns: 3198 entries, LABEL to FLUX.3197
dtypes: float64(3197), int64(1)
memory usage: 124.1 MB</pre><p>从输出中可以看到，<code>3197</code>列是浮点型的，<code>1</code>列是 T2，所以所有列都是数字型的。</p></li>

				<li><p>现在，让我们用下面的代码来确认空值的数量:</p><pre>df.isnull().sum().sum()</pre><p>输出如下所示:</p><pre>0</pre><p>输出显示没有空值。</p></li>

				<li><p>由于所有的列都是数值型的，没有空值，我们可以将数据分成训练集和测试集<a id="_idIndexMarker277"/>。注意，第 0 列是目标列<code>y</code>，所有其他列是预测列<code>X</code>:</p><pre>X = df.iloc[:,1:]
y = df.iloc[:,0]
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=2)</pre></li>

			</ol>

			<p>是时候建立一个梯度推进分类器来预测恒星是否存在系外行星了。</p>

			<h2 id="_idParaDest-105"><a id="_idTextAnchor112"/>构建梯度增强分类器</h2>

			<p>梯度推进<a id="_idIndexMarker278"/>分类器的工作方式与梯度推进回归器相同。区别主要在于得分。</p>

			<p>除了<code>accuracy_score</code>之外，让我们从导入<code>GradientBoostingClassifer</code>和<code>XGBClassifier</code>开始，这样我们可以比较这两个模型:</p>

			<pre>from sklearn.ensemble import GradientBoostingClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score</pre>

			<p>接下来，我们需要一种使用计时器来比较模型的方法。</p>

			<h2 id="_idParaDest-106"><a id="_idTextAnchor113"/>计时模式</h2>

			<p>Python 附带了一个<code>time</code>库，<a id="_idIndexMarker279"/>可以用来标记时间。总的想法是在计算前后标记时间。这些时间之间的差异告诉我们计算花费了多长时间。</p>

			<p><code>time</code>库导入如下:</p>

			<pre><code>import time</code></pre>

			<p>在<code>time</code>库中，<code>.time()</code>方法以秒为单位标记时间。</p>

			<p>例如，通过使用<code>time.time()</code>分配计算前后的开始和结束时间，查看运行<code>df.info()</code>需要多长时间:</p>

			<pre>start = time.time()
df.info()
end = time.time()
elapsed = end - start
print('\nRun Time: ' + str(elapsed) + ' seconds.')</pre>

			<p><a id="_idIndexMarker280"/>输出如下:</p>

			<pre>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 5087 entries, 0 to 5086
Columns: 3198 entries, LABEL to FLUX.3197
dtypes: float64(3197), int64(1)
memory usage: 124.1 MB</pre>

			<p>运行时如下:</p>

			<pre>Run Time: 0.0525362491607666 seconds.</pre>

			<p>你的结果会与我们的不同，但希望是在同一范围内。</p>

			<p>现在让我们使用前面的代码标记时间，将<code>GradientBoostingClassifier</code>和<code>XGBoostClassifier</code>与系外行星数据集进行速度比较。</p>

			<p class="callout-heading">小费</p>

			<p class="callout">Jupyter 笔记本自带魔法功能，在命令前用<code>%</code>符号表示。<code>%timeit</code>就是这样一个神奇的功能。<code>%timeit</code>不是计算运行一次代码需要多长时间，而是计算多次运行代码需要多长时间。关于魔法功能的更多信息，请参见<a href="http://ipython.readthedocs.io/en/stable/interactive/magics.html">ipython.readthedocs.io/en/stable/interactive/magics.html</a>。</p>

			<h2 id="_idParaDest-107"><a id="_idTextAnchor114"/>比较速度</h2>

			<p>是时候让<code>GradientBoostingClassifier</code>和<code>XGBoostClassifier</code>与<a id="_idIndexMarker281"/>系外行星数据集赛跑了。我们设置了<code>max_depth=2</code>和<code>n_estimators=100</code>来限制模型的大小。先说<code>GradientBoostingClassifier</code>:</p>

			<ol>

				<li value="1"><p>首先，我们将标记开始时间。在建立和评分模型后，我们将标记结束时间。根据您的计算机速度，以下代码可能需要大约 5 分钟的时间来运行:</p><pre>start = time.time()
gbr = GradientBoostingClassifier(n_estimators=100, max_depth=2, random_state=2)
gbr.fit(X_train, y_train)
y_pred = gbr.predict(X_test)
score = accuracy_score(y_pred, y_test)
print('Score: ' + str(score))
end = time.time()
elapsed = end - start
print('\nRun Time: ' + str(elapsed) + ' seconds')</pre><p>结果是这样的:</p><pre>Score: 0.9874213836477987
Run Time: 317.6318619251251 seconds</pre><p>在我的 2013 款 MacBook Air 上运行花了 5 分多钟。对于旧电脑上的 1.5 亿个数据点来说，这已经不错了。</p><p class="callout-heading">注意</p><p class="callout">虽然 98.7%的分数通常在准确性方面非常突出，但不平衡数据集的情况并非如此，正如您将在第七章 、<em class="italic">使用 XGBoost </em>发现系外行星中看到的那样。</p></li>

				<li><p>接下来，我们将使用相同的超参数<a id="_idIndexMarker282"/>构建一个<code>XGBClassifier</code>模型，并以相同的方式标记时间:</p><pre>start = time.time()
xg_reg = XGBClassifier(n_estimators=100, max_depth=2, random_state=2)
xg_reg.fit(X_train, y_train)
y_pred = xg_reg.predict(X_test)
score = accuracy_score(y_pred, y_test)
print('Score: ' + str(score))
end = time.time()
elapsed = end - start
print('Run Time: ' + str(elapsed) + ' seconds')</pre><p>结果如下:</p><pre>Score: 0.9913522012578616
Run Time: 118.90568995475769 seconds</pre></li>

			</ol>

			<p>在我的 2013 款 MacBook Air 上，XGBoost 用时不到 2 分钟，速度提高了一倍多。也精确了半个百分点。</p>

			<p>当涉及到大数据时，两倍快的算法可以节省数周或数月的计算时间和资源。在大数据领域，这一优势是巨大的。</p>

			<p>在 boosting 领域，XGBoost 由于其无与伦比的速度和令人印象深刻的准确性而成为首选模型。</p>

			<p>至于系外行星数据集，将在第七章 、<em class="italic">使用 XGBoost </em>发现系外行星中再次讨论，这是一个重要的案例研究，揭示了处理不平衡数据集的挑战以及应对这些挑战的各种潜在解决方案。</p>

			<p class="callout-heading">注意</p>

			<p class="callout">最近买了一台 2020 的 MacBook Pro，更新了所有软件。使用相同代码的时间差异是惊人的:</p>

			<p class="callout">梯度推进运行时间:197.38 秒</p>

			<p class="callout">XGBoost 运行时间:8.66 秒</p>

			<p class="callout">相差超过 10 倍！</p>

			<h1 id="_idParaDest-108"><a id="_idTextAnchor115"/>总结</h1>

			<p>在本章中，您学习了装袋和增压的区别。通过从头开始构建梯度增强回归器，您了解了梯度增强的工作原理。您实现了各种梯度增强超参数，包括<code>learning_rate</code>、<code>n_estimators</code>、<code>max_depth</code>和<code>subsample</code>，这导致了随机梯度增强。最后，你使用大数据通过比较<code>GradientBoostingClassifier</code>和<code>XGBoostClassifier</code>的时间来预测恒星是否有系外行星，其中<code>XGBoostClassifier</code>出现的速度是两倍到十倍以上，并且更加准确。</p>

			<p>学习这些技能的好处是，你现在明白什么时候应用 XGBoost，而不是类似的机器学习算法，比如梯度提升。现在，您可以通过适当利用核心超参数，包括<code>n_estimators</code>和<code>learning_rate</code>，构建更强大的 XGBoost 和梯度增强模型。此外，你已经发展了计算时间的能力，而不是依赖直觉。</p>

			<p>恭喜你！您已经完成了 XGBoost 的所有预备章节。到目前为止，目的是在更大的 XGBoost 叙述中向您介绍机器学习和数据分析。目的是展示 XGBoost 是如何从集合方法、增强、梯度增强和大数据中出现的。</p>

			<p>下一章从 XGBoost 的高级介绍开始，除了 XGBoost 为提高速度而进行的硬件修改之外，您还将了解 XGBoost 算法背后的数学细节。您还将在希格斯玻色子发现的历史相关案例研究中使用原始 Python API 构建 XGBoost 模型。接下来的章节重点介绍了令人兴奋的细节、优势、细微差别、技巧和提示，以构建快速、高效、强大、行业就绪的 XGBoost 模型，供您在未来几年使用。</p>

		</div>

	



</body></html>